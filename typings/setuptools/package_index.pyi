"""
This type stub file was generated by pyright.
"""

import configparser
from pkg_resources import Environment

"""PyPI and direct package downloading"""
EGG_FRAGMENT = ...
HREF = ...
PYPI_MD5 = ...
URL_SCHEME = ...
EXTENSIONS = ...
_SOCKET_TIMEOUT = ...
_tmpl = ...
user_agent = ...
def parse_requirement_arg(spec): # -> Requirement:
    ...

def parse_bdist_wininst(name): # -> tuple[Unknown | None, Unknown | None, Literal['win32', 'win-amd64'] | None]:
    """Return (base,pyversion) or (None,None) for possible .exe name"""
    ...

def egg_info_for_url(url): # -> tuple[str, str]:
    ...

def distros_for_url(url, metadata=...): # -> Generator[Distribution, None, None]:
    """Yield egg or source distribution objects that might be found at a URL"""
    ...

def distros_for_location(location, basename, metadata=...): # -> list[Distribution] | Generator[Distribution, None, None]:
    """Yield egg or source distribution objects based on basename"""
    ...

def distros_for_filename(filename, metadata=...): # -> list[Distribution] | Generator[Distribution, None, None]:
    """Yield possible egg or source distribution objects based on a filename"""
    ...

def interpret_distro_name(location, basename, metadata, py_version=..., precedence=..., platform=...): # -> Generator[Distribution, None, None]:
    """Generate alternative interpretations of a source distro name

    Note: if `location` is a filesystem filename, you should call
    ``pkg_resources.normalize_path()`` on it before passing it to this
    routine!
    """
    ...

def unique_everseen(iterable, key=...): # -> Generator[object | Unknown, None, None]:
    "List unique elements, preserving order. Remember all elements ever seen."
    ...

def unique_values(func): # -> (*args: Unknown, **kwargs: Unknown) -> Generator[object | Unknown, None, None]:
    """
    Wrap a function returning an iterable such that the resulting iterable
    only ever yields unique items.
    """
    ...

REL = ...
@unique_values
def find_external_links(url, page): # -> Generator[str, None, None]:
    """Find rel="homepage" and rel="download" links in `page`, yielding URLs"""
    ...

class ContentChecker:
    """
    A null content checker that defines the interface for checking content
    """
    def feed(self, block): # -> None:
        """
        Feed a block of data to the hash.
        """
        ...
    
    def is_valid(self): # -> Literal[True]:
        """
        Check the hash. Return False if validation fails.
        """
        ...
    
    def report(self, reporter, template): # -> None:
        """
        Call reporter with information about the checker (hash name)
        substituted into the template.
        """
        ...
    


class HashChecker(ContentChecker):
    pattern = ...
    def __init__(self, hash_name, expected) -> None:
        ...
    
    @classmethod
    def from_url(cls, url): # -> ContentChecker | HashChecker:
        "Construct a (possibly null) ContentChecker from a URL"
        ...
    
    def feed(self, block): # -> None:
        ...
    
    def is_valid(self): # -> bool:
        ...
    
    def report(self, reporter, template):
        ...
    


class PackageIndex(Environment):
    """A distribution index that scans web pages for download URLs"""
    def __init__(self, index_url=..., hosts=..., ca_bundle=..., verify_ssl=..., *args, **kw) -> None:
        ...
    
    def process_url(self, url, retrieve=...): # -> None:
        """Evaluate a URL as a possible download, and maybe retrieve it"""
        ...
    
    def process_filename(self, fn, nested=...): # -> None:
        ...
    
    def url_ok(self, url, fatal=...): # -> Literal[True] | None:
        ...
    
    def scan_egg_links(self, search_path): # -> None:
        ...
    
    def scan_egg_link(self, path, entry): # -> None:
        ...
    
    def process_index(self, url, page): # -> str:
        """Process the contents of a PyPI page"""
        ...
    
    def need_version_info(self, url): # -> None:
        ...
    
    def scan_all(self, msg=..., *args): # -> None:
        ...
    
    def find_packages(self, requirement): # -> None:
        ...
    
    def obtain(self, requirement, installer=...): # -> Distribution:
        ...
    
    def check_hash(self, checker, filename, tfp): # -> None:
        """
        checker is a ContentChecker
        """
        ...
    
    def add_find_links(self, urls): # -> None:
        """Add `urls` to the list that will be prescanned for searches"""
        ...
    
    def prescan(self): # -> None:
        """Scan urls scheduled for prescanning (e.g. --find-links)"""
        ...
    
    def not_found_in_index(self, requirement): # -> None:
        ...
    
    def download(self, spec, tmpdir): # -> str | Any | None:
        """Locate and/or download `spec` to `tmpdir`, returning a local path

        `spec` may be a ``Requirement`` object, or a string containing a URL,
        an existing local filename, or a project/version requirement spec
        (i.e. the string form of a ``Requirement`` object).  If it is the URL
        of a .py file with an unambiguous ``#egg=name-version`` tag (i.e., one
        that escapes ``-`` as ``_`` throughout), a trivial ``setup.py`` is
        automatically created alongside the downloaded file.

        If `spec` is a ``Requirement`` object or a string containing a
        project/version requirement spec, this method returns the location of
        a matching distribution (possibly after downloading it to `tmpdir`).
        If `spec` is a locally existing file or directory name, it is simply
        returned unchanged.  If `spec` is a URL, it is downloaded to a subpath
        of `tmpdir`, and the local filename is returned.  Various errors may be
        raised if a problem occurs during downloading.
        """
        ...
    
    def fetch_distribution(self, requirement, tmpdir, force_scan=..., source=..., develop_ok=..., local_index=...): # -> Requirement | None:
        """Obtain a distribution suitable for fulfilling `requirement`

        `requirement` must be a ``pkg_resources.Requirement`` instance.
        If necessary, or if the `force_scan` flag is set, the requirement is
        searched for in the (online) package index as well as the locally
        installed packages.  If a distribution matching `requirement` is found,
        the returned distribution's ``location`` is the value you would have
        gotten from calling the ``download()`` method with the matching
        distribution's URL or filename.  If no matching distribution is found,
        ``None`` is returned.

        If the `source` flag is set, only source distributions and source
        checkout links will be considered.  Unless the `develop_ok` flag is
        set, development and system eggs (i.e., those using the ``.egg-info``
        format) will be ignored.
        """
        ...
    
    def fetch(self, requirement, tmpdir, force_scan=..., source=...): # -> None:
        """Obtain a file suitable for fulfilling `requirement`

        DEPRECATED; use the ``fetch_distribution()`` method now instead.  For
        backward compatibility, this routine is identical but returns the
        ``location`` of the downloaded distribution instead of a distribution
        object.
        """
        ...
    
    def gen_setup(self, filename, fragment, tmpdir): # -> str:
        ...
    
    dl_blocksize = ...
    def reporthook(self, url, filename, blocknum, blksize, size): # -> None:
        ...
    
    def open_url(self, url, warning=...): # -> _UrlopenRet | HTTPError | None:
        ...
    
    def scan_url(self, url): # -> None:
        ...
    
    def debug(self, msg, *args): # -> None:
        ...
    
    def info(self, msg, *args): # -> None:
        ...
    
    def warn(self, msg, *args): # -> None:
        ...
    


entity_sub = ...
def decode_entity(match):
    ...

def htmldecode(text): # -> str:
    """
    Decode HTML entities in the given text.

    >>> htmldecode(
    ...     'https://../package_name-0.1.2.tar.gz'
    ...     '?tokena=A&amp;tokenb=B">package_name-0.1.2.tar.gz')
    'https://../package_name-0.1.2.tar.gz?tokena=A&tokenb=B">package_name-0.1.2.tar.gz'
    """
    ...

def socket_timeout(timeout=...): # -> (func: Unknown) -> (*args: Unknown, **kwargs: Unknown) -> Unknown:
    ...

class Credential:
    """
    A username/password pair. Use like a namedtuple.
    """
    def __init__(self, username, password) -> None:
        ...
    
    def __iter__(self): # -> Generator[Unknown, None, None]:
        ...
    
    def __str__(self) -> str:
        ...
    


class PyPIConfig(configparser.RawConfigParser):
    def __init__(self) -> None:
        """
        Load from ~/.pypirc
        """
        ...
    
    @property
    def creds_by_repository(self): # -> dict[str, Credential]:
        ...
    
    def find_credential(self, url): # -> Credential | None:
        """
        If the URL indicated appears to be a repository defined in this
        config, return the credential for that repository.
        """
        ...
    


def open_with_auth(url, opener=...):
    """Open a urllib2 request, handling HTTP authentication"""
    ...

open_with_auth = ...
def fix_sf_url(url):
    ...

def local_open(url): # -> _UrlopenRet | HTTPError:
    """Read a local path, with special support for directories"""
    ...

