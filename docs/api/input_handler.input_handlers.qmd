# input_handler.input_handlers { #shiny.input_handler.input_handlers }

`input_handler.input_handlers`

Manage Shiny input handlers.

Add and/or remove input handlers of a given ``type``. Shiny uses these handlers to
pre-process input values from the client (after being deserialized) before passing them
to the ``input`` argument of an [](:func:`~shiny.App`)&#x27;s ``server`` function.

The ``type`` is based on the ``getType()`` JavaScript method on the relevant Shiny
input binding. See `this article <https://shiny.posit.co/articles/js-custom-input.html>`_
for more information on how to create custom input bindings. (The article is about
Shiny for R, but the JavaScript and general principles are the same.)



## Methods

add(type: str, force: bool = False) -&gt; Callable[[InputHandlerType], None]
    Register an input handler. This method returns a decorator that registers the
    decorated function as the handler for the given ``type``. This handler should
    accept three arguments:
    - the input ``value``
    - the input ``name``
    - the [](:class:`~shiny.Session`) object
remove(type: str)
    Unregister an input handler.



## Note

``add()`` ing an input handler will make it persist for the duration of the Python
process (unless Shiny is explicitly reloaded). For that reason, verbose naming is
encouraged to minimize the risk of colliding with other Shiny input binding(s) which
happen to use the same ``type`` (if the binding is bundled with a package, we
recommend the format of &quot;packageName.widgetName&quot;).



## Example

```{python}
#| eval: false
from shiny.input_handler import input_handlers
@input_handlers.add("mypackage.intify")
def _(value, name, session):
    return int(value)
```

On the Javascript side, the associated input binding must have a corresponding
``getType`` method:

```{python}
#| eval: false
getType: function(el) {
    return "mypackage.intify";
}
```