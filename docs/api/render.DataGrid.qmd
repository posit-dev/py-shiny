# render.DataGrid { #shiny.render.DataGrid }

`render.DataGrid(self, data, *, width='fit-content', height='500px', summary=True, filters=False, row_selection_mode='none')`

Holds the data and options for a ``shiny.render.data_frame`` output, for a
spreadsheet-like view.

## Parameters

<code><span class="parameter-name">data</span><span class="parameter-annotation-sep">:</span> <span class="parameter-annotation">[object](`object`)</span></code>

:   A pandas `DataFrame` object, or any object that has a `.to_pandas()` method
    (e.g., a Polars data frame or Arrow table).

<code><span class="parameter-name">width</span><span class="parameter-annotation-sep">:</span> <span class="parameter-annotation">[str](`str`) \| [float](`float`) \| None</span> <span class="parameter-default-sep">=</span> <span class="parameter-default">'fit-content'</span></code>

:   A _maximum_ amount of vertical space for the data grid to occupy, in CSS units
    (e.g. `"400px"`) or as a number, which will be interpreted as pixels. The
    default is `fit-content`, which sets the grid's width according to its contents.
    Set this to `100%` to use the maximum available horizontal space.

<code><span class="parameter-name">height</span><span class="parameter-annotation-sep">:</span> <span class="parameter-annotation">[Union](`typing.Union`)\[[str](`str`), [float](`float`), None\]</span> <span class="parameter-default-sep">=</span> <span class="parameter-default">'500px'</span></code>

:   A _maximum_ amount of vertical space for the data grid to occupy, in CSS units
    (e.g. `"400px"`) or as a number, which will be interpreted as pixels. If there
    are more rows than can fit in this space, the grid will scroll. Set the height
    to `None` to allow the grid to grow to fit all of the rows (this is not
    recommended for large data sets, as it may crash the browser).

<code><span class="parameter-name">summary</span><span class="parameter-annotation-sep">:</span> <span class="parameter-annotation">[Union](`typing.Union`)\[[bool](`bool`), [str](`str`)\]</span> <span class="parameter-default-sep">=</span> <span class="parameter-default">True</span></code>

:   If `True` (the default), shows a message like "Viewing rows 1 through 10 of 20"
    below the grid when not all of the rows are being shown. If `False`, the message
    is not displayed. You can also specify a string template to customize the
    message, containing `{start}`, `{end}`, and `{total}` tokens. For example:
    `"Viendo filas {start} a {end} de {total}"`.

<code><span class="parameter-name">filters</span><span class="parameter-annotation-sep">:</span> <span class="parameter-annotation">[bool](`bool`)</span> <span class="parameter-default-sep">=</span> <span class="parameter-default">False</span></code>

:   If `True`, shows a row of filter inputs below the headers, one for each column.

<code><span class="parameter-name">row_selection_mode</span><span class="parameter-annotation-sep">:</span> <span class="parameter-annotation">[Literal](`typing.Literal`)\['none', 'single', 'multiple'\]</span> <span class="parameter-default-sep">=</span> <span class="parameter-default">'none'</span></code>

:   Use `"none"` to disable row selection, `"single"` to allow a single row to be
    selected at a time, and `"multiple"` to allow multiple rows to be selected by
    clicking on them individually.

## Returns

| Type   | Description                                                                                  |
|--------|----------------------------------------------------------------------------------------------|
|        | An object suitable for being returned from a `@render.data_frame`-decorated output function. |

## See Also

[](:func:`~shiny.ui.output_data_frame`)
[](:func:`~shiny.render.data_frame`)
[](:class:`~shiny.render.DataTable`)

## Examples

```{shinylive-python}
#| standalone: true
#| components: [editor, viewer]
#| layout: vertical
#| viewerHeight: 400

## file: app.py
import pandas  # noqa: F401 (this line needed for Shinylive to load plotly.express)
import plotly.express as px
import plotly.graph_objs as go
from shinywidgets import output_widget, render_widget

from shiny import App, reactive, render, req, session, ui

# Load the Gapminder dataset
df = px.data.gapminder()

# Prepare a summary DataFrame
summary_df = (
    df.groupby("country")
    .agg(
        {
            "pop": ["min", "max", "mean"],
            "lifeExp": ["min", "max", "mean"],
            "gdpPercap": ["min", "max", "mean"],
        }
    )
    .reset_index()
)

summary_df.columns = ["_".join(col).strip() for col in summary_df.columns.values]
summary_df.rename(columns={"country_": "country"}, inplace=True)

app_ui = ui.page_fillable(
    {"class": "p-3"},
    ui.p(
        ui.strong("Instructions:"),
        " Select one or more countries in the table below to see more information.",
    ),
    ui.layout_column_wrap(
        ui.card(
            ui.output_data_frame("summary_data"),
        ),
        ui.layout_column_wrap(
            ui.card(
                output_widget("country_detail_pop", height="100%"),
            ),
            ui.card(
                output_widget("country_detail_percap", height="100%"),
            ),
            width=1 / 2,
        ),
        width=1,
    ),
)


def server(input, output, session):
    @render.data_frame
    def summary_data():
        return render.DataGrid(
            summary_df.round(2),
            row_selection_mode="multiple",
            width="100%",
            height="100%",
        )

    @reactive.Calc
    def filtered_df():
        # input.summary_data_selected_rows() is a tuple, so we must convert it to list,
        # as that's what Pandas requires for indexing.
        selected_idx = list(req(input.summary_data_selected_rows()))
        countries = summary_df.iloc[selected_idx]["country"]
        # Filter data for selected countries
        return df[df["country"].isin(countries)]

    @render_widget
    def country_detail_pop():
        # Create the plot
        fig = px.line(
            filtered_df(),
            x="year",
            y="pop",
            color="country",
            title="Population Over Time",
        )
        widget = go.FigureWidget(fig)

        @synchronize_size("country_detail_pop")
        def on_size_changed(width, height):
            widget.layout.width = width
            widget.layout.height = height

        return widget

    @render_widget
    def country_detail_percap():
        # Create the plot
        fig = px.line(
            filtered_df(),
            x="year",
            y="gdpPercap",
            color="country",
            title="GDP per Capita Over Time",
        )
        widget = go.FigureWidget(fig)

        @synchronize_size("country_detail_percap")
        def on_size_changed(width, height):
            widget.layout.width = width
            widget.layout.height = height

        return widget


# This is a hacky workaround to help Plotly plots automatically
# resize to fit their container. In the future we'll have a
# built-in solution for this.
def synchronize_size(output_id):
    def wrapper(func):
        input = session.get_current_session().input

        @reactive.Effect
        def size_updater():
            func(
                input[f".clientdata_output_{output_id}_width"](),
                input[f".clientdata_output_{output_id}_height"](),
            )

        # When the output that we're synchronizing to is invalidated,
        # clean up the size_updater Effect.
        reactive.get_current_context().on_invalidate(size_updater.destroy)

        return size_updater

    return wrapper


app = App(app_ui, server)
```