# render.data_frame { #shiny.render.data_frame }

`render.data_frame()`

Decorator for a function that returns a pandas `DataFrame` object (or similar) to
render as an interactive table or grid. Features fast virtualized scrolling, sorting,
filtering, and row selection (single or multiple).

## Returns

| Type   | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|--------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|        | A decorator for a function that returns any of the following:  1. A [](:class:`~shiny.render.DataGrid`) or [](:class:`~shiny.render.DataTable`) object,    which can be used to customize the appearance and behavior of the data frame    output. 2. A pandas [](:class:`DataFrame`) object. (Equivalent to    `shiny.render.DataGrid(df)`.) 3. Any object that has a `.to_pandas()` method (e.g., a Polars data frame or    Arrow table). (Equivalent to `shiny.render.DataGrid(df.to_pandas())`.) |

## Row Selection

When using the row selection feature, you can access the selected rows by using the
`input.<id>_selected_rows()` function, where `<id>` is the `id` of the
[](:func:`~shiny.ui.output_data_frame`). The value returned will be `None` if no rows
are selected, or a tuple of integers representing the indices of the selected rows.
To filter a pandas data frame down to the selected rows, use
`df.iloc[list(input.<id>_selected_rows())]`.



## Tip

This decorator should be applied **before** the ``@output`` decorator (if that
decorator is used). Also, the name of the decorated function (or
``@output(id=...)``) should match the ``id`` of a [](:func:`~shiny.ui.output_table`)
container (see [](:func:`~shiny.ui.output_table`) for example usage).



## See Also

* [](:func:`~shiny.ui.output_data_frame`)
* [](:class:`~shiny.render.DataGrid`) and [](:class:`~shiny.render.DataTable`) are the
  objects you can return from the rendering function to specify options.

## Examples

```{shinylive-python}
#| standalone: true
#| components: [editor, viewer]
#| layout: vertical
#| viewerHeight: 400

## file: app.py
import pandas  # noqa: F401 (this line needed for Shinylive to load plotly.express)
import plotly.express as px
import plotly.graph_objs as go
from shinywidgets import output_widget, render_widget

from shiny import App, reactive, render, req, session, ui

# Load the Gapminder dataset
df = px.data.gapminder()

# Prepare a summary DataFrame
summary_df = (
    df.groupby("country")
    .agg(
        {
            "pop": ["min", "max", "mean"],
            "lifeExp": ["min", "max", "mean"],
            "gdpPercap": ["min", "max", "mean"],
        }
    )
    .reset_index()
)

summary_df.columns = ["_".join(col).strip() for col in summary_df.columns.values]
summary_df.rename(columns={"country_": "country"}, inplace=True)

app_ui = ui.page_fillable(
    {"class": "p-3"},
    ui.p(
        ui.strong("Instructions:"),
        " Select one or more countries in the table below to see more information.",
    ),
    ui.layout_column_wrap(
        ui.card(
            ui.output_data_frame("summary_data"),
        ),
        ui.layout_column_wrap(
            ui.card(
                output_widget("country_detail_pop", height="100%"),
            ),
            ui.card(
                output_widget("country_detail_percap", height="100%"),
            ),
            width=1 / 2,
        ),
        width=1,
    ),
)


def server(input, output, session):
    @render.data_frame
    def summary_data():
        return render.DataGrid(
            summary_df.round(2),
            row_selection_mode="multiple",
            width="100%",
            height="100%",
        )

    @reactive.Calc
    def filtered_df():
        # input.summary_data_selected_rows() is a tuple, so we must convert it to list,
        # as that's what Pandas requires for indexing.
        selected_idx = list(req(input.summary_data_selected_rows()))
        countries = summary_df.iloc[selected_idx]["country"]
        # Filter data for selected countries
        return df[df["country"].isin(countries)]

    @render_widget
    def country_detail_pop():
        # Create the plot
        fig = px.line(
            filtered_df(),
            x="year",
            y="pop",
            color="country",
            title="Population Over Time",
        )
        widget = go.FigureWidget(fig)

        @synchronize_size("country_detail_pop")
        def on_size_changed(width, height):
            widget.layout.width = width
            widget.layout.height = height

        return widget

    @render_widget
    def country_detail_percap():
        # Create the plot
        fig = px.line(
            filtered_df(),
            x="year",
            y="gdpPercap",
            color="country",
            title="GDP per Capita Over Time",
        )
        widget = go.FigureWidget(fig)

        @synchronize_size("country_detail_percap")
        def on_size_changed(width, height):
            widget.layout.width = width
            widget.layout.height = height

        return widget


# This is a hacky workaround to help Plotly plots automatically
# resize to fit their container. In the future we'll have a
# built-in solution for this.
def synchronize_size(output_id):
    def wrapper(func):
        input = session.get_current_session().input

        @reactive.Effect
        def size_updater():
            func(
                input[f".clientdata_output_{output_id}_width"](),
                input[f".clientdata_output_{output_id}_height"](),
            )

        # When the output that we're synchronizing to is invalidated,
        # clean up the size_updater Effect.
        reactive.get_current_context().on_invalidate(size_updater.destroy)

        return size_updater

    return wrapper


app = App(app_ui, server)
```