{
  "version": 3,
  "sources": ["../../srcts/src/components/_utils.ts", "../../srcts/src/components/sidebar.ts"],
  "sourcesContent": ["import type { HtmlDep } from \"rstudio-shiny/srcts/types/src/shiny/render\";\n\nimport type { InputBinding as InputBindingType } from \"rstudio-shiny/srcts/types/src/bindings/input\";\n\n// Exclude undefined from T\ntype NotUndefined<T> = T extends undefined ? never : T;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst InputBinding = (\n  window.Shiny ? Shiny.InputBinding : class {}\n) as typeof InputBindingType;\n\nfunction registerBinding(\n  inputBindingClass: new () => InputBindingType,\n  name: string\n): void {\n  if (window.Shiny) {\n    Shiny.inputBindings.register(new inputBindingClass(), \"bslib.\" + name);\n  }\n}\n\n// Return true if the key exists on the object and the value is not undefined.\n//\n// This method is mainly used in input bindings' `receiveMessage` method.\n// Since we know that the values are sent by Shiny via `{jsonlite}`,\n// then we know that there are no `undefined` values. `null` is possible, but not `undefined`.\nfunction hasDefinedProperty<\n  Prop extends keyof X,\n  X extends { [key: string]: any }\n>(\n  obj: X,\n  prop: Prop\n): obj is X & { [key in NonNullable<Prop>]: NotUndefined<X[key]> } {\n  return (\n    Object.prototype.hasOwnProperty.call(obj, prop) && obj[prop] !== undefined\n  );\n}\n\n// TODO: Shiny should trigger resize events when the output\n// https://github.com/rstudio/shiny/pull/3682\nfunction doWindowResizeOnElementResize(el: HTMLElement): void {\n  if ($(el).data(\"window-resize-observer\")) {\n    return;\n  }\n  const resizeEvent = new Event(\"resize\");\n  const ro = new ResizeObserver(() => {\n    window.dispatchEvent(resizeEvent);\n  });\n  ro.observe(el);\n  $(el).data(\"window-resize-observer\", ro);\n}\n\nexport {\n  InputBinding,\n  registerBinding,\n  hasDefinedProperty,\n  doWindowResizeOnElementResize,\n};\nexport type { HtmlDep };\n", "import {\n  InputBinding,\n  registerBinding,\n  doWindowResizeOnElementResize,\n} from \"./_utils\";\n\n/**\n * Methods for programmatically toggling the state of the sidebar. These methods\n * describe the desired state of the sidebar: `\"close\"` and `\"open\"` transition\n * the sidebar to the desired state, unless the sidebar is already in that\n * state. `\"toggle\"` transitions the sidebar to the state opposite of its\n * current state.\n * @typedef {SidebarToggleMethod}\n */\ntype SidebarToggleMethod = \"close\" | \"open\" | \"toggle\";\n\n/**\n * Data received by the input binding's `receiveMessage` method.\n * @typedef {SidebarMessageData}\n */\ntype SidebarMessageData = {\n  method: SidebarToggleMethod;\n};\n\n/**\n * The DOM elements that make up the sidebar. `main`, `sidebar`, and `toggle`\n * are all direct children of `container` (in that order).\n * @interface SidebarComponents\n * @typedef {SidebarComponents}\n */\ninterface SidebarComponents {\n  /**\n   * The `layout_sidebar()` parent container, with class\n   * `Sidebar.classes.LAYOUT`.\n   * @type {HTMLElement}\n   */\n  container: HTMLElement;\n  /**\n   * The main content area of the sidebar layout.\n   * @type {HTMLElement}\n   */\n  main: HTMLElement;\n  /**\n   * The sidebar container of the sidebar layout.\n   * @type {HTMLElement}\n   */\n  sidebar: HTMLElement;\n  /**\n   * The toggle button that is used to toggle the sidebar state.\n   * @type {HTMLElement}\n   */\n  toggle: HTMLElement;\n}\n\n/**\n * The bslib sidebar component class. This class is only used for collapsible\n * sidebars.\n *\n * @class Sidebar\n * @typedef {Sidebar}\n */\nclass Sidebar {\n  /**\n   * The DOM elements that make up the sidebar, see `SidebarComponents`.\n   * @private\n   * @type {SidebarComponents}\n   */\n  private layout: SidebarComponents;\n  /**\n   * Creates an instance of a collapsible bslib Sidebar.\n   * @constructor\n   * @param {HTMLElement} container\n   */\n  constructor(container: HTMLElement) {\n    Sidebar.instanceMap.set(container, this);\n    this.layout = {\n      container,\n      main: container.querySelector(\":scope > .main\") as HTMLElement,\n      sidebar: container.querySelector(\":scope > .sidebar\") as HTMLElement,\n      toggle: container.querySelector(\n        \":scope > .collapse-toggle\"\n      ) as HTMLElement,\n    } as SidebarComponents;\n\n    if (!this.layout.toggle) {\n      throw new Error(\"Tried to initialize a non-collapsible sidebar.\");\n    }\n\n    this._initEventListeners();\n    this._initSidebarCounters();\n    this._initDesktop();\n\n    container.removeAttribute(\"data-bslib-sidebar-init\");\n    const initScript = container.querySelector(\n      \":scope > script[data-bslib-sidebar-init]\"\n    );\n    if (initScript) {\n      container.removeChild(initScript);\n    }\n  }\n\n  /**\n   * Read the current state of the sidebar. Note that, when calling this method,\n   * the sidebar may be transitioning into the state returned by this method.\n   *\n   * @description\n   * The sidebar state works as follows, starting from the open state. When the\n   * sidebar is closed:\n   * 1. We add both the `COLLAPSE` and `TRANSITIONING` classes to the sidebar.\n   * 2. The sidebar collapse begins to animate. On desktop devices, and where it\n   *    is supported, we transition the `grid-template-columns` property of the\n   *    sidebar layout. On mobile, the sidebar is hidden immediately. In both\n   *    cases, the collapse icon rotates and we use this rotation to determine\n   *    when the transition is complete.\n   * 3. If another sidebar state toggle is requested while closing the sidebar,\n   *    we remove the `COLLAPSE` class and the animation immediately starts to\n   *    reverse.\n   * 4. When the `transition` is complete, we remove the `TRANSITIONING` class.\n   * @readonly\n   * @type {boolean}\n   */\n  get isClosed(): boolean {\n    return this.layout.container.classList.contains(Sidebar.classes.COLLAPSE);\n  }\n\n  /**\n   * Static classes related to the sidebar layout or state.\n   * @public\n   * @static\n   * @readonly\n   * @type {{ LAYOUT: string; COLLAPSE: string; TRANSITIONING: string; }}\n   */\n  public static readonly classes = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    LAYOUT: \"bslib-sidebar-layout\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    COLLAPSE: \"sidebar-collapsed\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    TRANSITIONING: \"transitioning\",\n  };\n\n  /**\n   * If sidebars are initialized before the DOM is ready, we re-schedule the\n   * initialization to occur on DOMContentLoaded.\n   * @private\n   * @static\n   * @type {boolean}\n   */\n  private static onReadyScheduled = false;\n  /**\n   * A map of initialized sidebars to their respective Sidebar instances.\n   * @private\n   * @static\n   * @type {WeakMap<HTMLElement, Sidebar>}\n   */\n  private static instanceMap: WeakMap<HTMLElement, Sidebar> = new WeakMap();\n\n  /**\n   * Given a sidebar container, return the Sidebar instance associated with it.\n   * @public\n   * @static\n   * @param {HTMLElement} el\n   * @returns {(Sidebar | undefined)}\n   */\n  public static getInstance(el: HTMLElement): Sidebar | undefined {\n    return Sidebar.instanceMap.get(el);\n  }\n\n  /**\n   * Initialize all collapsible sidebars on the page.\n   * @public\n   * @static\n   */\n  public static initCollapsibleAll(): void {\n    if (document.readyState === \"loading\") {\n      if (!Sidebar.onReadyScheduled) {\n        Sidebar.onReadyScheduled = true;\n        document.addEventListener(\"DOMContentLoaded\", () => {\n          Sidebar.initCollapsibleAll();\n        });\n      }\n      return;\n    }\n\n    const initSelector = `.${Sidebar.classes.LAYOUT}[data-bslib-sidebar-init]`;\n    if (!document.querySelector(initSelector)) {\n      // no sidebars to initialize\n      return;\n    }\n\n    const containers = document.querySelectorAll(initSelector);\n    containers.forEach((container) => new Sidebar(container as HTMLElement));\n  }\n\n  /**\n   * Initialize event listeners for the sidebar toggle button.\n   * @private\n   */\n  private _initEventListeners(): void {\n    const { sidebar, toggle } = this.layout;\n\n    toggle.addEventListener(\"click\", (ev) => {\n      ev.preventDefault();\n      this.toggle(\"toggle\");\n    });\n\n    // Remove the transitioning class when the transition ends. We watch the\n    // collapse toggle icon because it's guaranteed to transition, whereas the\n    // sidebar doesn't animate on mobile (or in browsers where animating\n    // grid-template-columns is not supported).\n    toggle\n      .querySelector(\".collapse-icon\")\n      ?.addEventListener(\"transitionend\", () => {\n        this._finalizeState();\n        $(sidebar).trigger(\"toggleCollapse.sidebarInputBinding\");\n      });\n  }\n\n  /**\n   * Initialize nested sidebar counters.\n   *\n   * @description\n   * This function walks up the DOM tree, adding CSS variables to each direct\n   * parent sidebar layout that count the layout's position in the stack of\n   * nested layouts. We use these counters to keep the collapse toggles from\n   * overlapping. Note that always-open sidebars that don't have collapse\n   * toggles break the chain of nesting.\n   * @private\n   */\n  private _initSidebarCounters(): void {\n    const { container } = this.layout;\n\n    const selectorChildLayouts =\n      `.${Sidebar.classes.LAYOUT}` +\n      \"> .main > \" +\n      `.${Sidebar.classes.LAYOUT}:not([data-bslib-sidebar-open=\"always\"])`;\n\n    const isInnermostLayout =\n      container.querySelector(selectorChildLayouts) === null;\n\n    if (!isInnermostLayout) {\n      // There are sidebar layouts nested within this layout; defer to children\n      return;\n    }\n\n    function nextSidebarParent(el: HTMLElement | null): HTMLElement | null {\n      el = el ? el.parentElement : null;\n      if (el && el.classList.contains(\"main\")) {\n        // .bslib-sidebar-layout > .main > .bslib-sidebar-layout\n        el = el.parentElement;\n      }\n      if (el && el.classList.contains(Sidebar.classes.LAYOUT)) {\n        return el;\n      }\n      return null;\n    }\n\n    const layouts = [container];\n    let parent = nextSidebarParent(container);\n\n    while (parent) {\n      // Add parent to front of layouts array, so we sort outer -> inner\n      layouts.unshift(parent);\n      parent = nextSidebarParent(parent);\n    }\n\n    const count = { left: 0, right: 0 };\n    layouts.forEach(function (x: HTMLElement, i: number): void {\n      x.style.setProperty(\"--bslib-sidebar-counter\", i.toString());\n      const isRight = x.classList.contains(\"sidebar-right\");\n      const thisCount = isRight ? count.right++ : count.left++;\n      x.style.setProperty(\n        \"--bslib-sidebar-overlap-counter\",\n        thisCount.toString()\n      );\n    });\n  }\n\n  /**\n   * Initialize the sidebar's initial state when `open = \"desktop\"`.\n   * @private\n   */\n  private _initDesktop(): void {\n    const { container } = this.layout;\n    // If sidebar is marked open='desktop'...\n    if (container.dataset.bslibSidebarOpen?.trim() !== \"desktop\") {\n      return;\n    }\n\n    // then close sidebar on mobile\n    const initCollapsed = window\n      .getComputedStyle(container)\n      .getPropertyValue(\"--bslib-sidebar-js-init-collapsed\");\n\n    if (initCollapsed.trim() === \"true\") {\n      this.toggle(\"close\");\n    }\n  }\n\n  /**\n   * Toggle the sidebar's open/closed state.\n   * @public\n   * @param {SidebarToggleMethod | undefined} method Whether to `\"open\"`,\n   * `\"close\"` or `\"toggle\"` the sidebar. If `.toggle()` is called without an\n   * argument, it will toggle the sidebar's state.\n   */\n  public toggle(method: SidebarToggleMethod | undefined): void {\n    if (typeof method === \"undefined\") {\n      method = \"toggle\";\n    }\n\n    const { container, main, sidebar } = this.layout;\n    const isClosed = this.isClosed;\n\n    if ([\"open\", \"close\", \"toggle\"].indexOf(method) === -1) {\n      throw new Error(`Unknown method ${method}`);\n    }\n\n    if (method === \"toggle\") {\n      method = isClosed ? \"open\" : \"close\";\n    }\n\n    if ((isClosed && method === \"close\") || (!isClosed && method === \"open\")) {\n      // nothing to do, sidebar is already in the desired state\n      return;\n    }\n\n    // Make sure outputs resize properly when the sidebar is opened/closed\n    doWindowResizeOnElementResize(main);\n\n    if (method === \"open\") {\n      // unhide sidebar immediately when opening,\n      // otherwise the sidebar is hidden on transitionend\n      sidebar.hidden = false;\n    }\n\n    // Add a transitioning class just before adding COLLAPSE_CLASS since we want\n    // some of the transitioning styles to apply before the collapse state\n    container.classList.add(Sidebar.classes.TRANSITIONING);\n    container.classList.toggle(Sidebar.classes.COLLAPSE);\n  }\n\n  /**\n   * When the sidebar open/close transition ends, finalize the sidebar's state.\n   * @private\n   */\n  private _finalizeState(): void {\n    const { container, sidebar, toggle } = this.layout;\n    container.classList.remove(Sidebar.classes.TRANSITIONING);\n    sidebar.hidden = this.isClosed;\n    toggle.ariaExpanded = this.isClosed ? \"false\" : \"true\";\n  }\n}\n\n/**\n * A Shiny input binding for a sidebar.\n * @class SidebarInputBinding\n * @typedef {SidebarInputBinding}\n * @extends {InputBinding}\n */\nclass SidebarInputBinding extends InputBinding {\n  find(scope: HTMLElement) {\n    return $(scope).find(`.${Sidebar.classes.LAYOUT} > .bslib-sidebar-input`);\n  }\n\n  getValue(el: HTMLElement): boolean {\n    const sb = Sidebar.getInstance(el.parentElement as HTMLElement);\n    return sb ? sb.isClosed : false;\n  }\n\n  setValue(el: HTMLElement, value: boolean): void {\n    const method = value ? \"open\" : \"close\";\n    this.receiveMessage(el, { method });\n  }\n\n  subscribe(el: HTMLElement, callback: (x: boolean) => void) {\n    $(el).on(\n      \"toggleCollapse.sidebarInputBinding\",\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      function (event) {\n        callback(true);\n      }\n    );\n  }\n\n  unsubscribe(el: HTMLElement) {\n    $(el).off(\".sidebarInputBinding\");\n  }\n\n  receiveMessage(el: HTMLElement, data: SidebarMessageData) {\n    const sb = Sidebar.getInstance(el.parentElement as HTMLElement);\n    if (sb) sb.toggle(data.method);\n  }\n}\n\nregisterBinding(SidebarInputBinding, \"sidebar\");\n\n// attach Sidebar class to window for global usage\n(window as any).bslib = (window as any).bslib || {};\n(window as any).bslib.Sidebar = Sidebar;\n"],
  "mappings": "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",
  "names": ["InputBinding", "registerBinding", "inputBindingClass", "name", "doWindowResizeOnElementResize", "el", "resizeEvent", "ro", "_Sidebar", "container", "initScript", "el", "initSelector", "_a", "sidebar", "toggle", "ev", "selectorChildLayouts", "nextSidebarParent", "layouts", "parent", "count", "x", "i", "thisCount", "method", "main", "isClosed", "doWindowResizeOnElementResize", "Sidebar", "SidebarInputBinding", "InputBinding", "scope", "sb", "value", "callback", "event", "data", "registerBinding"]
}
