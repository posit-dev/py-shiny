{
  "version": 3,
  "sources": ["../../../../js/node_modules/preact/src/constants.js", "../../../../js/node_modules/preact/src/util.js", "../../../../js/node_modules/preact/src/options.js", "../../../../js/node_modules/preact/src/create-element.js", "../../../../js/node_modules/preact/src/component.js", "../../../../js/node_modules/preact/src/diff/props.js", "../../../../js/node_modules/preact/src/create-context.js", "../../../../js/node_modules/preact/src/diff/children.js", "../../../../js/node_modules/preact/src/diff/index.js", "../../../../js/node_modules/preact/src/render.js", "../../../../js/node_modules/preact/src/clone-element.js", "../../../../js/node_modules/preact/src/diff/catch-error.js", "../../../../js/node_modules/preact/hooks/src/index.js", "../../../../js/node_modules/preact/compat/src/util.js", "../../../../js/node_modules/preact/compat/src/PureComponent.js", "../../../../js/node_modules/preact/compat/src/memo.js", "../../../../js/node_modules/preact/compat/src/forwardRef.js", "../../../../js/node_modules/preact/compat/src/Children.js", "../../../../js/node_modules/preact/compat/src/suspense.js", "../../../../js/node_modules/preact/compat/src/suspense-list.js", "../../../../js/node_modules/preact/src/constants.js", "../../../../js/node_modules/preact/compat/src/portals.js", "../../../../js/node_modules/preact/compat/src/render.js", "../../../../js/node_modules/preact/compat/src/index.js", "../../../../js/node_modules/@tanstack/table-core/src/columnHelper.ts", "../../../../js/node_modules/@tanstack/table-core/src/utils.ts", "../../../../js/node_modules/@tanstack/table-core/src/core/cell.ts", "../../../../js/node_modules/@tanstack/table-core/src/core/column.ts", "../../../../js/node_modules/@tanstack/table-core/src/core/headers.ts", "../../../../js/node_modules/@tanstack/table-core/src/core/row.ts", "../../../../js/node_modules/@tanstack/table-core/src/features/ColumnFaceting.ts", "../../../../js/node_modules/@tanstack/table-core/src/filterFns.ts", "../../../../js/node_modules/@tanstack/table-core/src/features/ColumnFiltering.ts", "../../../../js/node_modules/@tanstack/table-core/src/aggregationFns.ts", "../../../../js/node_modules/@tanstack/table-core/src/features/ColumnGrouping.ts", "../../../../js/node_modules/@tanstack/table-core/src/features/ColumnOrdering.ts", "../../../../js/node_modules/@tanstack/table-core/src/features/ColumnPinning.ts", "../../../../js/node_modules/@tanstack/table-core/src/features/ColumnSizing.ts", "../../../../js/node_modules/@tanstack/table-core/src/features/ColumnVisibility.ts", "../../../../js/node_modules/@tanstack/table-core/src/features/GlobalFaceting.ts", "../../../../js/node_modules/@tanstack/table-core/src/features/GlobalFiltering.ts", "../../../../js/node_modules/@tanstack/table-core/src/features/RowExpanding.ts", "../../../../js/node_modules/@tanstack/table-core/src/features/RowPagination.ts", "../../../../js/node_modules/@tanstack/table-core/src/features/RowPinning.ts", "../../../../js/node_modules/@tanstack/table-core/src/features/RowSelection.ts", "../../../../js/node_modules/@tanstack/table-core/src/sortingFns.ts", "../../../../js/node_modules/@tanstack/table-core/src/features/RowSorting.ts", "../../../../js/node_modules/@tanstack/table-core/src/core/table.ts", "../../../../js/node_modules/@tanstack/table-core/src/utils/getCoreRowModel.ts", "../../../../js/node_modules/@tanstack/table-core/src/utils/getExpandedRowModel.ts", "../../../../js/node_modules/@tanstack/table-core/src/utils/getFacetedMinMaxValues.ts", "../../../../js/node_modules/@tanstack/table-core/src/utils/filterRowsUtils.ts", "../../../../js/node_modules/@tanstack/table-core/src/utils/getFacetedRowModel.ts", "../../../../js/node_modules/@tanstack/table-core/src/utils/getFacetedUniqueValues.ts", "../../../../js/node_modules/@tanstack/table-core/src/utils/getFilteredRowModel.ts", "../../../../js/node_modules/@tanstack/table-core/src/utils/getGroupedRowModel.ts", "../../../../js/node_modules/@tanstack/table-core/src/utils/getPaginationRowModel.ts", "../../../../js/node_modules/@tanstack/table-core/src/utils/getSortedRowModel.ts", "../../../../js/node_modules/@tanstack/react-table/src/index.tsx", "../../../../js/node_modules/@tanstack/virtual-core/src/utils.ts", "../../../../js/node_modules/@tanstack/virtual-core/src/index.ts", "../../../../js/node_modules/@tanstack/react-virtual/src/index.tsx", "../../../../js/node_modules/preact/compat/client.mjs", "../../../../js/node_modules/immer/src/utils/env.ts", "../../../../js/node_modules/immer/src/utils/errors.ts", "../../../../js/node_modules/immer/src/utils/common.ts", "../../../../js/node_modules/immer/src/utils/plugins.ts", "../../../../js/node_modules/immer/src/core/scope.ts", "../../../../js/node_modules/immer/src/core/finalize.ts", "../../../../js/node_modules/immer/src/core/proxy.ts", "../../../../js/node_modules/immer/src/core/immerClass.ts", "../../../../js/node_modules/immer/src/core/current.ts", "../../../../js/node_modules/immer/src/plugins/patches.ts", "../../../../js/node_modules/immer/src/plugins/mapset.ts", "../../../../js/node_modules/immer/src/immer.ts", "../../../../js/node_modules/use-immer/src/index.ts", "../../../../js/data-frame/request.ts", "../../../../js/data-frame/data-update.tsx", "../../../../js/data-frame/cell.tsx", "../../../../js/data-frame/cell-edit-map.tsx", "../../../../js/data-frame/dom-utils.tsx", "../../../../js/data-frame/filter-numeric.tsx", "../../../../js/data-frame/filter.tsx", "../../../../js/data-frame/immutable-set.tsx", "../../../../js/data-frame/selection.tsx", "../../../../js/data-frame/sort.ts", "../../../../js/data-frame/sort-arrows.tsx", "../../../../js/data-frame/style-info.ts", "../../../../js/data-frame/styles.scss", "../../../../js/data-frame/tabindex-group.ts", "../../../../js/data-frame/table-summary.tsx", "../../../../js/data-frame/index.tsx"],
  "sourcesContent": ["/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 16;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 17;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n", "import { EMPTY_ARR } from './constants';\n\nexport const isArray = Array.isArray;\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\t// @ts-expect-error We change the type of `obj` to be `O & P`\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {preact.ContainerNode} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n\nexport const slice = EMPTY_ARR.slice;\n", "import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n", "import { slice } from './util';\nimport options from './options';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {VNode[\"type\"]} type The node name or Component constructor for this\n * virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the\n * virtual node\n * @returns {VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\t/** @type {VNode} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: original == null ? ++vnodeId : original,\n\t\t_index: -1,\n\t\t_flags: 0\n\t};\n\n\t// Only invoke the vnode hook if this was *not* a direct copy:\n\tif (original == null && options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor == undefined;\n", "import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\nimport { MODE_HYDRATE } from './constants';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function BaseComponent(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nBaseComponent.prototype.setState = function (update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) {\n\t\t\tthis._stateCallbacks.push(callback);\n\t\t}\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nBaseComponent.prototype.forceUpdate = function (callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {ComponentChildren | void}\n */\nBaseComponent.prototype.render = Fragment;\n\n/**\n * @param {VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._index + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet oldVNode = component._vnode,\n\t\toldDom = oldVNode._dom,\n\t\tcommitQueue = [],\n\t\trefQueue = [];\n\n\tif (component._parentDom) {\n\t\tconst newVNode = assign({}, oldVNode);\n\t\tnewVNode._original = oldVNode._original + 1;\n\t\tif (options.vnode) options.vnode(newVNode);\n\n\t\tdiff(\n\t\t\tcomponent._parentDom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tcomponent._parentDom.namespaceURI,\n\t\t\toldVNode._flags & MODE_HYDRATE ? [oldDom] : null,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(oldVNode) : oldDom,\n\t\t\t!!(oldVNode._flags & MODE_HYDRATE),\n\t\t\trefQueue\n\t\t);\n\n\t\tnewVNode._original = oldVNode._original;\n\t\tnewVNode._parent._children[newVNode._index] = newVNode;\n\t\tcommitRoot(commitQueue, newVNode, refQueue);\n\n\t\tif (newVNode._dom != oldDom) {\n\t\t\tupdateParentDomPointers(newVNode);\n\t\t}\n\t}\n}\n\n/**\n * @param {VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<Component>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/**\n * Enqueue a rerender of a component\n * @param {Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/**\n * @param {Component} a\n * @param {Component} b\n */\nconst depthSort = (a, b) => a._vnode._depth - b._vnode._depth;\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet c;\n\trerenderQueue.sort(depthSort);\n\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t// process() calls from getting scheduled while `queue` is still being consumed.\n\twhile ((c = rerenderQueue.shift())) {\n\t\tif (c._dirty) {\n\t\t\tlet renderQueueLength = rerenderQueue.length;\n\t\t\trenderComponent(c);\n\t\t\tif (rerenderQueue.length > renderQueueLength) {\n\t\t\t\t// When i.e. rerendering a provider additional new items can be injected, we want to\n\t\t\t\t// keep the order from top to bottom with those new items so we can handle them in a\n\t\t\t\t// single pass\n\t\t\t\trerenderQueue.sort(depthSort);\n\t\t\t}\n\t\t}\n\t}\n\tprocess._rerenderCount = 0;\n}\n\nprocess._rerenderCount = 0;\n", "import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\nfunction setStyle(style, key, value) {\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value == null ? '' : value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n// A logical clock to solve issues like https://github.com/preactjs/preact/issues/3927.\n// When the DOM performs an event it leaves micro-ticks in between bubbling up which means that\n// an event can trigger on a newly reated DOM-node while the event bubbles up.\n//\n// Originally inspired by Vue\n// (https://github.com/vuejs/core/blob/caeb8a68811a1b0f79/packages/runtime-dom/src/modules/events.ts#L90-L101),\n// but modified to use a logical clock instead of Date.now() in case event handlers get attached\n// and events get dispatched during the same millisecond.\n//\n// The clock is incremented after each new event dispatch. This allows 1 000 000 new events\n// per second for over 280 years before the value reaches Number.MAX_SAFE_INTEGER (2**53 - 1).\nlet eventClock = 0;\n\n/**\n * Set a property value on a DOM node\n * @param {PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {string} namespace Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, namespace) {\n\tlet useCapture;\n\n\to: if (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture =\n\t\t\tname !== (name = name.replace(/(PointerCapture)$|Capture$/i, '$1'));\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (\n\t\t\tname.toLowerCase() in dom ||\n\t\t\tname === 'onFocusOut' ||\n\t\t\tname === 'onFocusIn'\n\t\t)\n\t\t\tname = name.toLowerCase().slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tvalue._attached = eventClock;\n\t\t\t\tdom.addEventListener(\n\t\t\t\t\tname,\n\t\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\t\tuseCapture\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tvalue._attached = oldValue._attached;\n\t\t\t}\n\t\t} else {\n\t\t\tdom.removeEventListener(\n\t\t\t\tname,\n\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\tuseCapture\n\t\t\t);\n\t\t}\n\t} else {\n\t\tif (namespace == 'http://www.w3.org/2000/svg') {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink(H|:h)/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname != 'width' &&\n\t\t\tname != 'height' &&\n\t\t\tname != 'href' &&\n\t\t\tname != 'list' &&\n\t\t\tname != 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname != 'tabIndex' &&\n\t\t\tname != 'download' &&\n\t\t\tname != 'rowSpan' &&\n\t\t\tname != 'colSpan' &&\n\t\t\tname != 'role' &&\n\t\t\tname != 'popover' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == null ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// aria- and data- attributes have no boolean representation.\n\t\t// A `false` value is different from the attribute not being\n\t\t// present, so we can't remove it. For non-boolean aria\n\t\t// attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost too many bytes. On top of\n\t\t// that other frameworks generally stringify `false`.\n\n\t\tif (typeof value == 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (value != null && (value !== false || name[4] === '-')) {\n\t\t\tdom.setAttribute(name, name == 'popover' && value == true ? '' : value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Create an event proxy function.\n * @param {boolean} useCapture Is the event handler for the capture phase.\n * @private\n */\nfunction createEventProxy(useCapture) {\n\t/**\n\t * Proxy an event to hooked event handlers\n\t * @param {PreactEvent} e The event object from the browser\n\t * @private\n\t */\n\treturn function (e) {\n\t\tif (this._listeners) {\n\t\t\tconst eventHandler = this._listeners[e.type + useCapture];\n\t\t\tif (e._dispatched == null) {\n\t\t\t\te._dispatched = eventClock++;\n\n\t\t\t\t// When `e._dispatched` is smaller than the time when the targeted event\n\t\t\t\t// handler was attached we know we have bubbled up to an element that was added\n\t\t\t\t// during patching the DOM.\n\t\t\t} else if (e._dispatched < eventHandler._attached) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn eventHandler(options.event ? options.event(e) : e);\n\t\t}\n\t};\n}\n\nconst eventProxy = createEventProxy(false);\nconst eventProxyCapture = createEventProxy(true);\n", "import { enqueueRender } from './component';\n\nexport let i = 0;\n\nexport function createContext(defaultValue, contextId) {\n\tcontextId = '__cC' + i++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\t/** @type {FunctionComponent} */\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\t/** @type {FunctionComponent} */\n\t\tProvider(props) {\n\t\t\tif (!this.getChildContext) {\n\t\t\t\t/** @type {Component[] | null} */\n\t\t\t\tlet subs = [];\n\t\t\t\tlet ctx = {};\n\t\t\t\tctx[contextId] = this;\n\n\t\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\t\tthis.componentWillUnmount = () => {\n\t\t\t\t\tsubs = null;\n\t\t\t\t};\n\n\t\t\t\tthis.shouldComponentUpdate = function (_props) {\n\t\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\t\tsubs.some(c => {\n\t\t\t\t\t\t\tc._force = true;\n\t\t\t\t\t\t\tenqueueRender(c);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.sub = c => {\n\t\t\t\t\tsubs.push(c);\n\t\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\t\tif (subs) {\n\t\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType =\n\t\tcontext);\n}\n", "import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR, INSERT_VNODE, MATCHED } from '../constants';\nimport { isArray } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {PreactElement} parentDom The DOM element whose children are being\n * diffed\n * @param {ComponentChildren[]} renderResult\n * @param {VNode} newParentVNode The new virtual node whose children should be\n * diff'ed against oldParentVNode\n * @param {VNode} oldParentVNode The old virtual node whose children should be\n * diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\tlet i,\n\t\t/** @type {VNode} */\n\t\toldVNode,\n\t\t/** @type {VNode} */\n\t\tchildVNode,\n\t\t/** @type {PreactElement} */\n\t\tnewDom,\n\t\t/** @type {PreactElement} */\n\t\tfirstChildDom;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\t/** @type {VNode[]} */\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet newChildrenLength = renderResult.length;\n\n\tnewParentVNode._nextDom = oldDom;\n\tconstructNewChildrenArray(newParentVNode, renderResult, oldChildren);\n\toldDom = newParentVNode._nextDom;\n\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\tchildVNode = newParentVNode._children[i];\n\t\tif (\n\t\t\tchildVNode == null ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// At this point, constructNewChildrenArray has assigned _index to be the\n\t\t// matchingIndex for this VNode's oldVNode (or -1 if there is no oldVNode).\n\t\tif (childVNode._index === -1) {\n\t\t\toldVNode = EMPTY_OBJ;\n\t\t} else {\n\t\t\toldVNode = oldChildren[childVNode._index] || EMPTY_OBJ;\n\t\t}\n\n\t\t// Update childVNode._index to its final index\n\t\tchildVNode._index = i;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tdiff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\n\t\t// Adjust DOM nodes\n\t\tnewDom = childVNode._dom;\n\t\tif (childVNode.ref && oldVNode.ref != childVNode.ref) {\n\t\t\tif (oldVNode.ref) {\n\t\t\t\tapplyRef(oldVNode.ref, null, childVNode);\n\t\t\t}\n\t\t\trefQueue.push(\n\t\t\t\tchildVNode.ref,\n\t\t\t\tchildVNode._component || newDom,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t}\n\n\t\tif (firstChildDom == null && newDom != null) {\n\t\t\tfirstChildDom = newDom;\n\t\t}\n\n\t\tif (\n\t\t\tchildVNode._flags & INSERT_VNODE ||\n\t\t\toldVNode._children === childVNode._children\n\t\t) {\n\t\t\tif (\n\t\t\t\toldDom &&\n\t\t\t\ttypeof childVNode.type == 'string' &&\n\t\t\t\t// @ts-expect-error olDom should be present on a DOM node\n\t\t\t\t!parentDom.contains(oldDom)\n\t\t\t) {\n\t\t\t\toldDom = getDomSibling(oldVNode);\n\t\t\t}\n\t\t\toldDom = insert(childVNode, oldDom, parentDom);\n\t\t} else if (\n\t\t\ttypeof childVNode.type == 'function' &&\n\t\t\tchildVNode._nextDom !== undefined\n\t\t) {\n\t\t\t// Since Fragments or components that return Fragment like VNodes can\n\t\t\t// contain multiple DOM nodes as the same level, continue the diff from\n\t\t\t// the sibling of last DOM child of this child VNode\n\t\t\toldDom = childVNode._nextDom;\n\t\t} else if (newDom) {\n\t\t\toldDom = newDom.nextSibling;\n\t\t}\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because it\n\t\t// is only used by `diffChildren` to determine where to resume the diff\n\t\t// after diffing Components and Fragments. Once we store it the nextDOM\n\t\t// local var, we can clean up the property. Also prevents us hanging on to\n\t\t// DOM nodes that may have been unmounted.\n\t\tchildVNode._nextDom = undefined;\n\n\t\t// Unset diffing flags\n\t\tchildVNode._flags &= ~(INSERT_VNODE | MATCHED);\n\t}\n\n\t// TODO: With new child diffing algo, consider alt ways to diff Fragments.\n\t// Such as dropping oldDom and moving fragments in place\n\t//\n\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t// _nextDom property to the nextSibling of its last child DOM node.\n\t//\n\t// `oldDom` contains the correct value here because if the last child\n\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t// node's nextSibling.\n\tnewParentVNode._nextDom = oldDom;\n\tnewParentVNode._dom = firstChildDom;\n}\n\n/**\n * @param {VNode} newParentVNode\n * @param {ComponentChildren[]} renderResult\n * @param {VNode[]} oldChildren\n */\nfunction constructNewChildrenArray(newParentVNode, renderResult, oldChildren) {\n\t/** @type {number} */\n\tlet i;\n\t/** @type {VNode} */\n\tlet childVNode;\n\t/** @type {VNode} */\n\tlet oldVNode;\n\n\tconst newChildrenLength = renderResult.length;\n\tlet oldChildrenLength = oldChildren.length,\n\t\tremainingOldChildren = oldChildrenLength;\n\n\tlet skew = 0;\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\t// @ts-expect-error We are reusing the childVNode variable to hold both the\n\t\t// pre and post normalized childVNode\n\t\tchildVNode = renderResult[i];\n\n\t\tif (\n\t\t\tchildVNode == null ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (\n\t\t\ttypeof childVNode == 'string' ||\n\t\t\ttypeof childVNode == 'number' ||\n\t\t\t// eslint-disable-next-line valid-typeof\n\t\t\ttypeof childVNode == 'bigint' ||\n\t\t\tchildVNode.constructor == String\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode.constructor === undefined && childVNode._depth > 0) {\n\t\t\t// VNode is already in use, clone it. This can happen in the following\n\t\t\t// scenario:\n\t\t\t//   const reuse = <div />\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tchildVNode.ref ? childVNode.ref : null,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\tconst skewedIndex = i + skew;\n\n\t\t// Handle unmounting null placeholders, i.e. VNode => null in unkeyed children\n\t\tif (childVNode == null) {\n\t\t\toldVNode = oldChildren[skewedIndex];\n\t\t\tif (\n\t\t\t\toldVNode &&\n\t\t\t\toldVNode.key == null &&\n\t\t\t\toldVNode._dom &&\n\t\t\t\t(oldVNode._flags & MATCHED) === 0\n\t\t\t) {\n\t\t\t\tif (oldVNode._dom == newParentVNode._nextDom) {\n\t\t\t\t\tnewParentVNode._nextDom = getDomSibling(oldVNode);\n\t\t\t\t}\n\n\t\t\t\tunmount(oldVNode, oldVNode, false);\n\n\t\t\t\t// Explicitly nullify this position in oldChildren instead of just\n\t\t\t\t// setting `_match=true` to prevent other routines (e.g.\n\t\t\t\t// `findMatchingIndex` or `getDomSibling`) from thinking VNodes or DOM\n\t\t\t\t// nodes in this position are still available to be used in diffing when\n\t\t\t\t// they have actually already been unmounted. For example, by only\n\t\t\t\t// setting `_match=true` here, the unmounting loop later would attempt\n\t\t\t\t// to unmount this VNode again seeing `_match==true`.  Further,\n\t\t\t\t// getDomSibling doesn't know about _match and so would incorrectly\n\t\t\t\t// assume DOM nodes in this subtree are mounted and usable.\n\t\t\t\toldChildren[skewedIndex] = null;\n\t\t\t\tremainingOldChildren--;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\tconst matchingIndex = findMatchingIndex(\n\t\t\tchildVNode,\n\t\t\toldChildren,\n\t\t\tskewedIndex,\n\t\t\tremainingOldChildren\n\t\t);\n\n\t\t// Temporarily store the matchingIndex on the _index property so we can pull\n\t\t// out the oldVNode in diffChildren. We'll override this to the VNode's\n\t\t// final index after using this property to get the oldVNode\n\t\tchildVNode._index = matchingIndex;\n\n\t\toldVNode = null;\n\t\tif (matchingIndex !== -1) {\n\t\t\toldVNode = oldChildren[matchingIndex];\n\t\t\tremainingOldChildren--;\n\t\t\tif (oldVNode) {\n\t\t\t\toldVNode._flags |= MATCHED;\n\t\t\t}\n\t\t}\n\n\t\t// Here, we define isMounting for the purposes of the skew diffing\n\t\t// algorithm. Nodes that are unsuspending are considered mounting and we detect\n\t\t// this by checking if oldVNode._original === null\n\t\tconst isMounting = oldVNode == null || oldVNode._original === null;\n\n\t\tif (isMounting) {\n\t\t\tif (matchingIndex == -1) {\n\t\t\t\tskew--;\n\t\t\t}\n\n\t\t\t// If we are mounting a DOM VNode, mark it for insertion\n\t\t\tif (typeof childVNode.type != 'function') {\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t} else if (matchingIndex !== skewedIndex) {\n\t\t\tif (matchingIndex == skewedIndex - 1) {\n\t\t\t\tskew = matchingIndex - skewedIndex;\n\t\t\t} else if (matchingIndex == skewedIndex + 1) {\n\t\t\t\tskew++;\n\t\t\t} else if (matchingIndex > skewedIndex) {\n\t\t\t\t// Our matched DOM-node is further in the list of children than\n\t\t\t\t// where it's at now.\n\n\t\t\t\t// When the remaining old children is bigger than the new-children\n\t\t\t\t// minus our skewed index we know we are dealing with a shrinking list\n\t\t\t\t// we have to increase our skew with the matchedIndex - the skewed index\n\t\t\t\tif (remainingOldChildren > newChildrenLength - skewedIndex) {\n\t\t\t\t\tskew += matchingIndex - skewedIndex;\n\t\t\t\t} else {\n\t\t\t\t\t// If we have matched all the children just decrease the skew\n\t\t\t\t\tskew--;\n\t\t\t\t}\n\t\t\t} else if (matchingIndex < skewedIndex) {\n\t\t\t\t// When our new position is in front of our old position than we increase the skew\n\t\t\t\tskew++;\n\t\t\t}\n\n\t\t\t// Move this VNode's DOM if the original index (matchingIndex) doesn't\n\t\t\t// match the new skew index (i + new skew)\n\t\t\tif (matchingIndex !== i + skew) {\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any. Loop forwards so that as we\n\t// unmount DOM from the beginning of the oldChildren, we can adjust oldDom to\n\t// point to the next child, which needs to be the first DOM node that won't be\n\t// unmounted.\n\tif (remainingOldChildren) {\n\t\tfor (i = 0; i < oldChildrenLength; i++) {\n\t\t\toldVNode = oldChildren[i];\n\t\t\tif (oldVNode != null && (oldVNode._flags & MATCHED) === 0) {\n\t\t\t\tif (oldVNode._dom == newParentVNode._nextDom) {\n\t\t\t\t\tnewParentVNode._nextDom = getDomSibling(oldVNode);\n\t\t\t\t}\n\n\t\t\t\tunmount(oldVNode, oldVNode);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {VNode} parentVNode\n * @param {PreactElement} oldDom\n * @param {PreactElement} parentDom\n * @returns {PreactElement}\n */\nfunction insert(parentVNode, oldDom, parentDom) {\n\t// Note: VNodes in nested suspended trees may be missing _children.\n\n\tif (typeof parentVNode.type == 'function') {\n\t\tlet children = parentVNode._children;\n\t\tfor (let i = 0; children && i < children.length; i++) {\n\t\t\tif (children[i]) {\n\t\t\t\t// If we enter this code path on sCU bailout, where we copy\n\t\t\t\t// oldVNode._children to newVNode._children, we need to update the old\n\t\t\t\t// children's _parent pointer to point to the newVNode (parentVNode\n\t\t\t\t// here).\n\t\t\t\tchildren[i]._parent = parentVNode;\n\t\t\t\toldDom = insert(children[i], oldDom, parentDom);\n\t\t\t}\n\t\t}\n\n\t\treturn oldDom;\n\t} else if (parentVNode._dom != oldDom) {\n\t\tparentDom.insertBefore(parentVNode._dom, oldDom || null);\n\t\toldDom = parentVNode._dom;\n\t}\n\n\tdo {\n\t\toldDom = oldDom && oldDom.nextSibling;\n\t} while (oldDom != null && oldDom.nodeType === 8);\n\n\treturn oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {ComponentChildren} children The unflattened children of a virtual\n * node\n * @returns {VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\n/**\n * @param {VNode} childVNode\n * @param {VNode[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(\n\tchildVNode,\n\toldChildren,\n\tskewedIndex,\n\tremainingOldChildren\n) {\n\tconst key = childVNode.key;\n\tconst type = childVNode.type;\n\tlet x = skewedIndex - 1;\n\tlet y = skewedIndex + 1;\n\tlet oldVNode = oldChildren[skewedIndex];\n\n\t// We only need to perform a search if there are more children\n\t// (remainingOldChildren) to search. However, if the oldVNode we just looked\n\t// at skewedIndex was not already used in this diff, then there must be at\n\t// least 1 other (so greater than 1) remainingOldChildren to attempt to match\n\t// against. So the following condition checks that ensuring\n\t// remainingOldChildren > 1 if the oldVNode is not already used/matched. Else\n\t// if the oldVNode was null or matched, then there could needs to be at least\n\t// 1 (aka `remainingOldChildren > 0`) children to find and compare against.\n\tlet shouldSearch =\n\t\tremainingOldChildren >\n\t\t(oldVNode != null && (oldVNode._flags & MATCHED) === 0 ? 1 : 0);\n\n\tif (\n\t\toldVNode === null ||\n\t\t(oldVNode &&\n\t\t\tkey == oldVNode.key &&\n\t\t\ttype === oldVNode.type &&\n\t\t\t(oldVNode._flags & MATCHED) === 0)\n\t) {\n\t\treturn skewedIndex;\n\t} else if (shouldSearch) {\n\t\twhile (x >= 0 || y < oldChildren.length) {\n\t\t\tif (x >= 0) {\n\t\t\t\toldVNode = oldChildren[x];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) === 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t\tx--;\n\t\t\t}\n\n\t\t\tif (y < oldChildren.length) {\n\t\t\t\toldVNode = oldChildren[y];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) === 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn y;\n\t\t\t\t}\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n", "import {\n\tEMPTY_OBJ,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tRESET_MODE\n} from '../constants';\nimport { BaseComponent, getDomSibling } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { setProperty } from './props';\nimport { assign, isArray, removeNode, slice } from '../util';\nimport options from '../options';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {PreactElement} parentDom The parent of the DOM element\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\t/** @type {any} */\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._flags & MODE_SUSPENDED) {\n\t\tisHydrating = !!(oldVNode._flags & MODE_HYDRATE);\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\touter: if (typeof newType == 'function') {\n\t\ttry {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\t\t\tconst isClassComponent =\n\t\t\t\t'prototype' in newType && newType.prototype.render;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif (isClassComponent) {\n\t\t\t\t\t// @ts-expect-error The check above verifies that newType is suppose to be constructed\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-expect-error Trust me, Component implements the interface we want\n\t\t\t\t\tnewVNode._component = c = new BaseComponent(\n\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (isClassComponent && c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\n\t\t\tif (isClassComponent && newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\t\t\tc._vnode = newVNode;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!c._force &&\n\t\t\t\t\t((c.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\t\tnewVNode._original === oldVNode._original)\n\t\t\t\t) {\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) {\n\t\t\t\t\t\t// When we are dealing with a bail because of sCU we have to update\n\t\t\t\t\t\t// the props, state and dirty-state.\n\t\t\t\t\t\t// when we are dealing with strict-equality we don't as the child could still\n\t\t\t\t\t\t// be dirtied see #3883\n\t\t\t\t\t\tc.props = newProps;\n\t\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t\tc._dirty = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tnewVNode._children.forEach(vnode => {\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\n\t\t\t\t\t});\n\n\t\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t\t}\n\t\t\t\t\tc._stateCallbacks = [];\n\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc._parentDom = parentDom;\n\t\t\tc._force = false;\n\n\t\t\tlet renderHook = options._render,\n\t\t\t\tcount = 0;\n\t\t\tif (isClassComponent) {\n\t\t\t\tc.state = c._nextState;\n\t\t\t\tc._dirty = false;\n\n\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t}\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tc._dirty = false;\n\t\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\t\t// Handle setState called in render, see #2553\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t} while (c._dirty && ++count < 25);\n\t\t\t}\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (isClassComponent && !isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type === Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tisArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnamespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._flags &= RESET_MODE;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tnewVNode._original = null;\n\t\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\t\tif (isHydrating || excessDomChildren != null) {\n\t\t\t\tnewVNode._dom = oldDom;\n\t\t\t\tnewVNode._flags |= isHydrating\n\t\t\t\t\t? MODE_HYDRATE | MODE_SUSPENDED\n\t\t\t\t\t: MODE_HYDRATE;\n\t\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = null;\n\t\t\t\t// ^ could possibly be simplified to:\n\t\t\t\t// excessDomChildren.length = 0;\n\t\t\t} else {\n\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t}\n\t\t\toptions._catchError(e, newVNode, oldVNode);\n\t\t}\n\t} else if (\n\t\texcessDomChildren == null &&\n\t\tnewVNode._original === oldVNode._original\n\t) {\n\t\tnewVNode._children = oldVNode._children;\n\t\tnewVNode._dom = oldVNode._dom;\n\t} else {\n\t\tnewVNode._dom = diffElementNodes(\n\t\t\toldVNode._dom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\t}\n\n\tif ((tmp = options.diffed)) tmp(newVNode);\n}\n\n/**\n * @param {Array<Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {VNode} root\n */\nexport function commitRoot(commitQueue, root, refQueue) {\n\troot._nextDom = undefined;\n\n\tfor (let i = 0; i < refQueue.length; i++) {\n\t\tapplyRef(refQueue[i], refQueue[++i], refQueue[++i]);\n\t}\n\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\t// @ts-expect-error Reuse the commitQueue variable here so the type changes\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\t// @ts-expect-error See above comment on commitQueue\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {PreactElement} dom The DOM element representing the virtual nodes\n * being diffed\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n * @returns {PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating,\n\trefQueue\n) {\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\tlet nodeType = /** @type {string} */ (newVNode.type);\n\t/** @type {any} */\n\tlet i;\n\t/** @type {{ __html?: string }} */\n\tlet newHtml;\n\t/** @type {{ __html?: string }} */\n\tlet oldHtml;\n\t/** @type {ComponentChildren} */\n\tlet newChildren;\n\tlet value;\n\tlet inputValue;\n\tlet checked;\n\n\t// Tracks entering and exiting namespaces when descending through the tree.\n\tif (nodeType === 'svg') namespace = 'http://www.w3.org/2000/svg';\n\telse if (nodeType === 'math')\n\t\tnamespace = 'http://www.w3.org/1998/Math/MathML';\n\telse if (!namespace) namespace = 'http://www.w3.org/1999/xhtml';\n\n\tif (excessDomChildren != null) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tvalue = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tvalue &&\n\t\t\t\t'setAttribute' in value === !!nodeType &&\n\t\t\t\t(nodeType ? value.localName === nodeType : value.nodeType === 3)\n\t\t\t) {\n\t\t\t\tdom = value;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (nodeType === null) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = document.createElementNS(\n\t\t\tnamespace,\n\t\t\tnodeType,\n\t\t\tnewProps.is && newProps\n\t\t);\n\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in\n\t\t// case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (nodeType === null) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data !== newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\t// If we are in a situation where we are not hydrating but are using\n\t\t// existing DOM (e.g. replaceNode) we should read the existing DOM\n\t\t// attributes to diff them\n\t\tif (!isHydrating && excessDomChildren != null) {\n\t\t\toldProps = {};\n\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\tvalue = dom.attributes[i];\n\t\t\t\toldProps[value.name] = value.value;\n\t\t\t}\n\t\t}\n\n\t\tfor (i in oldProps) {\n\t\t\tvalue = oldProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\toldHtml = value;\n\t\t\t} else if (i !== 'key' && !(i in newProps)) {\n\t\t\t\tif (\n\t\t\t\t\t(i == 'value' && 'defaultValue' in newProps) ||\n\t\t\t\t\t(i == 'checked' && 'defaultChecked' in newProps)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsetProperty(dom, i, null, value, namespace);\n\t\t\t}\n\t\t}\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tfor (i in newProps) {\n\t\t\tvalue = newProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t\tnewChildren = value;\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\tnewHtml = value;\n\t\t\t} else if (i == 'value') {\n\t\t\t\tinputValue = value;\n\t\t\t} else if (i == 'checked') {\n\t\t\t\tchecked = value;\n\t\t\t} else if (\n\t\t\t\ti !== 'key' &&\n\t\t\t\t(!isHydrating || typeof value == 'function') &&\n\t\t\t\toldProps[i] !== value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, value, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\tif (\n\t\t\t\t!isHydrating &&\n\t\t\t\t(!oldHtml ||\n\t\t\t\t\t(newHtml.__html !== oldHtml.__html &&\n\t\t\t\t\t\tnewHtml.__html !== dom.innerHTML))\n\t\t\t) {\n\t\t\t\tdom.innerHTML = newHtml.__html;\n\t\t\t}\n\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\tif (oldHtml) dom.innerHTML = '';\n\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tisArray(newChildren) ? newChildren : [newChildren],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnodeType === 'foreignObject'\n\t\t\t\t\t? 'http://www.w3.org/1999/xhtml'\n\t\t\t\t\t: namespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\texcessDomChildren\n\t\t\t\t\t? excessDomChildren[0]\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\t// Remove children that are not part of any vnode.\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// As above, don't diff props during hydration\n\t\tif (!isHydrating) {\n\t\t\ti = 'value';\n\t\t\tif (\n\t\t\t\tinputValue !== undefined &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(inputValue !== dom[i] ||\n\t\t\t\t\t(nodeType === 'progress' && !inputValue) ||\n\t\t\t\t\t// This is only for IE 11 to fix <select> value not being updated.\n\t\t\t\t\t// To avoid a stale select value we need to set the option.value\n\t\t\t\t\t// again, which triggers IE11 to re-evaluate the select value\n\t\t\t\t\t(nodeType === 'option' && inputValue !== oldProps[i]))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, inputValue, oldProps[i], namespace);\n\t\t\t}\n\n\t\t\ti = 'checked';\n\t\t\tif (checked !== undefined && checked !== dom[i]) {\n\t\t\t\tsetProperty(dom, i, checked, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {Ref<any>} ref\n * @param {any} value\n * @param {VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {VNode} vnode The virtual node to unmount\n * @param {VNode} parentVNode The parent of the VNode that initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) {\n\t\t\tapplyRef(r, null, parentVNode);\n\t\t}\n\t}\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentVNode,\n\t\t\t\t\tskipRemove || typeof vnode.type != 'function'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove && vnode._dom != null) {\n\t\tremoveNode(vnode._dom);\n\t}\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._component = vnode._parent = vnode._dom = vnode._nextDom = undefined;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n", "import { EMPTY_OBJ } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { slice } from './util';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {ComponentChild} vnode The virtual node to render\n * @param {PreactElement} parentDom The DOM element to render into\n * @param {PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\n\t// element..\n\tlet isHydrating = typeof replaceNode == 'function';\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\n\tvnode = ((!isHydrating && replaceNode) || parentDom)._children =\n\t\tcreateElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [],\n\t\trefQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\tvnode,\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.namespaceURI,\n\t\t!isHydrating && replaceNode\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t\t? null\n\t\t\t\t: parentDom.firstChild\n\t\t\t\t\t? slice.call(parentDom.childNodes)\n\t\t\t\t\t: null,\n\t\tcommitQueue,\n\t\t!isHydrating && replaceNode\n\t\t\t? replaceNode\n\t\t\t: oldVNode\n\t\t\t\t? oldVNode._dom\n\t\t\t\t: parentDom.firstChild,\n\t\tisHydrating,\n\t\trefQueue\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode, refQueue);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {ComponentChild} vnode The virtual node to render\n * @param {PreactElement} parentDom The DOM element to update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, hydrate);\n}\n", "import { assign, slice } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its\n * children.\n * @param {VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<ComponentChildren>} rest Any additional arguments will be used\n * as replacement children.\n * @returns {VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\n\tlet defaultProps;\n\n\tif (vnode.type && vnode.type.defaultProps) {\n\t\tdefaultProps = vnode.type.defaultProps;\n\t}\n\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse if (props[i] === undefined && defaultProps !== undefined) {\n\t\t\tnormalizedProps[i] = defaultProps[i];\n\t\t} else {\n\t\t\tnormalizedProps[i] = props[i];\n\t\t}\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n", "/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {VNode} vnode The vnode that threw the error that was caught (except\n * for unmounting when this parameter is the highest parent that was being\n * unmounted)\n * @param {VNode} [oldVNode]\n * @param {ErrorInfo} [errorInfo]\n */\nexport function _catchError(error, vnode, oldVNode, errorInfo) {\n\t/** @type {Component} */\n\tlet component,\n\t\t/** @type {ComponentType} */\n\t\tctor,\n\t\t/** @type {boolean} */\n\t\thandled;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != null) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\tcomponent.componentDidCatch(error, errorInfo || {});\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n", "import { options as _options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {import('./internal').Component} */\nlet previousComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\n// Cast to use internal Options type\nconst options = /** @type {import('./internal').Options} */ (_options);\n\nlet oldBeforeDiff = options._diff;\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\nlet oldRoot = options._root;\n\nconst RAF_TIMEOUT = 100;\nlet prevRaf;\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._diff = vnode => {\n\tcurrentComponent = null;\n\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n};\n\noptions._root = (vnode, parentDom) => {\n\tif (vnode && parentDom._children && parentDom._children._mask) {\n\t\tvnode._mask = parentDom._children._mask;\n\t}\n\n\tif (oldRoot) oldRoot(vnode, parentDom);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\tif (previousComponent === currentComponent) {\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentComponent._renderCallbacks = [];\n\t\t\thooks._list.forEach(hookItem => {\n\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t}\n\t\t\t\thookItem._pendingArgs = hookItem._nextValue = undefined;\n\t\t\t});\n\t\t} else {\n\t\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentIndex = 0;\n\t\t}\n\t}\n\tpreviousComponent = currentComponent;\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tif (c.__hooks._pendingEffects.length) afterPaint(afterPaintEffects.push(c));\n\t\tc.__hooks._list.forEach(hookItem => {\n\t\t\tif (hookItem._pendingArgs) {\n\t\t\t\thookItem._args = hookItem._pendingArgs;\n\t\t\t}\n\t\t\thookItem._pendingArgs = undefined;\n\t\t});\n\t}\n\tpreviousComponent = currentComponent = null;\n};\n\n// TODO: Improve typing of commitQueue parameter\n/** @type {(vnode: import('./internal').VNode, commitQueue: any) => void} */\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tlet hasErrored;\n\t\tc.__hooks._list.forEach(s => {\n\t\t\ttry {\n\t\t\t\tinvokeCleanup(s);\n\t\t\t} catch (e) {\n\t\t\t\thasErrored = e;\n\t\t\t}\n\t\t});\n\t\tc.__hooks = undefined;\n\t\tif (hasErrored) options._catchError(hasErrored, c._vnode);\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {any}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\n\treturn hooks._list[index];\n}\n\n/**\n * @template {unknown} S\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} [initialState]\n * @returns {[S, (state: S) => void]}\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @template {unknown} S\n * @template {unknown} A\n * @param {import('./index').Reducer<S, A>} reducer\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ S, (state: S) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst currentValue = hookState._nextValue\n\t\t\t\t\t? hookState._nextValue[0]\n\t\t\t\t\t: hookState._value[0];\n\t\t\t\tconst nextValue = hookState._reducer(currentValue, action);\n\n\t\t\t\tif (currentValue !== nextValue) {\n\t\t\t\t\thookState._nextValue = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\n\t\thookState._component = currentComponent;\n\n\t\tif (!currentComponent._hasScuFromHooks) {\n\t\t\tcurrentComponent._hasScuFromHooks = true;\n\t\t\tlet prevScu = currentComponent.shouldComponentUpdate;\n\t\t\tconst prevCWU = currentComponent.componentWillUpdate;\n\n\t\t\t// If we're dealing with a forced update `shouldComponentUpdate` will\n\t\t\t// not be called. But we use that to update the hook values, so we\n\t\t\t// need to call it.\n\t\t\tcurrentComponent.componentWillUpdate = function (p, s, c) {\n\t\t\t\tif (this._force) {\n\t\t\t\t\tlet tmp = prevScu;\n\t\t\t\t\t// Clear to avoid other sCU hooks from being called\n\t\t\t\t\tprevScu = undefined;\n\t\t\t\t\tupdateHookState(p, s, c);\n\t\t\t\t\tprevScu = tmp;\n\t\t\t\t}\n\n\t\t\t\tif (prevCWU) prevCWU.call(this, p, s, c);\n\t\t\t};\n\n\t\t\t// This SCU has the purpose of bailing out after repeated updates\n\t\t\t// to stateful hooks.\n\t\t\t// we store the next value in _nextValue[0] and keep doing that for all\n\t\t\t// state setters, if we have next states and\n\t\t\t// all next states within a component end up being equal to their original state\n\t\t\t// we are safe to bail out for this specific component.\n\t\t\t/**\n\t\t\t *\n\t\t\t * @type {import('./internal').Component[\"shouldComponentUpdate\"]}\n\t\t\t */\n\t\t\t// @ts-ignore - We don't use TS to downtranspile\n\t\t\t// eslint-disable-next-line no-inner-declarations\n\t\t\tfunction updateHookState(p, s, c) {\n\t\t\t\tif (!hookState._component.__hooks) return true;\n\n\t\t\t\t/** @type {(x: import('./internal').HookState) => x is import('./internal').ReducerHookState} */\n\t\t\t\tconst isStateHook = x => !!x._component;\n\t\t\t\tconst stateHooks =\n\t\t\t\t\thookState._component.__hooks._list.filter(isStateHook);\n\n\t\t\t\tconst allHooksEmpty = stateHooks.every(x => !x._nextValue);\n\t\t\t\t// When we have no updated hooks in the component we invoke the previous SCU or\n\t\t\t\t// traverse the VDOM tree further.\n\t\t\t\tif (allHooksEmpty) {\n\t\t\t\t\treturn prevScu ? prevScu.call(this, p, s, c) : true;\n\t\t\t\t}\n\n\t\t\t\t// We check whether we have components with a nextValue set that\n\t\t\t\t// have values that aren't equal to one another this pushes\n\t\t\t\t// us to update further down the tree\n\t\t\t\tlet shouldUpdate = false;\n\t\t\t\tstateHooks.forEach(hookItem => {\n\t\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\t\tconst currentValue = hookItem._value[0];\n\t\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t\t\thookItem._nextValue = undefined;\n\t\t\t\t\t\tif (currentValue !== hookItem._value[0]) shouldUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn shouldUpdate || hookState._component.props !== p\n\t\t\t\t\t? prevScu\n\t\t\t\t\t\t? prevScu.call(this, p, s, c)\n\t\t\t\t\t\t: true\n\t\t\t\t\t: false;\n\t\t\t}\n\n\t\t\tcurrentComponent.shouldComponentUpdate = updateHookState;\n\t\t}\n\t}\n\n\treturn hookState._nextValue || hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\n/** @type {(initialValue: unknown) => unknown} */\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') {\n\t\t\t\tref(createHandle());\n\t\t\t\treturn () => ref(null);\n\t\t\t} else if (ref) {\n\t\t\t\tref.current = createHandle();\n\t\t\t\treturn () => (ref.current = null);\n\t\t\t}\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @template {unknown} T\n * @param {() => T} factory\n * @param {unknown[]} args\n * @returns {T}\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState<T>} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._value = factory();\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {unknown[]} args\n * @returns {() => void}\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\t/** @type {import('./internal').ContextHookState} */\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(\n\t\t\tformatter ? formatter(value) : /** @type {any}*/ (value)\n\t\t);\n\t}\n}\n\n/**\n * @param {(error: unknown, errorInfo: import('preact').ErrorInfo) => void} cb\n * @returns {[unknown, () => void]}\n */\nexport function useErrorBoundary(cb) {\n\t/** @type {import('./internal').ErrorBoundaryHookState} */\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = (err, errorInfo) => {\n\t\t\tif (state._value) state._value(err, errorInfo);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/** @type {() => string} */\nexport function useId() {\n\t/** @type {import('./internal').IdHookState} */\n\tconst state = getHookState(currentIndex++, 11);\n\tif (!state._value) {\n\t\t// Grab either the root node or the nearest async boundary node.\n\t\t/** @type {import('./internal.d').VNode} */\n\t\tlet root = currentComponent._vnode;\n\t\twhile (root !== null && !root._mask && root._parent !== null) {\n\t\t\troot = root._parent;\n\t\t}\n\n\t\tlet mask = root._mask || (root._mask = [0, 0]);\n\t\tstate._value = 'P' + mask[0] + '-' + mask[1]++;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tlet component;\n\twhile ((component = afterPaintEffects.shift())) {\n\t\tif (!component._parentDom || !component.__hooks) continue;\n\t\ttry {\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t} catch (e) {\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t}\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n * @returns {void}\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').HookState} hook\n * @returns {void}\n */\nfunction invokeCleanup(hook) {\n\t// A hook cleanup can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\tlet cleanup = hook._cleanup;\n\tif (typeof cleanup == 'function') {\n\t\thook._cleanup = undefined;\n\t\tcleanup();\n\t}\n\n\tcurrentComponent = comp;\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n * @returns {void}\n */\nfunction invokeEffect(hook) {\n\t// A hook call can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\thook._cleanup = hook._value();\n\tcurrentComponent = comp;\n}\n\n/**\n * @param {unknown[]} oldArgs\n * @param {unknown[]} newArgs\n * @returns {boolean}\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn (\n\t\t!oldArgs ||\n\t\toldArgs.length !== newArgs.length ||\n\t\tnewArgs.some((arg, index) => arg !== oldArgs[index])\n\t);\n}\n\n/**\n * @template Arg\n * @param {Arg} arg\n * @param {(arg: Arg) => any} f\n * @returns {any}\n */\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n", "/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Check if two objects have a different shape\n * @param {object} a\n * @param {object} b\n * @returns {boolean}\n */\nexport function shallowDiffers(a, b) {\n\tfor (let i in a) if (i !== '__source' && !(i in b)) return true;\n\tfor (let i in b) if (i !== '__source' && a[i] !== b[i]) return true;\n\treturn false;\n}\n\n/**\n * Check if two values are the same value\n * @param {*} x\n * @param {*} y\n * @returns {boolean}\n */\nexport function is(x, y) {\n\treturn (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\n", "import { Component } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Component class with a predefined `shouldComponentUpdate` implementation\n */\nexport function PureComponent(p, c) {\n\tthis.props = p;\n\tthis.context = c;\n}\nPureComponent.prototype = new Component();\n// Some third-party libraries check if this property is present\nPureComponent.prototype.isPureReactComponent = true;\nPureComponent.prototype.shouldComponentUpdate = function (props, state) {\n\treturn shallowDiffers(this.props, props) || shallowDiffers(this.state, state);\n};\n", "import { createElement } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Memoize a component, so that it only updates when the props actually have\n * changed. This was previously known as `React.pure`.\n * @param {import('./internal').FunctionComponent} c functional component\n * @param {(prev: object, next: object) => boolean} [comparer] Custom equality function\n * @returns {import('./internal').FunctionComponent}\n */\nexport function memo(c, comparer) {\n\tfunction shouldUpdate(nextProps) {\n\t\tlet ref = this.props.ref;\n\t\tlet updateRef = ref == nextProps.ref;\n\t\tif (!updateRef && ref) {\n\t\t\tref.call ? ref(null) : (ref.current = null);\n\t\t}\n\n\t\tif (!comparer) {\n\t\t\treturn shallowDiffers(this.props, nextProps);\n\t\t}\n\n\t\treturn !comparer(this.props, nextProps) || !updateRef;\n\t}\n\n\tfunction Memoed(props) {\n\t\tthis.shouldComponentUpdate = shouldUpdate;\n\t\treturn createElement(c, props);\n\t}\n\tMemoed.displayName = 'Memo(' + (c.displayName || c.name) + ')';\n\tMemoed.prototype.isReactComponent = true;\n\tMemoed._forwarded = true;\n\treturn Memoed;\n}\n", "import { options } from 'preact';\nimport { assign } from './util';\n\nlet oldDiffHook = options._diff;\noptions._diff = vnode => {\n\tif (vnode.type && vnode.type._forwarded && vnode.ref) {\n\t\tvnode.props.ref = vnode.ref;\n\t\tvnode.ref = null;\n\t}\n\tif (oldDiffHook) oldDiffHook(vnode);\n};\n\nexport const REACT_FORWARD_SYMBOL =\n\t(typeof Symbol != 'undefined' &&\n\t\tSymbol.for &&\n\t\tSymbol.for('react.forward_ref')) ||\n\t0xf47;\n\n/**\n * Pass ref down to a child. This is mainly used in libraries with HOCs that\n * wrap components. Using `forwardRef` there is an easy way to get a reference\n * of the wrapped component instead of one of the wrapper itself.\n * @param {import('./index').ForwardFn} fn\n * @returns {import('./internal').FunctionComponent}\n */\nexport function forwardRef(fn) {\n\tfunction Forwarded(props) {\n\t\tlet clone = assign({}, props);\n\t\tdelete clone.ref;\n\t\treturn fn(clone, props.ref || null);\n\t}\n\n\t// mobx-react checks for this being present\n\tForwarded.$$typeof = REACT_FORWARD_SYMBOL;\n\t// mobx-react heavily relies on implementation details.\n\t// It expects an object here with a `render` property,\n\t// and prototype.render will fail. Without this\n\t// mobx-react throws.\n\tForwarded.render = Forwarded;\n\n\tForwarded.prototype.isReactComponent = Forwarded._forwarded = true;\n\tForwarded.displayName = 'ForwardRef(' + (fn.displayName || fn.name) + ')';\n\treturn Forwarded;\n}\n", "import { toChildArray } from 'preact';\n\nconst mapFn = (children, fn) => {\n\tif (children == null) return null;\n\treturn toChildArray(toChildArray(children).map(fn));\n};\n\n// This API is completely unnecessary for Preact, so it's basically passthrough.\nexport const Children = {\n\tmap: mapFn,\n\tforEach: mapFn,\n\tcount(children) {\n\t\treturn children ? toChildArray(children).length : 0;\n\t},\n\tonly(children) {\n\t\tconst normalized = toChildArray(children);\n\t\tif (normalized.length !== 1) throw 'Children.only';\n\t\treturn normalized[0];\n\t},\n\ttoArray: toChildArray\n};\n", "import { Component, createElement, options, Fragment } from 'preact';\nimport { MODE_HYDRATE } from '../../src/constants';\nimport { assign } from './util';\n\nconst oldCatchError = options._catchError;\noptions._catchError = function (error, newVNode, oldVNode, errorInfo) {\n\tif (error.then) {\n\t\t/** @type {import('./internal').Component} */\n\t\tlet component;\n\t\tlet vnode = newVNode;\n\n\t\tfor (; (vnode = vnode._parent); ) {\n\t\t\tif ((component = vnode._component) && component._childDidSuspend) {\n\t\t\t\tif (newVNode._dom == null) {\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t}\n\t\t\t\t// Don't call oldCatchError if we found a Suspense\n\t\t\t\treturn component._childDidSuspend(error, newVNode);\n\t\t\t}\n\t\t}\n\t}\n\toldCatchError(error, newVNode, oldVNode, errorInfo);\n};\n\nconst oldUnmount = options.unmount;\noptions.unmount = function (vnode) {\n\t/** @type {import('./internal').Component} */\n\tconst component = vnode._component;\n\tif (component && component._onResolve) {\n\t\tcomponent._onResolve();\n\t}\n\n\t// if the component is still hydrating\n\t// most likely it is because the component is suspended\n\t// we set the vnode.type as `null` so that it is not a typeof function\n\t// so the unmount will remove the vnode._dom\n\tif (component && vnode._flags & MODE_HYDRATE) {\n\t\tvnode.type = null;\n\t}\n\n\tif (oldUnmount) oldUnmount(vnode);\n};\n\nfunction detachedClone(vnode, detachedParent, parentDom) {\n\tif (vnode) {\n\t\tif (vnode._component && vnode._component.__hooks) {\n\t\t\tvnode._component.__hooks._list.forEach(effect => {\n\t\t\t\tif (typeof effect._cleanup == 'function') effect._cleanup();\n\t\t\t});\n\n\t\t\tvnode._component.__hooks = null;\n\t\t}\n\n\t\tvnode = assign({}, vnode);\n\t\tif (vnode._component != null) {\n\t\t\tif (vnode._component._parentDom === parentDom) {\n\t\t\t\tvnode._component._parentDom = detachedParent;\n\t\t\t}\n\t\t\tvnode._component = null;\n\t\t}\n\n\t\tvnode._children =\n\t\t\tvnode._children &&\n\t\t\tvnode._children.map(child =>\n\t\t\t\tdetachedClone(child, detachedParent, parentDom)\n\t\t\t);\n\t}\n\n\treturn vnode;\n}\n\nfunction removeOriginal(vnode, detachedParent, originalParent) {\n\tif (vnode && originalParent) {\n\t\tvnode._original = null;\n\t\tvnode._children =\n\t\t\tvnode._children &&\n\t\t\tvnode._children.map(child =>\n\t\t\t\tremoveOriginal(child, detachedParent, originalParent)\n\t\t\t);\n\n\t\tif (vnode._component) {\n\t\t\tif (vnode._component._parentDom === detachedParent) {\n\t\t\t\tif (vnode._dom) {\n\t\t\t\t\toriginalParent.appendChild(vnode._dom);\n\t\t\t\t}\n\t\t\t\tvnode._component._force = true;\n\t\t\t\tvnode._component._parentDom = originalParent;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn vnode;\n}\n\n// having custom inheritance instead of a class here saves a lot of bytes\nexport function Suspense() {\n\t// we do not call super here to golf some bytes...\n\tthis._pendingSuspensionCount = 0;\n\tthis._suspenders = null;\n\tthis._detachOnNextRender = null;\n}\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspense.prototype = new Component();\n\n/**\n * @this {import('./internal').SuspenseComponent}\n * @param {Promise} promise The thrown promise\n * @param {import('./internal').VNode<any, any>} suspendingVNode The suspending component\n */\nSuspense.prototype._childDidSuspend = function (promise, suspendingVNode) {\n\tconst suspendingComponent = suspendingVNode._component;\n\n\t/** @type {import('./internal').SuspenseComponent} */\n\tconst c = this;\n\n\tif (c._suspenders == null) {\n\t\tc._suspenders = [];\n\t}\n\tc._suspenders.push(suspendingComponent);\n\n\tconst resolve = suspended(c._vnode);\n\n\tlet resolved = false;\n\tconst onResolved = () => {\n\t\tif (resolved) return;\n\n\t\tresolved = true;\n\t\tsuspendingComponent._onResolve = null;\n\n\t\tif (resolve) {\n\t\t\tresolve(onSuspensionComplete);\n\t\t} else {\n\t\t\tonSuspensionComplete();\n\t\t}\n\t};\n\n\tsuspendingComponent._onResolve = onResolved;\n\n\tconst onSuspensionComplete = () => {\n\t\tif (!--c._pendingSuspensionCount) {\n\t\t\t// If the suspension was during hydration we don't need to restore the\n\t\t\t// suspended children into the _children array\n\t\t\tif (c.state._suspended) {\n\t\t\t\tconst suspendedVNode = c.state._suspended;\n\t\t\t\tc._vnode._children[0] = removeOriginal(\n\t\t\t\t\tsuspendedVNode,\n\t\t\t\t\tsuspendedVNode._component._parentDom,\n\t\t\t\t\tsuspendedVNode._component._originalParentDom\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tc.setState({ _suspended: (c._detachOnNextRender = null) });\n\n\t\t\tlet suspended;\n\t\t\twhile ((suspended = c._suspenders.pop())) {\n\t\t\t\tsuspended.forceUpdate();\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * We do not set `suspended: true` during hydration because we want the actual markup\n\t * to remain on screen and hydrate it when the suspense actually gets resolved.\n\t * While in non-hydration cases the usual fallback -> component flow would occour.\n\t */\n\tif (\n\t\t!c._pendingSuspensionCount++ &&\n\t\t!(suspendingVNode._flags & MODE_HYDRATE)\n\t) {\n\t\tc.setState({ _suspended: (c._detachOnNextRender = c._vnode._children[0]) });\n\t}\n\tpromise.then(onResolved, onResolved);\n};\n\nSuspense.prototype.componentWillUnmount = function () {\n\tthis._suspenders = [];\n};\n\n/**\n * @this {import('./internal').SuspenseComponent}\n * @param {import('./internal').SuspenseComponent[\"props\"]} props\n * @param {import('./internal').SuspenseState} state\n */\nSuspense.prototype.render = function (props, state) {\n\tif (this._detachOnNextRender) {\n\t\t// When the Suspense's _vnode was created by a call to createVNode\n\t\t// (i.e. due to a setState further up in the tree)\n\t\t// it's _children prop is null, in this case we \"forget\" about the parked vnodes to detach\n\t\tif (this._vnode._children) {\n\t\t\tconst detachedParent = document.createElement('div');\n\t\t\tconst detachedComponent = this._vnode._children[0]._component;\n\t\t\tthis._vnode._children[0] = detachedClone(\n\t\t\t\tthis._detachOnNextRender,\n\t\t\t\tdetachedParent,\n\t\t\t\t(detachedComponent._originalParentDom = detachedComponent._parentDom)\n\t\t\t);\n\t\t}\n\n\t\tthis._detachOnNextRender = null;\n\t}\n\n\t// Wrap fallback tree in a VNode that prevents itself from being marked as aborting mid-hydration:\n\t/** @type {import('./internal').VNode} */\n\tconst fallback =\n\t\tstate._suspended && createElement(Fragment, null, props.fallback);\n\tif (fallback) fallback._flags &= ~MODE_HYDRATE;\n\n\treturn [\n\t\tcreateElement(Fragment, null, state._suspended ? null : props.children),\n\t\tfallback\n\t];\n};\n\n/**\n * Checks and calls the parent component's _suspended method, passing in the\n * suspended vnode. This is a way for a parent (e.g. SuspenseList) to get notified\n * that one of its children/descendants suspended.\n *\n * The parent MAY return a callback. The callback will get called when the\n * suspension resolves, notifying the parent of the fact.\n * Moreover, the callback gets function `unsuspend` as a parameter. The resolved\n * child descendant will not actually get unsuspended until `unsuspend` gets called.\n * This is a way for the parent to delay unsuspending.\n *\n * If the parent does not return a callback then the resolved vnode\n * gets unsuspended immediately when it resolves.\n *\n * @param {import('./internal').VNode} vnode\n * @returns {((unsuspend: () => void) => void)?}\n */\nexport function suspended(vnode) {\n\t/** @type {import('./internal').Component} */\n\tlet component = vnode._parent._component;\n\treturn component && component._suspended && component._suspended(vnode);\n}\n\nexport function lazy(loader) {\n\tlet prom;\n\tlet component;\n\tlet error;\n\n\tfunction Lazy(props) {\n\t\tif (!prom) {\n\t\t\tprom = loader();\n\t\t\tprom.then(\n\t\t\t\texports => {\n\t\t\t\t\tcomponent = exports.default || exports;\n\t\t\t\t},\n\t\t\t\te => {\n\t\t\t\t\terror = e;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (!component) {\n\t\t\tthrow prom;\n\t\t}\n\n\t\treturn createElement(component, props);\n\t}\n\n\tLazy.displayName = 'Lazy';\n\tLazy._forwarded = true;\n\treturn Lazy;\n}\n", "import { Component, toChildArray } from 'preact';\nimport { suspended } from './suspense.js';\n\n// Indexes to linked list nodes (nodes are stored as arrays to save bytes).\nconst SUSPENDED_COUNT = 0;\nconst RESOLVED_COUNT = 1;\nconst NEXT_NODE = 2;\n\n// Having custom inheritance instead of a class here saves a lot of bytes.\nexport function SuspenseList() {\n\tthis._next = null;\n\tthis._map = null;\n}\n\n// Mark one of child's earlier suspensions as resolved.\n// Some pending callbacks may become callable due to this\n// (e.g. the last suspended descendant gets resolved when\n// revealOrder === 'together'). Process those callbacks as well.\nconst resolve = (list, child, node) => {\n\tif (++node[RESOLVED_COUNT] === node[SUSPENDED_COUNT]) {\n\t\t// The number a child (or any of its descendants) has been suspended\n\t\t// matches the number of times it's been resolved. Therefore we\n\t\t// mark the child as completely resolved by deleting it from ._map.\n\t\t// This is used to figure out when *all* children have been completely\n\t\t// resolved when revealOrder is 'together'.\n\t\tlist._map.delete(child);\n\t}\n\n\t// If revealOrder is falsy then we can do an early exit, as the\n\t// callbacks won't get queued in the node anyway.\n\t// If revealOrder is 'together' then also do an early exit\n\t// if all suspended descendants have not yet been resolved.\n\tif (\n\t\t!list.props.revealOrder ||\n\t\t(list.props.revealOrder[0] === 't' && list._map.size)\n\t) {\n\t\treturn;\n\t}\n\n\t// Walk the currently suspended children in order, calling their\n\t// stored callbacks on the way. Stop if we encounter a child that\n\t// has not been completely resolved yet.\n\tnode = list._next;\n\twhile (node) {\n\t\twhile (node.length > 3) {\n\t\t\tnode.pop()();\n\t\t}\n\t\tif (node[RESOLVED_COUNT] < node[SUSPENDED_COUNT]) {\n\t\t\tbreak;\n\t\t}\n\t\tlist._next = node = node[NEXT_NODE];\n\t}\n};\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspenseList.prototype = new Component();\n\nSuspenseList.prototype._suspended = function (child) {\n\tconst list = this;\n\tconst delegated = suspended(list._vnode);\n\n\tlet node = list._map.get(child);\n\tnode[SUSPENDED_COUNT]++;\n\n\treturn unsuspend => {\n\t\tconst wrappedUnsuspend = () => {\n\t\t\tif (!list.props.revealOrder) {\n\t\t\t\t// Special case the undefined (falsy) revealOrder, as there\n\t\t\t\t// is no need to coordinate a specific order or unsuspends.\n\t\t\t\tunsuspend();\n\t\t\t} else {\n\t\t\t\tnode.push(unsuspend);\n\t\t\t\tresolve(list, child, node);\n\t\t\t}\n\t\t};\n\t\tif (delegated) {\n\t\t\tdelegated(wrappedUnsuspend);\n\t\t} else {\n\t\t\twrappedUnsuspend();\n\t\t}\n\t};\n};\n\nSuspenseList.prototype.render = function (props) {\n\tthis._next = null;\n\tthis._map = new Map();\n\n\tconst children = toChildArray(props.children);\n\tif (props.revealOrder && props.revealOrder[0] === 'b') {\n\t\t// If order === 'backwards' (or, well, anything starting with a 'b')\n\t\t// then flip the child list around so that the last child will be\n\t\t// the first in the linked list.\n\t\tchildren.reverse();\n\t}\n\t// Build the linked list. Iterate through the children in reverse order\n\t// so that `_next` points to the first linked list node to be resolved.\n\tfor (let i = children.length; i--; ) {\n\t\t// Create a new linked list node as an array of form:\n\t\t// \t[suspended_count, resolved_count, next_node]\n\t\t// where suspended_count and resolved_count are numeric counters for\n\t\t// keeping track how many times a node has been suspended and resolved.\n\t\t//\n\t\t// Note that suspended_count starts from 1 instead of 0, so we can block\n\t\t// processing callbacks until componentDidMount has been called. In a sense\n\t\t// node is suspended at least until componentDidMount gets called!\n\t\t//\n\t\t// Pending callbacks are added to the end of the node:\n\t\t// \t[suspended_count, resolved_count, next_node, callback_0, callback_1, ...]\n\t\tthis._map.set(children[i], (this._next = [1, 0, this._next]));\n\t}\n\treturn props.children;\n};\n\nSuspenseList.prototype.componentDidUpdate =\n\tSuspenseList.prototype.componentDidMount = function () {\n\t\t// Iterate through all children after mounting for two reasons:\n\t\t// 1. As each node[SUSPENDED_COUNT] starts from 1, this iteration increases\n\t\t//    each node[RELEASED_COUNT] by 1, therefore balancing the counters.\n\t\t//    The nodes can now be completely consumed from the linked list.\n\t\t// 2. Handle nodes that might have gotten resolved between render and\n\t\t//    componentDidMount.\n\t\tthis._map.forEach((node, child) => {\n\t\t\tresolve(this, child, node);\n\t\t});\n\t};\n", "/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 16;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 17;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n", "import { createElement, render } from 'preact';\n\n/**\n * @param {import('../../src/index').RenderableProps<{ context: any }>} props\n */\nfunction ContextProvider(props) {\n\tthis.getChildContext = () => props.context;\n\treturn props.children;\n}\n\n/**\n * Portal component\n * @this {import('./internal').Component}\n * @param {object | null | undefined} props\n *\n * TODO: use createRoot() instead of fake root\n */\nfunction Portal(props) {\n\tconst _this = this;\n\tlet container = props._container;\n\n\t_this.componentWillUnmount = function () {\n\t\trender(null, _this._temp);\n\t\t_this._temp = null;\n\t\t_this._container = null;\n\t};\n\n\t// When we change container we should clear our old container and\n\t// indicate a new mount.\n\tif (_this._container && _this._container !== container) {\n\t\t_this.componentWillUnmount();\n\t}\n\n\tif (!_this._temp) {\n\t\t_this._container = container;\n\n\t\t// Create a fake DOM parent node that manages a subset of `container`'s children:\n\t\t_this._temp = {\n\t\t\tnodeType: 1,\n\t\t\tparentNode: container,\n\t\t\tchildNodes: [],\n\t\t\tcontains: () => true,\n\t\t\tappendChild(child) {\n\t\t\t\tthis.childNodes.push(child);\n\t\t\t\t_this._container.appendChild(child);\n\t\t\t},\n\t\t\tinsertBefore(child, before) {\n\t\t\t\tthis.childNodes.push(child);\n\t\t\t\t_this._container.appendChild(child);\n\t\t\t},\n\t\t\tremoveChild(child) {\n\t\t\t\tthis.childNodes.splice(this.childNodes.indexOf(child) >>> 1, 1);\n\t\t\t\t_this._container.removeChild(child);\n\t\t\t}\n\t\t};\n\t}\n\n\t// Render our wrapping element into temp.\n\trender(\n\t\tcreateElement(ContextProvider, { context: _this.context }, props._vnode),\n\t\t_this._temp\n\t);\n}\n\n/**\n * Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.\n */\nexport function createPortal(vnode, container) {\n\tconst el = createElement(Portal, { _vnode: vnode, _container: container });\n\tel.containerInfo = container;\n\treturn el;\n}\n", "import {\n\trender as preactRender,\n\thydrate as preactHydrate,\n\toptions,\n\ttoChildArray,\n\tComponent\n} from 'preact';\nimport {\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue,\n\tuseEffect,\n\tuseId,\n\tuseImperativeHandle,\n\tuseLayoutEffect,\n\tuseMemo,\n\tuseReducer,\n\tuseRef,\n\tuseState\n} from 'preact/hooks';\nimport {\n\tuseDeferredValue,\n\tuseInsertionEffect,\n\tuseSyncExternalStore,\n\tuseTransition\n} from './index';\n\nexport const REACT_ELEMENT_TYPE =\n\t(typeof Symbol != 'undefined' && Symbol.for && Symbol.for('react.element')) ||\n\t0xeac7;\n\nconst CAMEL_PROPS =\n\t/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;\nconst ON_ANI = /^on(Ani|Tra|Tou|BeforeInp|Compo)/;\nconst CAMEL_REPLACE = /[A-Z0-9]/g;\n\nconst IS_DOM = typeof document !== 'undefined';\n\n// Input types for which onchange should not be converted to oninput.\n// type=\"file|checkbox|radio\", plus \"range\" in IE11.\n// (IE11 doesn't support Symbol, which we use here to turn `rad` into `ra` which matches \"range\")\nconst onChangeInputType = type =>\n\t(typeof Symbol != 'undefined' && typeof Symbol() == 'symbol'\n\t\t? /fil|che|rad/\n\t\t: /fil|che|ra/\n\t).test(type);\n\n// Some libraries like `react-virtualized` explicitly check for this.\nComponent.prototype.isReactComponent = {};\n\n// `UNSAFE_*` lifecycle hooks\n// Preact only ever invokes the unprefixed methods.\n// Here we provide a base \"fallback\" implementation that calls any defined UNSAFE_ prefixed method.\n// - If a component defines its own `componentDidMount()` (including via defineProperty), use that.\n// - If a component defines `UNSAFE_componentDidMount()`, `componentDidMount` is the alias getter/setter.\n// - If anything assigns to an `UNSAFE_*` property, the assignment is forwarded to the unprefixed property.\n// See https://github.com/preactjs/preact/issues/1941\n[\n\t'componentWillMount',\n\t'componentWillReceiveProps',\n\t'componentWillUpdate'\n].forEach(key => {\n\tObject.defineProperty(Component.prototype, key, {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn this['UNSAFE_' + key];\n\t\t},\n\t\tset(v) {\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: v\n\t\t\t});\n\t\t}\n\t});\n});\n\n/**\n * Proxy render() since React returns a Component reference.\n * @param {import('./internal').VNode} vnode VNode tree to render\n * @param {import('./internal').PreactElement} parent DOM node to render vnode tree into\n * @param {() => void} [callback] Optional callback that will be called after rendering\n * @returns {import('./internal').Component | null} The root component reference or null\n */\nexport function render(vnode, parent, callback) {\n\t// React destroys any existing DOM nodes, see #1727\n\t// ...but only on the first render, see #1828\n\tif (parent._children == null) {\n\t\tparent.textContent = '';\n\t}\n\n\tpreactRender(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nexport function hydrate(vnode, parent, callback) {\n\tpreactHydrate(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nlet oldEventHook = options.event;\noptions.event = e => {\n\tif (oldEventHook) e = oldEventHook(e);\n\n\te.persist = empty;\n\te.isPropagationStopped = isPropagationStopped;\n\te.isDefaultPrevented = isDefaultPrevented;\n\treturn (e.nativeEvent = e);\n};\n\nfunction empty() {}\n\nfunction isPropagationStopped() {\n\treturn this.cancelBubble;\n}\n\nfunction isDefaultPrevented() {\n\treturn this.defaultPrevented;\n}\n\nconst classNameDescriptorNonEnumberable = {\n\tenumerable: false,\n\tconfigurable: true,\n\tget() {\n\t\treturn this.class;\n\t}\n};\n\nfunction handleDomVNode(vnode) {\n\tlet props = vnode.props,\n\t\ttype = vnode.type,\n\t\tnormalizedProps = {};\n\n\tfor (let i in props) {\n\t\tlet value = props[i];\n\n\t\tif (\n\t\t\t(i === 'value' && 'defaultValue' in props && value == null) ||\n\t\t\t// Emulate React's behavior of not rendering the contents of noscript tags on the client.\n\t\t\t(IS_DOM && i === 'children' && type === 'noscript') ||\n\t\t\ti === 'class' ||\n\t\t\ti === 'className'\n\t\t) {\n\t\t\t// Skip applying value if it is null/undefined and we already set\n\t\t\t// a default value\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet lowerCased = i.toLowerCase();\n\t\tif (i === 'defaultValue' && 'value' in props && props.value == null) {\n\t\t\t// `defaultValue` is treated as a fallback `value` when a value prop is present but null/undefined.\n\t\t\t// `defaultValue` for Elements with no value prop is the same as the DOM defaultValue property.\n\t\t\ti = 'value';\n\t\t} else if (i === 'download' && value === true) {\n\t\t\t// Calling `setAttribute` with a truthy value will lead to it being\n\t\t\t// passed as a stringified value, e.g. `download=\"true\"`. React\n\t\t\t// converts it to an empty string instead, otherwise the attribute\n\t\t\t// value will be used as the file name and the file will be called\n\t\t\t// \"true\" upon downloading it.\n\t\t\tvalue = '';\n\t\t} else if (lowerCased === 'translate' && value === 'no') {\n\t\t\tvalue = false;\n\t\t} else if (lowerCased === 'ondoubleclick') {\n\t\t\ti = 'ondblclick';\n\t\t} else if (\n\t\t\tlowerCased === 'onchange' &&\n\t\t\t(type === 'input' || type === 'textarea') &&\n\t\t\t!onChangeInputType(props.type)\n\t\t) {\n\t\t\tlowerCased = i = 'oninput';\n\t\t} else if (lowerCased === 'onfocus') {\n\t\t\ti = 'onfocusin';\n\t\t} else if (lowerCased === 'onblur') {\n\t\t\ti = 'onfocusout';\n\t\t} else if (ON_ANI.test(i)) {\n\t\t\ti = lowerCased;\n\t\t} else if (type.indexOf('-') === -1 && CAMEL_PROPS.test(i)) {\n\t\t\ti = i.replace(CAMEL_REPLACE, '-$&').toLowerCase();\n\t\t} else if (value === null) {\n\t\t\tvalue = undefined;\n\t\t}\n\n\t\t// Add support for onInput and onChange, see #3561\n\t\t// if we have an oninput prop already change it to oninputCapture\n\t\tif (lowerCased === 'oninput') {\n\t\t\ti = lowerCased;\n\t\t\tif (normalizedProps[i]) {\n\t\t\t\ti = 'oninputCapture';\n\t\t\t}\n\t\t}\n\n\t\tnormalizedProps[i] = value;\n\t}\n\n\t// Add support for array select values: <select multiple value={[]} />\n\tif (\n\t\ttype == 'select' &&\n\t\tnormalizedProps.multiple &&\n\t\tArray.isArray(normalizedProps.value)\n\t) {\n\t\t// forEach() always returns undefined, which we abuse here to unset the value prop.\n\t\tnormalizedProps.value = toChildArray(props.children).forEach(child => {\n\t\t\tchild.props.selected =\n\t\t\t\tnormalizedProps.value.indexOf(child.props.value) != -1;\n\t\t});\n\t}\n\n\t// Adding support for defaultValue in select tag\n\tif (type == 'select' && normalizedProps.defaultValue != null) {\n\t\tnormalizedProps.value = toChildArray(props.children).forEach(child => {\n\t\t\tif (normalizedProps.multiple) {\n\t\t\t\tchild.props.selected =\n\t\t\t\t\tnormalizedProps.defaultValue.indexOf(child.props.value) != -1;\n\t\t\t} else {\n\t\t\t\tchild.props.selected =\n\t\t\t\t\tnormalizedProps.defaultValue == child.props.value;\n\t\t\t}\n\t\t});\n\t}\n\n\tif (props.class && !props.className) {\n\t\tnormalizedProps.class = props.class;\n\t\tObject.defineProperty(\n\t\t\tnormalizedProps,\n\t\t\t'className',\n\t\t\tclassNameDescriptorNonEnumberable\n\t\t);\n\t} else if (props.className && !props.class) {\n\t\tnormalizedProps.class = normalizedProps.className = props.className;\n\t} else if (props.class && props.className) {\n\t\tnormalizedProps.class = normalizedProps.className = props.className;\n\t}\n\n\tvnode.props = normalizedProps;\n}\n\nlet oldVNodeHook = options.vnode;\noptions.vnode = vnode => {\n\t// only normalize props on Element nodes\n\tif (typeof vnode.type === 'string') {\n\t\thandleDomVNode(vnode);\n\t}\n\n\tvnode.$$typeof = REACT_ELEMENT_TYPE;\n\n\tif (oldVNodeHook) oldVNodeHook(vnode);\n};\n\n// Only needed for react-relay\nlet currentComponent;\nconst oldBeforeRender = options._render;\noptions._render = function (vnode) {\n\tif (oldBeforeRender) {\n\t\toldBeforeRender(vnode);\n\t}\n\tcurrentComponent = vnode._component;\n};\n\nconst oldDiffed = options.diffed;\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.diffed = function (vnode) {\n\tif (oldDiffed) {\n\t\toldDiffed(vnode);\n\t}\n\n\tconst props = vnode.props;\n\tconst dom = vnode._dom;\n\n\tif (\n\t\tdom != null &&\n\t\tvnode.type === 'textarea' &&\n\t\t'value' in props &&\n\t\tprops.value !== dom.value\n\t) {\n\t\tdom.value = props.value == null ? '' : props.value;\n\t}\n\n\tcurrentComponent = null;\n};\n\n// This is a very very private internal function for React it\n// is used to sort-of do runtime dependency injection.\nexport const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {\n\tReactCurrentDispatcher: {\n\t\tcurrent: {\n\t\t\treadContext(context) {\n\t\t\t\treturn currentComponent._globalContext[context._id].props.value;\n\t\t\t},\n\t\t\tuseCallback,\n\t\t\tuseContext,\n\t\t\tuseDebugValue,\n\t\t\tuseDeferredValue,\n\t\t\tuseEffect,\n\t\t\tuseId,\n\t\t\tuseImperativeHandle,\n\t\t\tuseInsertionEffect,\n\t\t\tuseLayoutEffect,\n\t\t\tuseMemo,\n\t\t\t// useMutableSource, // experimental-only and replaced by uSES, likely not worth supporting\n\t\t\tuseReducer,\n\t\t\tuseRef,\n\t\t\tuseState,\n\t\t\tuseSyncExternalStore,\n\t\t\tuseTransition\n\t\t}\n\t}\n};\n", "import {\n\tcreateElement,\n\trender as preactRender,\n\tcloneElement as preactCloneElement,\n\tcreateRef,\n\tComponent,\n\tcreateContext,\n\tFragment\n} from 'preact';\nimport {\n\tuseState,\n\tuseId,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue\n} from 'preact/hooks';\nimport { PureComponent } from './PureComponent';\nimport { memo } from './memo';\nimport { forwardRef } from './forwardRef';\nimport { Children } from './Children';\nimport { Suspense, lazy } from './suspense';\nimport { SuspenseList } from './suspense-list';\nimport { createPortal } from './portals';\nimport { is } from './util';\nimport {\n\thydrate,\n\trender,\n\tREACT_ELEMENT_TYPE,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n} from './render';\n\nconst version = '17.0.2'; // trick libraries to think we are react\n\n/**\n * Legacy version of createElement.\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor\n */\nfunction createFactory(type) {\n\treturn createElement.bind(null, type);\n}\n\n/**\n * Check if the passed element is a valid (p)react node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isValidElement(element) {\n\treturn !!element && element.$$typeof === REACT_ELEMENT_TYPE;\n}\n\n/**\n * Check if the passed element is a Fragment node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isFragment(element) {\n\treturn isValidElement(element) && element.type === Fragment;\n}\n\n/**\n * Check if the passed element is a Memo node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isMemo(element) {\n\treturn (\n\t\t!!element &&\n\t\t!!element.displayName &&\n\t\t(typeof element.displayName === 'string' ||\n\t\t\telement.displayName instanceof String) &&\n\t\telement.displayName.startsWith('Memo(')\n\t);\n}\n\n/**\n * Wrap `cloneElement` to abort if the passed element is not a valid element and apply\n * all vnode normalizations.\n * @param {import('./internal').VNode} element The vnode to clone\n * @param {object} props Props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Optional component children\n */\nfunction cloneElement(element) {\n\tif (!isValidElement(element)) return element;\n\treturn preactCloneElement.apply(null, arguments);\n}\n\n/**\n * Remove a component tree from the DOM, including state and event handlers.\n * @param {import('./internal').PreactElement} container\n * @returns {boolean}\n */\nfunction unmountComponentAtNode(container) {\n\tif (container._children) {\n\t\tpreactRender(null, container);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n * Get the matching DOM node for a component\n * @param {import('./internal').Component} component\n * @returns {import('./internal').PreactElement | null}\n */\nfunction findDOMNode(component) {\n\treturn (\n\t\t(component &&\n\t\t\t(component.base || (component.nodeType === 1 && component))) ||\n\t\tnull\n\t);\n}\n\n/**\n * Deprecated way to control batched rendering inside the reconciler, but we\n * already schedule in batches inside our rendering code\n * @template Arg\n * @param {(arg: Arg) => void} callback function that triggers the updated\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n */\n// eslint-disable-next-line camelcase\nconst unstable_batchedUpdates = (callback, arg) => callback(arg);\n\n/**\n * In React, `flushSync` flushes the entire tree and forces a rerender. It's\n * implmented here as a no-op.\n * @template Arg\n * @template Result\n * @param {(arg: Arg) => Result} callback function that runs before the flush\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n * @returns\n */\nconst flushSync = (callback, arg) => callback(arg);\n\n/**\n * Strict Mode is not implemented in Preact, so we provide a stand-in for it\n * that just renders its children without imposing any restrictions.\n */\nconst StrictMode = Fragment;\n\nexport function startTransition(cb) {\n\tcb();\n}\n\nexport function useDeferredValue(val) {\n\treturn val;\n}\n\nexport function useTransition() {\n\treturn [false, startTransition];\n}\n\n// TODO: in theory this should be done after a VNode is diffed as we want to insert\n// styles/... before it attaches\nexport const useInsertionEffect = useLayoutEffect;\n\n// compat to react-is\nexport const isElement = isValidElement;\n\n/**\n * This is taken from https://github.com/facebook/react/blob/main/packages/use-sync-external-store/src/useSyncExternalStoreShimClient.js#L84\n * on a high level this cuts out the warnings, ... and attempts a smaller implementation\n * @typedef {{ _value: any; _getSnapshot: () => any }} Store\n */\nexport function useSyncExternalStore(subscribe, getSnapshot) {\n\tconst value = getSnapshot();\n\n\t/**\n\t * @typedef {{ _instance: Store }} StoreRef\n\t * @type {[StoreRef, (store: StoreRef) => void]}\n\t */\n\tconst [{ _instance }, forceUpdate] = useState({\n\t\t_instance: { _value: value, _getSnapshot: getSnapshot }\n\t});\n\n\tuseLayoutEffect(() => {\n\t\t_instance._value = value;\n\t\t_instance._getSnapshot = getSnapshot;\n\n\t\tif (didSnapshotChange(_instance)) {\n\t\t\tforceUpdate({ _instance });\n\t\t}\n\t}, [subscribe, value, getSnapshot]);\n\n\tuseEffect(() => {\n\t\tif (didSnapshotChange(_instance)) {\n\t\t\tforceUpdate({ _instance });\n\t\t}\n\n\t\treturn subscribe(() => {\n\t\t\tif (didSnapshotChange(_instance)) {\n\t\t\t\tforceUpdate({ _instance });\n\t\t\t}\n\t\t});\n\t}, [subscribe]);\n\n\treturn value;\n}\n\n/** @type {(inst: Store) => boolean} */\nfunction didSnapshotChange(inst) {\n\tconst latestGetSnapshot = inst._getSnapshot;\n\tconst prevValue = inst._value;\n\ttry {\n\t\tconst nextValue = latestGetSnapshot();\n\t\treturn !is(prevValue, nextValue);\n\t} catch (error) {\n\t\treturn true;\n\t}\n}\n\nexport * from 'preact/hooks';\nexport {\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tisFragment,\n\tisMemo,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\tflushSync,\n\t// eslint-disable-next-line camelcase\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n\n// React copies the named exports to the default one.\nexport default {\n\tuseState,\n\tuseId,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseInsertionEffect,\n\tuseTransition,\n\tuseDeferredValue,\n\tuseSyncExternalStore,\n\tstartTransition,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue,\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tisElement,\n\tisFragment,\n\tisMemo,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\tflushSync,\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n", "import {\n  AccessorFn,\n  AccessorFnColumnDef,\n  AccessorKeyColumnDef,\n  DisplayColumnDef,\n  GroupColumnDef,\n  IdentifiedColumnDef,\n  RowData,\n} from './types'\nimport { DeepKeys, DeepValue } from './utils'\n\n// type Person = {\n//   firstName: string\n//   lastName: string\n//   age: number\n//   visits: number\n//   status: string\n//   progress: number\n//   createdAt: Date\n//   nested: {\n//     foo: [\n//       {\n//         bar: 'bar'\n//       }\n//     ]\n//     bar: { subBar: boolean }[]\n//     baz: {\n//       foo: 'foo'\n//       bar: {\n//         baz: 'baz'\n//       }\n//     }\n//   }\n// }\n\n// const test: DeepKeys<Person> = 'nested.foo.0.bar'\n// const test2: DeepKeys<Person> = 'nested.bar'\n\n// const helper = createColumnHelper<Person>()\n\n// helper.accessor('nested.foo', {\n//   cell: info => info.getValue(),\n// })\n\n// helper.accessor('nested.foo.0.bar', {\n//   cell: info => info.getValue(),\n// })\n\n// helper.accessor('nested.bar', {\n//   cell: info => info.getValue(),\n// })\n\nexport type ColumnHelper<TData extends RowData> = {\n  accessor: <\n    TAccessor extends AccessorFn<TData> | DeepKeys<TData>,\n    TValue extends TAccessor extends AccessorFn<TData, infer TReturn>\n      ? TReturn\n      : TAccessor extends DeepKeys<TData>\n        ? DeepValue<TData, TAccessor>\n        : never,\n  >(\n    accessor: TAccessor,\n    column: TAccessor extends AccessorFn<TData>\n      ? DisplayColumnDef<TData, TValue>\n      : IdentifiedColumnDef<TData, TValue>\n  ) => TAccessor extends AccessorFn<TData>\n    ? AccessorFnColumnDef<TData, TValue>\n    : AccessorKeyColumnDef<TData, TValue>\n  display: (column: DisplayColumnDef<TData>) => DisplayColumnDef<TData, unknown>\n  group: (column: GroupColumnDef<TData>) => GroupColumnDef<TData, unknown>\n}\n\nexport function createColumnHelper<\n  TData extends RowData,\n>(): ColumnHelper<TData> {\n  return {\n    accessor: (accessor, column) => {\n      return typeof accessor === 'function'\n        ? ({\n            ...column,\n            accessorFn: accessor,\n          } as any)\n        : {\n            ...column,\n            accessorKey: accessor,\n          }\n    },\n    display: column => column,\n    group: column => column,\n  }\n}\n", "import { TableOptionsResolved, TableState, Updater } from './types'\n\nexport type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\nexport type RequiredKeys<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>\nexport type Overwrite<T, U extends { [TKey in keyof T]?: any }> = Omit<\n  T,\n  keyof U\n> &\n  U\n\nexport type UnionToIntersection<T> = (\n  T extends any ? (x: T) => any : never\n) extends (x: infer R) => any\n  ? R\n  : never\n\nexport type IsAny<T, Y, N> = 1 extends 0 & T ? Y : N\nexport type IsKnown<T, Y, N> = unknown extends T ? N : Y\n\ntype ComputeRange<\n  N extends number,\n  Result extends Array<unknown> = [],\n> = Result['length'] extends N\n  ? Result\n  : ComputeRange<N, [...Result, Result['length']]>\ntype Index40 = ComputeRange<40>[number]\n\n// Is this type a tuple?\ntype IsTuple<T> = T extends readonly any[] & { length: infer Length }\n  ? Length extends Index40\n    ? T\n    : never\n  : never\n\n// If this type is a tuple, what indices are allowed?\ntype AllowedIndexes<\n  Tuple extends ReadonlyArray<any>,\n  Keys extends number = never,\n> = Tuple extends readonly []\n  ? Keys\n  : Tuple extends readonly [infer _, ...infer Tail]\n    ? AllowedIndexes<Tail, Keys | Tail['length']>\n    : Keys\n\nexport type DeepKeys<T, TDepth extends any[] = []> = TDepth['length'] extends 5\n  ? never\n  : unknown extends T\n    ? string\n    : T extends readonly any[] & IsTuple<T>\n      ? AllowedIndexes<T> | DeepKeysPrefix<T, AllowedIndexes<T>, TDepth>\n      : T extends any[]\n        ? DeepKeys<T[number], [...TDepth, any]>\n        : T extends Date\n          ? never\n          : T extends object\n            ? (keyof T & string) | DeepKeysPrefix<T, keyof T, TDepth>\n            : never\n\ntype DeepKeysPrefix<\n  T,\n  TPrefix,\n  TDepth extends any[],\n> = TPrefix extends keyof T & (number | string)\n  ? `${TPrefix}.${DeepKeys<T[TPrefix], [...TDepth, any]> & string}`\n  : never\n\nexport type DeepValue<T, TProp> =\n  T extends Record<string | number, any>\n    ? TProp extends `${infer TBranch}.${infer TDeepProp}`\n      ? DeepValue<T[TBranch], TDeepProp>\n      : T[TProp & string]\n    : never\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\n\nexport type Getter<TValue> = <TTValue = TValue>() => NoInfer<TTValue>\n\n///\n\nexport function functionalUpdate<T>(updater: Updater<T>, input: T): T {\n  return typeof updater === 'function'\n    ? (updater as (input: T) => T)(input)\n    : updater\n}\n\nexport function noop() {\n  //\n}\n\nexport function makeStateUpdater<K extends keyof TableState>(\n  key: K,\n  instance: unknown\n) {\n  return (updater: Updater<TableState[K]>) => {\n    ;(instance as any).setState(<TTableState>(old: TTableState) => {\n      return {\n        ...old,\n        [key]: functionalUpdate(updater, (old as any)[key]),\n      }\n    })\n  }\n}\n\ntype AnyFunction = (...args: any) => any\n\nexport function isFunction<T extends AnyFunction>(d: any): d is T {\n  return d instanceof Function\n}\n\nexport function isNumberArray(d: any): d is number[] {\n  return Array.isArray(d) && d.every(val => typeof val === 'number')\n}\n\nexport function flattenBy<TNode>(\n  arr: TNode[],\n  getChildren: (item: TNode) => TNode[]\n) {\n  const flat: TNode[] = []\n\n  const recurse = (subArr: TNode[]) => {\n    subArr.forEach(item => {\n      flat.push(item)\n      const children = getChildren(item)\n      if (children?.length) {\n        recurse(children)\n      }\n    })\n  }\n\n  recurse(arr)\n\n  return flat\n}\n\nexport function memo<TDeps extends readonly any[], TDepArgs, TResult>(\n  getDeps: (depArgs?: TDepArgs) => [...TDeps],\n  fn: (...args: NoInfer<[...TDeps]>) => TResult,\n  opts: {\n    key: any\n    debug?: () => any\n    onChange?: (result: TResult) => void\n  }\n): (depArgs?: TDepArgs) => TResult {\n  let deps: any[] = []\n  let result: TResult | undefined\n\n  return depArgs => {\n    let depTime: number\n    if (opts.key && opts.debug) depTime = Date.now()\n\n    const newDeps = getDeps(depArgs)\n\n    const depsChanged =\n      newDeps.length !== deps.length ||\n      newDeps.some((dep: any, index: number) => deps[index] !== dep)\n\n    if (!depsChanged) {\n      return result!\n    }\n\n    deps = newDeps\n\n    let resultTime: number\n    if (opts.key && opts.debug) resultTime = Date.now()\n\n    result = fn(...newDeps)\n    opts?.onChange?.(result)\n\n    if (opts.key && opts.debug) {\n      if (opts?.debug()) {\n        const depEndTime = Math.round((Date.now() - depTime!) * 100) / 100\n        const resultEndTime = Math.round((Date.now() - resultTime!) * 100) / 100\n        const resultFpsPercentage = resultEndTime / 16\n\n        const pad = (str: number | string, num: number) => {\n          str = String(str)\n          while (str.length < num) {\n            str = ' ' + str\n          }\n          return str\n        }\n\n        console.info(\n          `%c ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n          `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n              0,\n              Math.min(120 - 120 * resultFpsPercentage, 120)\n            )}deg 100% 31%);`,\n          opts?.key\n        )\n      }\n    }\n\n    return result!\n  }\n}\n\nexport function getMemoOptions(\n  tableOptions: Partial<TableOptionsResolved<any>>,\n  debugLevel:\n    | 'debugAll'\n    | 'debugCells'\n    | 'debugTable'\n    | 'debugColumns'\n    | 'debugRows'\n    | 'debugHeaders',\n  key: string,\n  onChange?: (result: any) => void\n) {\n  return {\n    debug: () => tableOptions?.debugAll ?? tableOptions[debugLevel],\n    key: process.env.NODE_ENV === 'development' && key,\n    onChange,\n  }\n}\n", "import { RowData, Cell, Column, Row, Table } from '../types'\nimport { Getter, getMemoOptions, memo } from '../utils'\n\nexport interface CellContext<TData extends RowData, TValue> {\n  cell: Cell<TData, TValue>\n  column: Column<TData, TValue>\n  getValue: Getter<TValue>\n  renderValue: Getter<TValue | null>\n  row: Row<TData>\n  table: Table<TData>\n}\n\nexport interface CoreCell<TData extends RowData, TValue> {\n  /**\n   * The associated Column object for the cell.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/cell#column)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/cells)\n   */\n  column: Column<TData, TValue>\n  /**\n   * Returns the rendering context (or props) for cell-based components like cells and aggregated cells. Use these props with your framework's `flexRender` utility to render these using the template of your choice:\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/cell#getcontext)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/cells)\n   */\n  getContext: () => CellContext<TData, TValue>\n  /**\n   * Returns the value for the cell, accessed via the associated column's accessor key or accessor function.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/cell#getvalue)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/cells)\n   */\n  getValue: CellContext<TData, TValue>['getValue']\n  /**\n   * The unique ID for the cell across the entire table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/cell#id)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/cells)\n   */\n  id: string\n  /**\n   * Renders the value for a cell the same as `getValue`, but will return the `renderFallbackValue` if no value is found.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/cell#rendervalue)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/cells)\n   */\n  renderValue: CellContext<TData, TValue>['renderValue']\n  /**\n   * The associated Row object for the cell.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/cell#row)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/cells)\n   */\n  row: Row<TData>\n}\n\nexport function createCell<TData extends RowData, TValue>(\n  table: Table<TData>,\n  row: Row<TData>,\n  column: Column<TData, TValue>,\n  columnId: string\n): Cell<TData, TValue> {\n  const getRenderValue = () =>\n    cell.getValue() ?? table.options.renderFallbackValue\n\n  const cell: CoreCell<TData, TValue> = {\n    id: `${row.id}_${column.id}`,\n    row,\n    column,\n    getValue: () => row.getValue(columnId),\n    renderValue: getRenderValue,\n    getContext: memo(\n      () => [table, column, row, cell],\n      (table, column, row, cell) => ({\n        table,\n        column,\n        row,\n        cell: cell as Cell<TData, TValue>,\n        getValue: cell.getValue,\n        renderValue: cell.renderValue,\n      }),\n      getMemoOptions(table.options, 'debugCells', 'cell.getContext')\n    ),\n  }\n\n  table._features.forEach(feature => {\n    feature.createCell?.(\n      cell as Cell<TData, TValue>,\n      column,\n      row as Row<TData>,\n      table\n    )\n  }, {})\n\n  return cell as Cell<TData, TValue>\n}\n", "import {\n  Column,\n  Table,\n  AccessorFn,\n  ColumnDef,\n  RowData,\n  ColumnDefResolved,\n} from '../types'\nimport { getMemoOptions, memo } from '../utils'\n\nexport interface CoreColumn<TData extends RowData, TValue> {\n  /**\n   * The resolved accessor function to use when extracting the value for the column from each row. Will only be defined if the column def has a valid accessor key or function defined.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/column#accessorfn)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-defs)\n   */\n  accessorFn?: AccessorFn<TData, TValue>\n  /**\n   * The original column def used to create the column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/column#columndef)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-defs)\n   */\n  columnDef: ColumnDef<TData, TValue>\n  /**\n   * The child column (if the column is a group column). Will be an empty array if the column is not a group column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/column#columns)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-defs)\n   */\n  columns: Column<TData, TValue>[]\n  /**\n   * The depth of the column (if grouped) relative to the root column def array.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/column#depth)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-defs)\n   */\n  depth: number\n  /**\n   * Returns the flattened array of this column and all child/grand-child columns for this column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/column#getflatcolumns)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-defs)\n   */\n  getFlatColumns: () => Column<TData, TValue>[]\n  /**\n   * Returns an array of all leaf-node columns for this column. If a column has no children, it is considered the only leaf-node column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/column#getleafcolumns)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-defs)\n   */\n  getLeafColumns: () => Column<TData, TValue>[]\n  /**\n   * The resolved unique identifier for the column resolved in this priority:\n      - A manual `id` property from the column def\n      - The accessor key from the column def\n      - The header string from the column def\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/column#id)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-defs)\n   */\n  id: string\n  /**\n   * The parent column for this column. Will be undefined if this is a root column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/column#parent)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-defs)\n   */\n  parent?: Column<TData, TValue>\n}\n\nexport function createColumn<TData extends RowData, TValue>(\n  table: Table<TData>,\n  columnDef: ColumnDef<TData, TValue>,\n  depth: number,\n  parent?: Column<TData, TValue>\n): Column<TData, TValue> {\n  const defaultColumn = table._getDefaultColumnDef()\n\n  const resolvedColumnDef = {\n    ...defaultColumn,\n    ...columnDef,\n  } as ColumnDefResolved<TData>\n\n  const accessorKey = resolvedColumnDef.accessorKey\n\n  let id =\n    resolvedColumnDef.id ??\n    (accessorKey ? accessorKey.replace('.', '_') : undefined) ??\n    (typeof resolvedColumnDef.header === 'string'\n      ? resolvedColumnDef.header\n      : undefined)\n\n  let accessorFn: AccessorFn<TData> | undefined\n\n  if (resolvedColumnDef.accessorFn) {\n    accessorFn = resolvedColumnDef.accessorFn\n  } else if (accessorKey) {\n    // Support deep accessor keys\n    if (accessorKey.includes('.')) {\n      accessorFn = (originalRow: TData) => {\n        let result = originalRow as Record<string, any>\n\n        for (const key of accessorKey.split('.')) {\n          result = result?.[key]\n          if (process.env.NODE_ENV !== 'production' && result === undefined) {\n            console.warn(\n              `\"${key}\" in deeply nested key \"${accessorKey}\" returned undefined.`\n            )\n          }\n        }\n\n        return result\n      }\n    } else {\n      accessorFn = (originalRow: TData) =>\n        (originalRow as any)[resolvedColumnDef.accessorKey]\n    }\n  }\n\n  if (!id) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        resolvedColumnDef.accessorFn\n          ? `Columns require an id when using an accessorFn`\n          : `Columns require an id when using a non-string header`\n      )\n    }\n    throw new Error()\n  }\n\n  let column: CoreColumn<TData, any> = {\n    id: `${String(id)}`,\n    accessorFn,\n    parent: parent as any,\n    depth,\n    columnDef: resolvedColumnDef as ColumnDef<TData, any>,\n    columns: [],\n    getFlatColumns: memo(\n      () => [true],\n      () => {\n        return [\n          column as Column<TData, TValue>,\n          ...column.columns?.flatMap(d => d.getFlatColumns()),\n        ]\n      },\n      getMemoOptions(table.options, 'debugColumns', 'column.getFlatColumns')\n    ),\n    getLeafColumns: memo(\n      () => [table._getOrderColumnsFn()],\n      orderColumns => {\n        if (column.columns?.length) {\n          let leafColumns = column.columns.flatMap(column =>\n            column.getLeafColumns()\n          )\n\n          return orderColumns(leafColumns)\n        }\n\n        return [column as Column<TData, TValue>]\n      },\n      getMemoOptions(table.options, 'debugColumns', 'column.getLeafColumns')\n    ),\n  }\n\n  for (const feature of table._features) {\n    feature.createColumn?.(column as Column<TData, TValue>, table)\n  }\n\n  // Yes, we have to convert table to unknown, because we know more than the compiler here.\n  return column as Column<TData, TValue>\n}\n", "import {\n  RowData,\n  Column,\n  Header,\n  HeaderGroup,\n  Table,\n  TableFeature,\n} from '../types'\nimport { getMemoOptions, memo } from '../utils'\n\nconst debug = 'debugHeaders'\n\nexport interface CoreHeaderGroup<TData extends RowData> {\n  depth: number\n  headers: Header<TData, unknown>[]\n  id: string\n}\n\nexport interface HeaderContext<TData, TValue> {\n  /**\n   * An instance of a column.\n   */\n  column: Column<TData, TValue>\n  /**\n   * An instance of a header.\n   */\n  header: Header<TData, TValue>\n  /**\n   * The table instance.\n   */\n  table: Table<TData>\n}\n\nexport interface CoreHeader<TData extends RowData, TValue> {\n  /**\n   * The col-span for the header.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/header#colspan)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  colSpan: number\n  /**\n   * The header's associated column object.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/header#column)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  column: Column<TData, TValue>\n  /**\n   * The depth of the header, zero-indexed based.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/header#depth)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  depth: number\n  /**\n   * Returns the rendering context (or props) for column-based components like headers, footers and filters.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/header#getcontext)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  getContext: () => HeaderContext<TData, TValue>\n  /**\n   * Returns the leaf headers hierarchically nested under this header.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/header#getleafheaders)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  getLeafHeaders: () => Header<TData, unknown>[]\n  /**\n   * The header's associated header group object.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/header#headergroup)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  headerGroup: HeaderGroup<TData>\n  /**\n   * The unique identifier for the header.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/header#id)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  id: string\n  /**\n   * The index for the header within the header group.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/header#index)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  index: number\n  /**\n   * A boolean denoting if the header is a placeholder header.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/header#isplaceholder)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  isPlaceholder: boolean\n  /**\n   * If the header is a placeholder header, this will be a unique header ID that does not conflict with any other headers across the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/header#placeholderid)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  placeholderId?: string\n  /**\n   * The row-span for the header.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/header#rowspan)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  rowSpan: number\n  /**\n   * The header's hierarchical sub/child headers. Will be empty if the header's associated column is a leaf-column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/header#subheaders)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  subHeaders: Header<TData, TValue>[]\n}\n\nexport interface HeadersInstance<TData extends RowData> {\n  /**\n   * Returns all header groups for the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/headers#getheadergroups)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  getHeaderGroups: () => HeaderGroup<TData>[]\n  /**\n   * If pinning, returns the header groups for the left pinned columns.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/headers#getleftheadergroups)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  getLeftHeaderGroups: () => HeaderGroup<TData>[]\n  /**\n   * If pinning, returns the header groups for columns that are not pinned.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/headers#getcenterheadergroups)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  getCenterHeaderGroups: () => HeaderGroup<TData>[]\n  /**\n   * If pinning, returns the header groups for the right pinned columns.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/headers#getrightheadergroups)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  getRightHeaderGroups: () => HeaderGroup<TData>[]\n\n  /**\n   * Returns the footer groups for the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/headers#getfootergroups)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  getFooterGroups: () => HeaderGroup<TData>[]\n  /**\n   * If pinning, returns the footer groups for the left pinned columns.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/headers#getleftfootergroups)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  getLeftFooterGroups: () => HeaderGroup<TData>[]\n  /**\n   * If pinning, returns the footer groups for columns that are not pinned.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/headers#getcenterfootergroups)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  getCenterFooterGroups: () => HeaderGroup<TData>[]\n  /**\n   * If pinning, returns the footer groups for the right pinned columns.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/headers#getrightfootergroups)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  getRightFooterGroups: () => HeaderGroup<TData>[]\n\n  /**\n   * Returns headers for all columns in the table, including parent headers.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/headers#getflatheaders)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  getFlatHeaders: () => Header<TData, unknown>[]\n  /**\n   * If pinning, returns headers for all left pinned columns in the table, including parent headers.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/headers#getleftflatheaders)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  getLeftFlatHeaders: () => Header<TData, unknown>[]\n  /**\n   * If pinning, returns headers for all columns that are not pinned, including parent headers.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/headers#getcenterflatheaders)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  getCenterFlatHeaders: () => Header<TData, unknown>[]\n  /**\n   * If pinning, returns headers for all right pinned columns in the table, including parent headers.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/headers#getrightflatheaders)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  getRightFlatHeaders: () => Header<TData, unknown>[]\n\n  /**\n   * Returns headers for all leaf columns in the table, (not including parent headers).\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/headers#getleafheaders)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  getLeafHeaders: () => Header<TData, unknown>[]\n  /**\n   * If pinning, returns headers for all left pinned leaf columns in the table, (not including parent headers).\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/headers#getleftleafheaders)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  getLeftLeafHeaders: () => Header<TData, unknown>[]\n  /**\n   * If pinning, returns headers for all columns that are not pinned, (not including parent headers).\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/headers#getcenterleafheaders)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  getCenterLeafHeaders: () => Header<TData, unknown>[]\n  /**\n   * If pinning, returns headers for all right pinned leaf columns in the table, (not including parent headers).\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/headers#getrightleafheaders)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/headers)\n   */\n  getRightLeafHeaders: () => Header<TData, unknown>[]\n}\n\n//\n\nfunction createHeader<TData extends RowData, TValue>(\n  table: Table<TData>,\n  column: Column<TData, TValue>,\n  options: {\n    id?: string\n    isPlaceholder?: boolean\n    placeholderId?: string\n    index: number\n    depth: number\n  }\n): Header<TData, TValue> {\n  const id = options.id ?? column.id\n\n  let header: CoreHeader<TData, TValue> = {\n    id,\n    column,\n    index: options.index,\n    isPlaceholder: !!options.isPlaceholder,\n    placeholderId: options.placeholderId,\n    depth: options.depth,\n    subHeaders: [],\n    colSpan: 0,\n    rowSpan: 0,\n    headerGroup: null!,\n    getLeafHeaders: (): Header<TData, unknown>[] => {\n      const leafHeaders: Header<TData, unknown>[] = []\n\n      const recurseHeader = (h: CoreHeader<TData, any>) => {\n        if (h.subHeaders && h.subHeaders.length) {\n          h.subHeaders.map(recurseHeader)\n        }\n        leafHeaders.push(h as Header<TData, unknown>)\n      }\n\n      recurseHeader(header)\n\n      return leafHeaders\n    },\n    getContext: () => ({\n      table,\n      header: header as Header<TData, TValue>,\n      column,\n    }),\n  }\n\n  table._features.forEach(feature => {\n    feature.createHeader?.(header as Header<TData, TValue>, table)\n  })\n\n  return header as Header<TData, TValue>\n}\n\nexport const Headers: TableFeature = {\n  createTable: <TData extends RowData>(table: Table<TData>): void => {\n    // Header Groups\n\n    table.getHeaderGroups = memo(\n      () => [\n        table.getAllColumns(),\n        table.getVisibleLeafColumns(),\n        table.getState().columnPinning.left,\n        table.getState().columnPinning.right,\n      ],\n      (allColumns, leafColumns, left, right) => {\n        const leftColumns =\n          left\n            ?.map(columnId => leafColumns.find(d => d.id === columnId)!)\n            .filter(Boolean) ?? []\n\n        const rightColumns =\n          right\n            ?.map(columnId => leafColumns.find(d => d.id === columnId)!)\n            .filter(Boolean) ?? []\n\n        const centerColumns = leafColumns.filter(\n          column => !left?.includes(column.id) && !right?.includes(column.id)\n        )\n\n        const headerGroups = buildHeaderGroups(\n          allColumns,\n          [...leftColumns, ...centerColumns, ...rightColumns],\n          table\n        )\n\n        return headerGroups\n      },\n      getMemoOptions(table.options, debug, 'getHeaderGroups')\n    )\n\n    table.getCenterHeaderGroups = memo(\n      () => [\n        table.getAllColumns(),\n        table.getVisibleLeafColumns(),\n        table.getState().columnPinning.left,\n        table.getState().columnPinning.right,\n      ],\n      (allColumns, leafColumns, left, right) => {\n        leafColumns = leafColumns.filter(\n          column => !left?.includes(column.id) && !right?.includes(column.id)\n        )\n        return buildHeaderGroups(allColumns, leafColumns, table, 'center')\n      },\n      getMemoOptions(table.options, debug, 'getCenterHeaderGroups')\n    )\n\n    table.getLeftHeaderGroups = memo(\n      () => [\n        table.getAllColumns(),\n        table.getVisibleLeafColumns(),\n        table.getState().columnPinning.left,\n      ],\n      (allColumns, leafColumns, left) => {\n        const orderedLeafColumns =\n          left\n            ?.map(columnId => leafColumns.find(d => d.id === columnId)!)\n            .filter(Boolean) ?? []\n\n        return buildHeaderGroups(allColumns, orderedLeafColumns, table, 'left')\n      },\n      getMemoOptions(table.options, debug, 'getLeftHeaderGroups')\n    )\n\n    table.getRightHeaderGroups = memo(\n      () => [\n        table.getAllColumns(),\n        table.getVisibleLeafColumns(),\n        table.getState().columnPinning.right,\n      ],\n      (allColumns, leafColumns, right) => {\n        const orderedLeafColumns =\n          right\n            ?.map(columnId => leafColumns.find(d => d.id === columnId)!)\n            .filter(Boolean) ?? []\n\n        return buildHeaderGroups(allColumns, orderedLeafColumns, table, 'right')\n      },\n      getMemoOptions(table.options, debug, 'getRightHeaderGroups')\n    )\n\n    // Footer Groups\n\n    table.getFooterGroups = memo(\n      () => [table.getHeaderGroups()],\n      headerGroups => {\n        return [...headerGroups].reverse()\n      },\n      getMemoOptions(table.options, debug, 'getFooterGroups')\n    )\n\n    table.getLeftFooterGroups = memo(\n      () => [table.getLeftHeaderGroups()],\n      headerGroups => {\n        return [...headerGroups].reverse()\n      },\n      getMemoOptions(table.options, debug, 'getLeftFooterGroups')\n    )\n\n    table.getCenterFooterGroups = memo(\n      () => [table.getCenterHeaderGroups()],\n      headerGroups => {\n        return [...headerGroups].reverse()\n      },\n      getMemoOptions(table.options, debug, 'getCenterFooterGroups')\n    )\n\n    table.getRightFooterGroups = memo(\n      () => [table.getRightHeaderGroups()],\n      headerGroups => {\n        return [...headerGroups].reverse()\n      },\n      getMemoOptions(table.options, debug, 'getRightFooterGroups')\n    )\n\n    // Flat Headers\n\n    table.getFlatHeaders = memo(\n      () => [table.getHeaderGroups()],\n      headerGroups => {\n        return headerGroups\n          .map(headerGroup => {\n            return headerGroup.headers\n          })\n          .flat()\n      },\n      getMemoOptions(table.options, debug, 'getFlatHeaders')\n    )\n\n    table.getLeftFlatHeaders = memo(\n      () => [table.getLeftHeaderGroups()],\n      left => {\n        return left\n          .map(headerGroup => {\n            return headerGroup.headers\n          })\n          .flat()\n      },\n      getMemoOptions(table.options, debug, 'getLeftFlatHeaders')\n    )\n\n    table.getCenterFlatHeaders = memo(\n      () => [table.getCenterHeaderGroups()],\n      left => {\n        return left\n          .map(headerGroup => {\n            return headerGroup.headers\n          })\n          .flat()\n      },\n      getMemoOptions(table.options, debug, 'getCenterFlatHeaders')\n    )\n\n    table.getRightFlatHeaders = memo(\n      () => [table.getRightHeaderGroups()],\n      left => {\n        return left\n          .map(headerGroup => {\n            return headerGroup.headers\n          })\n          .flat()\n      },\n      getMemoOptions(table.options, debug, 'getRightFlatHeaders')\n    )\n\n    // Leaf Headers\n\n    table.getCenterLeafHeaders = memo(\n      () => [table.getCenterFlatHeaders()],\n      flatHeaders => {\n        return flatHeaders.filter(header => !header.subHeaders?.length)\n      },\n      getMemoOptions(table.options, debug, 'getCenterLeafHeaders')\n    )\n\n    table.getLeftLeafHeaders = memo(\n      () => [table.getLeftFlatHeaders()],\n      flatHeaders => {\n        return flatHeaders.filter(header => !header.subHeaders?.length)\n      },\n      getMemoOptions(table.options, debug, 'getLeftLeafHeaders')\n    )\n\n    table.getRightLeafHeaders = memo(\n      () => [table.getRightFlatHeaders()],\n      flatHeaders => {\n        return flatHeaders.filter(header => !header.subHeaders?.length)\n      },\n      getMemoOptions(table.options, debug, 'getRightLeafHeaders')\n    )\n\n    table.getLeafHeaders = memo(\n      () => [\n        table.getLeftHeaderGroups(),\n        table.getCenterHeaderGroups(),\n        table.getRightHeaderGroups(),\n      ],\n      (left, center, right) => {\n        return [\n          ...(left[0]?.headers ?? []),\n          ...(center[0]?.headers ?? []),\n          ...(right[0]?.headers ?? []),\n        ]\n          .map(header => {\n            return header.getLeafHeaders()\n          })\n          .flat()\n      },\n      getMemoOptions(table.options, debug, 'getLeafHeaders')\n    )\n  },\n}\n\nexport function buildHeaderGroups<TData extends RowData>(\n  allColumns: Column<TData, unknown>[],\n  columnsToGroup: Column<TData, unknown>[],\n  table: Table<TData>,\n  headerFamily?: 'center' | 'left' | 'right'\n) {\n  // Find the max depth of the columns:\n  // build the leaf column row\n  // build each buffer row going up\n  //    placeholder for non-existent level\n  //    real column for existing level\n\n  let maxDepth = 0\n\n  const findMaxDepth = (columns: Column<TData, unknown>[], depth = 1) => {\n    maxDepth = Math.max(maxDepth, depth)\n\n    columns\n      .filter(column => column.getIsVisible())\n      .forEach(column => {\n        if (column.columns?.length) {\n          findMaxDepth(column.columns, depth + 1)\n        }\n      }, 0)\n  }\n\n  findMaxDepth(allColumns)\n\n  let headerGroups: HeaderGroup<TData>[] = []\n\n  const createHeaderGroup = (\n    headersToGroup: Header<TData, unknown>[],\n    depth: number\n  ) => {\n    // The header group we are creating\n    const headerGroup: HeaderGroup<TData> = {\n      depth,\n      id: [headerFamily, `${depth}`].filter(Boolean).join('_'),\n      headers: [],\n    }\n\n    // The parent columns we're going to scan next\n    const pendingParentHeaders: Header<TData, unknown>[] = []\n\n    // Scan each column for parents\n    headersToGroup.forEach(headerToGroup => {\n      // What is the latest (last) parent column?\n\n      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0]\n\n      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth\n\n      let column: Column<TData, unknown>\n      let isPlaceholder = false\n\n      if (isLeafHeader && headerToGroup.column.parent) {\n        // The parent header is new\n        column = headerToGroup.column.parent\n      } else {\n        // The parent header is repeated\n        column = headerToGroup.column\n        isPlaceholder = true\n      }\n\n      if (\n        latestPendingParentHeader &&\n        latestPendingParentHeader?.column === column\n      ) {\n        // This column is repeated. Add it as a sub header to the next batch\n        latestPendingParentHeader.subHeaders.push(headerToGroup)\n      } else {\n        // This is a new header. Let's create it\n        const header = createHeader(table, column, {\n          id: [headerFamily, depth, column.id, headerToGroup?.id]\n            .filter(Boolean)\n            .join('_'),\n          isPlaceholder,\n          placeholderId: isPlaceholder\n            ? `${pendingParentHeaders.filter(d => d.column === column).length}`\n            : undefined,\n          depth,\n          index: pendingParentHeaders.length,\n        })\n\n        // Add the headerToGroup as a subHeader of the new header\n        header.subHeaders.push(headerToGroup)\n        // Add the new header to the pendingParentHeaders to get grouped\n        // in the next batch\n        pendingParentHeaders.push(header)\n      }\n\n      headerGroup.headers.push(headerToGroup)\n      headerToGroup.headerGroup = headerGroup\n    })\n\n    headerGroups.push(headerGroup)\n\n    if (depth > 0) {\n      createHeaderGroup(pendingParentHeaders, depth - 1)\n    }\n  }\n\n  const bottomHeaders = columnsToGroup.map((column, index) =>\n    createHeader(table, column, {\n      depth: maxDepth,\n      index,\n    })\n  )\n\n  createHeaderGroup(bottomHeaders, maxDepth - 1)\n\n  headerGroups.reverse()\n\n  // headerGroups = headerGroups.filter(headerGroup => {\n  //   return !headerGroup.headers.every(header => header.isPlaceholder)\n  // })\n\n  const recurseHeadersForSpans = (\n    headers: Header<TData, unknown>[]\n  ): { colSpan: number; rowSpan: number }[] => {\n    const filteredHeaders = headers.filter(header =>\n      header.column.getIsVisible()\n    )\n\n    return filteredHeaders.map(header => {\n      let colSpan = 0\n      let rowSpan = 0\n      let childRowSpans = [0]\n\n      if (header.subHeaders && header.subHeaders.length) {\n        childRowSpans = []\n\n        recurseHeadersForSpans(header.subHeaders).forEach(\n          ({ colSpan: childColSpan, rowSpan: childRowSpan }) => {\n            colSpan += childColSpan\n            childRowSpans.push(childRowSpan)\n          }\n        )\n      } else {\n        colSpan = 1\n      }\n\n      const minChildRowSpan = Math.min(...childRowSpans)\n      rowSpan = rowSpan + minChildRowSpan\n\n      header.colSpan = colSpan\n      header.rowSpan = rowSpan\n\n      return { colSpan, rowSpan }\n    })\n  }\n\n  recurseHeadersForSpans(headerGroups[0]?.headers ?? [])\n\n  return headerGroups\n}\n", "import { RowData, Cell, Row, Table } from '../types'\nimport { flattenBy, getMemoOptions, memo } from '../utils'\nimport { createCell } from './cell'\n\nexport interface CoreRow<TData extends RowData> {\n  _getAllCellsByColumnId: () => Record<string, Cell<TData, unknown>>\n  _uniqueValuesCache: Record<string, unknown>\n  _valuesCache: Record<string, unknown>\n  /**\n   * The depth of the row (if nested or grouped) relative to the root row array.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/row#depth)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/rows)\n   */\n  depth: number\n  /**\n   * Returns all of the cells for the row.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/row#getallcells)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/rows)\n   */\n  getAllCells: () => Cell<TData, unknown>[]\n  /**\n   * Returns the leaf rows for the row, not including any parent rows.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/row#getleafrows)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/rows)\n   */\n  getLeafRows: () => Row<TData>[]\n  /**\n   * Returns the parent row for the row, if it exists.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/row#getparentrow)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/rows)\n   */\n  getParentRow: () => Row<TData> | undefined\n  /**\n   * Returns the parent rows for the row, all the way up to a root row.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/row#getparentrows)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/rows)\n   */\n  getParentRows: () => Row<TData>[]\n  /**\n   * Returns a unique array of values from the row for a given columnId.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/row#getuniquevalues)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/rows)\n   */\n  getUniqueValues: <TValue>(columnId: string) => TValue[]\n  /**\n   * Returns the value from the row for a given columnId.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/row#getvalue)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/rows)\n   */\n  getValue: <TValue>(columnId: string) => TValue\n  /**\n   * The resolved unique identifier for the row resolved via the `options.getRowId` option. Defaults to the row's index (or relative index if it is a subRow).\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/row#id)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/rows)\n   */\n  id: string\n  /**\n   * The index of the row within its parent array (or the root data array).\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/row#index)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/rows)\n   */\n  index: number\n  /**\n   * The original row object provided to the table. If the row is a grouped row, the original row object will be the first original in the group.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/row#original)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/rows)\n   */\n  original: TData\n  /**\n   * An array of the original subRows as returned by the `options.getSubRows` option.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/row#originalsubrows)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/rows)\n   */\n  originalSubRows?: TData[]\n  /**\n   * If nested, this row's parent row id.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/row#parentid)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/rows)\n   */\n  parentId?: string\n  /**\n   * Renders the value for the row in a given columnId the same as `getValue`, but will return the `renderFallbackValue` if no value is found.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/row#rendervalue)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/rows)\n   */\n  renderValue: <TValue>(columnId: string) => TValue\n  /**\n   * An array of subRows for the row as returned and created by the `options.getSubRows` option.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/row#subrows)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/rows)\n   */\n  subRows: Row<TData>[]\n}\n\nexport const createRow = <TData extends RowData>(\n  table: Table<TData>,\n  id: string,\n  original: TData,\n  rowIndex: number,\n  depth: number,\n  subRows?: Row<TData>[],\n  parentId?: string\n): Row<TData> => {\n  let row: CoreRow<TData> = {\n    id,\n    index: rowIndex,\n    original,\n    depth,\n    parentId,\n    _valuesCache: {},\n    _uniqueValuesCache: {},\n    getValue: columnId => {\n      if (row._valuesCache.hasOwnProperty(columnId)) {\n        return row._valuesCache[columnId]\n      }\n\n      const column = table.getColumn(columnId)\n\n      if (!column?.accessorFn) {\n        return undefined\n      }\n\n      row._valuesCache[columnId] = column.accessorFn(\n        row.original as TData,\n        rowIndex\n      )\n\n      return row._valuesCache[columnId] as any\n    },\n    getUniqueValues: columnId => {\n      if (row._uniqueValuesCache.hasOwnProperty(columnId)) {\n        return row._uniqueValuesCache[columnId]\n      }\n\n      const column = table.getColumn(columnId)\n\n      if (!column?.accessorFn) {\n        return undefined\n      }\n\n      if (!column.columnDef.getUniqueValues) {\n        row._uniqueValuesCache[columnId] = [row.getValue(columnId)]\n        return row._uniqueValuesCache[columnId]\n      }\n\n      row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(\n        row.original as TData,\n        rowIndex\n      )\n\n      return row._uniqueValuesCache[columnId] as any\n    },\n    renderValue: columnId =>\n      row.getValue(columnId) ?? table.options.renderFallbackValue,\n    subRows: subRows ?? [],\n    getLeafRows: () => flattenBy(row.subRows, d => d.subRows),\n    getParentRow: () =>\n      row.parentId ? table.getRow(row.parentId, true) : undefined,\n    getParentRows: () => {\n      let parentRows: Row<TData>[] = []\n      let currentRow = row\n      while (true) {\n        const parentRow = currentRow.getParentRow()\n        if (!parentRow) break\n        parentRows.push(parentRow)\n        currentRow = parentRow\n      }\n      return parentRows.reverse()\n    },\n    getAllCells: memo(\n      () => [table.getAllLeafColumns()],\n      leafColumns => {\n        return leafColumns.map(column => {\n          return createCell(table, row as Row<TData>, column, column.id)\n        })\n      },\n      getMemoOptions(table.options, 'debugRows', 'getAllCells')\n    ),\n\n    _getAllCellsByColumnId: memo(\n      () => [row.getAllCells()],\n      allCells => {\n        return allCells.reduce(\n          (acc, cell) => {\n            acc[cell.column.id] = cell\n            return acc\n          },\n          {} as Record<string, Cell<TData, unknown>>\n        )\n      },\n      getMemoOptions(table.options, 'debugRows', 'getAllCellsByColumnId')\n    ),\n  }\n\n  for (let i = 0; i < table._features.length; i++) {\n    const feature = table._features[i]\n    feature?.createRow?.(row as Row<TData>, table)\n  }\n\n  return row as Row<TData>\n}\n", "import { RowModel } from '..'\nimport { Column, RowData, Table, TableFeature } from '../types'\n\nexport interface FacetedColumn<TData extends RowData> {\n  _getFacetedMinMaxValues?: () => undefined | [number, number]\n  _getFacetedRowModel?: () => RowModel<TData>\n  _getFacetedUniqueValues?: () => Map<any, number>\n  /**\n   * A function that **computes and returns** a min/max tuple derived from `column.getFacetedRowModel`. Useful for displaying faceted result values.\n   * >  Requires that you pass a valid `getFacetedMinMaxValues` function to `options.getFacetedMinMaxValues`. A default implementation is provided via the exported `getFacetedMinMaxValues` function.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-faceting#getfacetedminmaxvalues)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-faceting)\n   */\n  getFacetedMinMaxValues: () => undefined | [number, number]\n  /**\n   * Returns the row model with all other column filters applied, excluding its own filter. Useful for displaying faceted result counts.\n   * >  Requires that you pass a valid `getFacetedRowModel` function to `options.facetedRowModel`. A default implementation is provided via the exported `getFacetedRowModel` function.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-faceting#getfacetedrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-faceting)\n   */\n  getFacetedRowModel: () => RowModel<TData>\n  /**\n   * A function that **computes and returns** a `Map` of unique values and their occurrences derived from `column.getFacetedRowModel`. Useful for displaying faceted result values.\n   * >  Requires that you pass a valid `getFacetedUniqueValues` function to `options.getFacetedUniqueValues`. A default implementation is provided via the exported `getFacetedUniqueValues` function.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-faceting#getfaceteduniquevalues)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-faceting)\n   */\n  getFacetedUniqueValues: () => Map<any, number>\n}\n\nexport interface FacetedOptions<TData extends RowData> {\n  getFacetedMinMaxValues?: (\n    table: Table<TData>,\n    columnId: string\n  ) => () => undefined | [number, number]\n  getFacetedRowModel?: (\n    table: Table<TData>,\n    columnId: string\n  ) => () => RowModel<TData>\n  getFacetedUniqueValues?: (\n    table: Table<TData>,\n    columnId: string\n  ) => () => Map<any, number>\n}\n\n//\n\nexport const ColumnFaceting: TableFeature = {\n  createColumn: <TData extends RowData>(\n    column: Column<TData, unknown>,\n    table: Table<TData>\n  ): void => {\n    column._getFacetedRowModel =\n      table.options.getFacetedRowModel &&\n      table.options.getFacetedRowModel(table, column.id)\n    column.getFacetedRowModel = () => {\n      if (!column._getFacetedRowModel) {\n        return table.getPreFilteredRowModel()\n      }\n\n      return column._getFacetedRowModel()\n    }\n    column._getFacetedUniqueValues =\n      table.options.getFacetedUniqueValues &&\n      table.options.getFacetedUniqueValues(table, column.id)\n    column.getFacetedUniqueValues = () => {\n      if (!column._getFacetedUniqueValues) {\n        return new Map()\n      }\n\n      return column._getFacetedUniqueValues()\n    }\n    column._getFacetedMinMaxValues =\n      table.options.getFacetedMinMaxValues &&\n      table.options.getFacetedMinMaxValues(table, column.id)\n    column.getFacetedMinMaxValues = () => {\n      if (!column._getFacetedMinMaxValues) {\n        return undefined\n      }\n\n      return column._getFacetedMinMaxValues()\n    }\n  },\n}\n", "import { FilterFn } from './features/ColumnFiltering'\n\nconst includesString: FilterFn<any> = (\n  row,\n  columnId: string,\n  filterValue: string\n) => {\n  const search = filterValue.toLowerCase()\n  return Boolean(\n    row\n      .getValue<string | null>(columnId)\n      ?.toString()\n      ?.toLowerCase()\n      ?.includes(search)\n  )\n}\n\nincludesString.autoRemove = (val: any) => testFalsey(val)\n\nconst includesStringSensitive: FilterFn<any> = (\n  row,\n  columnId: string,\n  filterValue: string\n) => {\n  return Boolean(\n    row.getValue<string | null>(columnId)?.toString()?.includes(filterValue)\n  )\n}\n\nincludesStringSensitive.autoRemove = (val: any) => testFalsey(val)\n\nconst equalsString: FilterFn<any> = (\n  row,\n  columnId: string,\n  filterValue: string\n) => {\n  return (\n    row.getValue<string | null>(columnId)?.toString()?.toLowerCase() ===\n    filterValue?.toLowerCase()\n  )\n}\n\nequalsString.autoRemove = (val: any) => testFalsey(val)\n\nconst arrIncludes: FilterFn<any> = (\n  row,\n  columnId: string,\n  filterValue: unknown\n) => {\n  return row.getValue<unknown[]>(columnId)?.includes(filterValue)\n}\n\narrIncludes.autoRemove = (val: any) => testFalsey(val) || !val?.length\n\nconst arrIncludesAll: FilterFn<any> = (\n  row,\n  columnId: string,\n  filterValue: unknown[]\n) => {\n  return !filterValue.some(\n    val => !row.getValue<unknown[]>(columnId)?.includes(val)\n  )\n}\n\narrIncludesAll.autoRemove = (val: any) => testFalsey(val) || !val?.length\n\nconst arrIncludesSome: FilterFn<any> = (\n  row,\n  columnId: string,\n  filterValue: unknown[]\n) => {\n  return filterValue.some(val =>\n    row.getValue<unknown[]>(columnId)?.includes(val)\n  )\n}\n\narrIncludesSome.autoRemove = (val: any) => testFalsey(val) || !val?.length\n\nconst equals: FilterFn<any> = (row, columnId: string, filterValue: unknown) => {\n  return row.getValue(columnId) === filterValue\n}\n\nequals.autoRemove = (val: any) => testFalsey(val)\n\nconst weakEquals: FilterFn<any> = (\n  row,\n  columnId: string,\n  filterValue: unknown\n) => {\n  return row.getValue(columnId) == filterValue\n}\n\nweakEquals.autoRemove = (val: any) => testFalsey(val)\n\nconst inNumberRange: FilterFn<any> = (\n  row,\n  columnId: string,\n  filterValue: [number, number]\n) => {\n  let [min, max] = filterValue\n\n  const rowValue = row.getValue<number>(columnId)\n  return rowValue >= min && rowValue <= max\n}\n\ninNumberRange.resolveFilterValue = (val: [any, any]) => {\n  let [unsafeMin, unsafeMax] = val\n\n  let parsedMin =\n    typeof unsafeMin !== 'number' ? parseFloat(unsafeMin as string) : unsafeMin\n  let parsedMax =\n    typeof unsafeMax !== 'number' ? parseFloat(unsafeMax as string) : unsafeMax\n\n  let min =\n    unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin\n  let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax\n\n  if (min > max) {\n    const temp = min\n    min = max\n    max = temp\n  }\n\n  return [min, max] as const\n}\n\ninNumberRange.autoRemove = (val: any) =>\n  testFalsey(val) || (testFalsey(val[0]) && testFalsey(val[1]))\n\n// Export\n\nexport const filterFns = {\n  includesString,\n  includesStringSensitive,\n  equalsString,\n  arrIncludes,\n  arrIncludesAll,\n  arrIncludesSome,\n  equals,\n  weakEquals,\n  inNumberRange,\n}\n\nexport type BuiltInFilterFn = keyof typeof filterFns\n\n// Utils\n\nfunction testFalsey(val: any) {\n  return val === undefined || val === null || val === ''\n}\n", "import { RowModel } from '..'\nimport { BuiltInFilterFn, filterFns } from '../filterFns'\nimport {\n  Column,\n  FilterFns,\n  FilterMeta,\n  OnChangeFn,\n  Row,\n  RowData,\n  Table,\n  TableFeature,\n  Updater,\n} from '../types'\nimport { functionalUpdate, isFunction, makeStateUpdater } from '../utils'\n\nexport interface ColumnFiltersTableState {\n  columnFilters: ColumnFiltersState\n}\n\nexport type ColumnFiltersState = ColumnFilter[]\n\nexport interface ColumnFilter {\n  id: string\n  value: unknown\n}\n\nexport interface ResolvedColumnFilter<TData extends RowData> {\n  filterFn: FilterFn<TData>\n  id: string\n  resolvedValue: unknown\n}\n\nexport interface FilterFn<TData extends RowData> {\n  (\n    row: Row<TData>,\n    columnId: string,\n    filterValue: any,\n    addMeta: (meta: FilterMeta) => void\n  ): boolean\n  autoRemove?: ColumnFilterAutoRemoveTestFn<TData>\n  resolveFilterValue?: TransformFilterValueFn<TData>\n}\n\nexport type TransformFilterValueFn<TData extends RowData> = (\n  value: any,\n  column?: Column<TData, unknown>\n) => unknown\n\nexport type ColumnFilterAutoRemoveTestFn<TData extends RowData> = (\n  value: any,\n  column?: Column<TData, unknown>\n) => boolean\n\nexport type CustomFilterFns<TData extends RowData> = Record<\n  string,\n  FilterFn<TData>\n>\n\nexport type FilterFnOption<TData extends RowData> =\n  | 'auto'\n  | BuiltInFilterFn\n  | keyof FilterFns\n  | FilterFn<TData>\n\nexport interface ColumnFiltersColumnDef<TData extends RowData> {\n  /**\n   * Enables/disables the **column** filter for this column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#enablecolumnfilter)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  enableColumnFilter?: boolean\n  /**\n   * The filter function to use with this column. Can be the name of a built-in filter function or a custom filter function.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#filterfn)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  filterFn?: FilterFnOption<TData>\n}\n\nexport interface ColumnFiltersColumn<TData extends RowData> {\n  /**\n   * Returns an automatically calculated filter function for the column based off of the columns first known value.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#getautofilterfn)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  getAutoFilterFn: () => FilterFn<TData> | undefined\n  /**\n   * Returns whether or not the column can be **column** filtered.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#getcanfilter)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  getCanFilter: () => boolean\n  /**\n   * Returns the filter function (either user-defined or automatic, depending on configuration) for the columnId specified.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#getfilterfn)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  getFilterFn: () => FilterFn<TData> | undefined\n  /**\n   * Returns the index (including `-1`) of the column filter in the table's `state.columnFilters` array.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#getfilterindex)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  getFilterIndex: () => number\n  /**\n   * Returns the current filter value for the column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#getfiltervalue)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  getFilterValue: () => unknown\n  /**\n   * Returns whether or not the column is currently filtered.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#getisfiltered)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  getIsFiltered: () => boolean\n  /**\n   * A function that sets the current filter value for the column. You can pass it a value or an updater function for immutability-safe operations on existing values.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#setfiltervalue)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  setFilterValue: (updater: Updater<any>) => void\n}\n\nexport interface ColumnFiltersRow<TData extends RowData> {\n  /**\n   * The column filters map for the row. This object tracks whether a row is passing/failing specific filters by their column ID.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#columnfilters)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  columnFilters: Record<string, boolean>\n  /**\n   * The column filters meta map for the row. This object tracks any filter meta for a row as optionally provided during the filtering process.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#columnfiltersmeta)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  columnFiltersMeta: Record<string, FilterMeta>\n}\n\ninterface ColumnFiltersOptionsBase<TData extends RowData> {\n  /**\n   * Enables/disables **column** filtering for all columns.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#enablecolumnfilters)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  enableColumnFilters?: boolean\n  /**\n   * Enables/disables all filtering for the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#enablefilters)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  enableFilters?: boolean\n  /**\n   * By default, filtering is done from parent rows down (so if a parent row is filtered out, all of its children will be filtered out as well). Setting this option to `true` will cause filtering to be done from leaf rows up (which means parent rows will be included so long as one of their child or grand-child rows is also included).\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#filterfromleafrows)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  filterFromLeafRows?: boolean\n  /**\n   * If provided, this function is called **once** per table and should return a **new function** which will calculate and return the row model for the table when it's filtered.\n   * - For server-side filtering, this function is unnecessary and can be ignored since the server should already return the filtered row model.\n   * - For client-side filtering, this function is required. A default implementation is provided via any table adapter's `{ getFilteredRowModel }` export.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#getfilteredrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  getFilteredRowModel?: (table: Table<any>) => () => RowModel<any>\n  /**\n   * Disables the `getFilteredRowModel` from being used to filter data. This may be useful if your table needs to dynamically support both client-side and server-side filtering.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#manualfiltering)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  manualFiltering?: boolean\n  /**\n   * By default, filtering is done for all rows (max depth of 100), no matter if they are root level parent rows or the child leaf rows of a parent row. Setting this option to `0` will cause filtering to only be applied to the root level parent rows, with all sub-rows remaining unfiltered. Similarly, setting this option to `1` will cause filtering to only be applied to child leaf rows 1 level deep, and so on.\n\n   * This is useful for situations where you want a row's entire child hierarchy to be visible regardless of the applied filter.\n    * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#maxleafrowfilterdepth)\n    * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  maxLeafRowFilterDepth?: number\n  /**\n   * If provided, this function will be called with an `updaterFn` when `state.columnFilters` changes. This overrides the default internal state management, so you will need to persist the state change either fully or partially outside of the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#oncolumnfilterschange)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  onColumnFiltersChange?: OnChangeFn<ColumnFiltersState>\n}\n\ntype ResolvedFilterFns = keyof FilterFns extends never\n  ? {\n      filterFns?: Record<string, FilterFn<any>>\n    }\n  : {\n      filterFns: Record<keyof FilterFns, FilterFn<any>>\n    }\n\nexport interface ColumnFiltersOptions<TData extends RowData>\n  extends ColumnFiltersOptionsBase<TData>,\n    ResolvedFilterFns {}\n\nexport interface ColumnFiltersInstance<TData extends RowData> {\n  _getFilteredRowModel?: () => RowModel<TData>\n  /**\n   * Returns the row model for the table after **column** filtering has been applied.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#getfilteredrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  getFilteredRowModel: () => RowModel<TData>\n  /**\n   * Returns the row model for the table before any **column** filtering has been applied.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#getprefilteredrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  getPreFilteredRowModel: () => RowModel<TData>\n  /**\n   * Resets the **columnFilters** state to `initialState.columnFilters`, or `true` can be passed to force a default blank state reset to `[]`.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#resetcolumnfilters)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  resetColumnFilters: (defaultState?: boolean) => void\n  /**\n   * Resets the **globalFilter** state to `initialState.globalFilter`, or `true` can be passed to force a default blank state reset to `undefined`.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#resetglobalfilter)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  resetGlobalFilter: (defaultState?: boolean) => void\n  /**\n   * Sets or updates the `state.columnFilters` state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#setcolumnfilters)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  setColumnFilters: (updater: Updater<ColumnFiltersState>) => void\n  /**\n   * Sets or updates the `state.globalFilter` state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-filtering#setglobalfilter)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-filtering)\n   */\n  setGlobalFilter: (updater: Updater<any>) => void\n}\n\n//\n\nexport const ColumnFiltering: TableFeature = {\n  getDefaultColumnDef: <\n    TData extends RowData,\n  >(): ColumnFiltersColumnDef<TData> => {\n    return {\n      filterFn: 'auto',\n    }\n  },\n\n  getInitialState: (state): ColumnFiltersTableState => {\n    return {\n      columnFilters: [],\n      ...state,\n    }\n  },\n\n  getDefaultOptions: <TData extends RowData>(\n    table: Table<TData>\n  ): ColumnFiltersOptions<TData> => {\n    return {\n      onColumnFiltersChange: makeStateUpdater('columnFilters', table),\n      filterFromLeafRows: false,\n      maxLeafRowFilterDepth: 100,\n    } as ColumnFiltersOptions<TData>\n  },\n\n  createColumn: <TData extends RowData>(\n    column: Column<TData, unknown>,\n    table: Table<TData>\n  ): void => {\n    column.getAutoFilterFn = () => {\n      const firstRow = table.getCoreRowModel().flatRows[0]\n\n      const value = firstRow?.getValue(column.id)\n\n      if (typeof value === 'string') {\n        return filterFns.includesString\n      }\n\n      if (typeof value === 'number') {\n        return filterFns.inNumberRange\n      }\n\n      if (typeof value === 'boolean') {\n        return filterFns.equals\n      }\n\n      if (value !== null && typeof value === 'object') {\n        return filterFns.equals\n      }\n\n      if (Array.isArray(value)) {\n        return filterFns.arrIncludes\n      }\n\n      return filterFns.weakEquals\n    }\n    column.getFilterFn = () => {\n      return isFunction(column.columnDef.filterFn)\n        ? column.columnDef.filterFn\n        : column.columnDef.filterFn === 'auto'\n          ? column.getAutoFilterFn()\n          : // @ts-ignore\n            table.options.filterFns?.[column.columnDef.filterFn as string] ??\n            filterFns[column.columnDef.filterFn as BuiltInFilterFn]\n    }\n    column.getCanFilter = () => {\n      return (\n        (column.columnDef.enableColumnFilter ?? true) &&\n        (table.options.enableColumnFilters ?? true) &&\n        (table.options.enableFilters ?? true) &&\n        !!column.accessorFn\n      )\n    }\n\n    column.getIsFiltered = () => column.getFilterIndex() > -1\n\n    column.getFilterValue = () =>\n      table.getState().columnFilters?.find(d => d.id === column.id)?.value\n\n    column.getFilterIndex = () =>\n      table.getState().columnFilters?.findIndex(d => d.id === column.id) ?? -1\n\n    column.setFilterValue = value => {\n      table.setColumnFilters(old => {\n        const filterFn = column.getFilterFn()\n        const previousFilter = old?.find(d => d.id === column.id)\n\n        const newFilter = functionalUpdate(\n          value,\n          previousFilter ? previousFilter.value : undefined\n        )\n\n        //\n        if (\n          shouldAutoRemoveFilter(filterFn as FilterFn<TData>, newFilter, column)\n        ) {\n          return old?.filter(d => d.id !== column.id) ?? []\n        }\n\n        const newFilterObj = { id: column.id, value: newFilter }\n\n        if (previousFilter) {\n          return (\n            old?.map(d => {\n              if (d.id === column.id) {\n                return newFilterObj\n              }\n              return d\n            }) ?? []\n          )\n        }\n\n        if (old?.length) {\n          return [...old, newFilterObj]\n        }\n\n        return [newFilterObj]\n      })\n    }\n  },\n\n  createRow: <TData extends RowData>(\n    row: Row<TData>,\n    _table: Table<TData>\n  ): void => {\n    row.columnFilters = {}\n    row.columnFiltersMeta = {}\n  },\n\n  createTable: <TData extends RowData>(table: Table<TData>): void => {\n    table.setColumnFilters = (updater: Updater<ColumnFiltersState>) => {\n      const leafColumns = table.getAllLeafColumns()\n\n      const updateFn = (old: ColumnFiltersState) => {\n        return functionalUpdate(updater, old)?.filter(filter => {\n          const column = leafColumns.find(d => d.id === filter.id)\n\n          if (column) {\n            const filterFn = column.getFilterFn()\n\n            if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {\n              return false\n            }\n          }\n\n          return true\n        })\n      }\n\n      table.options.onColumnFiltersChange?.(updateFn)\n    }\n\n    table.resetColumnFilters = defaultState => {\n      table.setColumnFilters(\n        defaultState ? [] : table.initialState?.columnFilters ?? []\n      )\n    }\n\n    table.getPreFilteredRowModel = () => table.getCoreRowModel()\n    table.getFilteredRowModel = () => {\n      if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {\n        table._getFilteredRowModel = table.options.getFilteredRowModel(table)\n      }\n\n      if (table.options.manualFiltering || !table._getFilteredRowModel) {\n        return table.getPreFilteredRowModel()\n      }\n\n      return table._getFilteredRowModel()\n    }\n  },\n}\n\nexport function shouldAutoRemoveFilter<TData extends RowData>(\n  filterFn?: FilterFn<TData>,\n  value?: any,\n  column?: Column<TData, unknown>\n) {\n  return (\n    (filterFn && filterFn.autoRemove\n      ? filterFn.autoRemove(value, column)\n      : false) ||\n    typeof value === 'undefined' ||\n    (typeof value === 'string' && !value)\n  )\n}\n", "import { AggregationFn } from './features/ColumnGrouping'\nimport { isNumberArray } from './utils'\n\nconst sum: AggregationFn<any> = (columnId, _leafRows, childRows) => {\n  // It's faster to just add the aggregations together instead of\n  // process leaf nodes individually\n  return childRows.reduce((sum, next) => {\n    const nextValue = next.getValue(columnId)\n    return sum + (typeof nextValue === 'number' ? nextValue : 0)\n  }, 0)\n}\n\nconst min: AggregationFn<any> = (columnId, _leafRows, childRows) => {\n  let min: number | undefined\n\n  childRows.forEach(row => {\n    const value = row.getValue<number>(columnId)\n\n    if (\n      value != null &&\n      (min! > value || (min === undefined && value >= value))\n    ) {\n      min = value\n    }\n  })\n\n  return min\n}\n\nconst max: AggregationFn<any> = (columnId, _leafRows, childRows) => {\n  let max: number | undefined\n\n  childRows.forEach(row => {\n    const value = row.getValue<number>(columnId)\n    if (\n      value != null &&\n      (max! < value || (max === undefined && value >= value))\n    ) {\n      max = value\n    }\n  })\n\n  return max\n}\n\nconst extent: AggregationFn<any> = (columnId, _leafRows, childRows) => {\n  let min: number | undefined\n  let max: number | undefined\n\n  childRows.forEach(row => {\n    const value = row.getValue<number>(columnId)\n    if (value != null) {\n      if (min === undefined) {\n        if (value >= value) min = max = value\n      } else {\n        if (min > value) min = value\n        if (max! < value) max = value\n      }\n    }\n  })\n\n  return [min, max]\n}\n\nconst mean: AggregationFn<any> = (columnId, leafRows) => {\n  let count = 0\n  let sum = 0\n\n  leafRows.forEach(row => {\n    let value = row.getValue<number>(columnId)\n    if (value != null && (value = +value) >= value) {\n      ++count, (sum += value)\n    }\n  })\n\n  if (count) return sum / count\n\n  return\n}\n\nconst median: AggregationFn<any> = (columnId, leafRows) => {\n  if (!leafRows.length) {\n    return\n  }\n\n  const values = leafRows.map(row => row.getValue(columnId))\n  if (!isNumberArray(values)) {\n    return\n  }\n  if (values.length === 1) {\n    return values[0]\n  }\n\n  const mid = Math.floor(values.length / 2)\n  const nums = values.sort((a, b) => a - b)\n  return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1]! + nums[mid]!) / 2\n}\n\nconst unique: AggregationFn<any> = (columnId, leafRows) => {\n  return Array.from(new Set(leafRows.map(d => d.getValue(columnId))).values())\n}\n\nconst uniqueCount: AggregationFn<any> = (columnId, leafRows) => {\n  return new Set(leafRows.map(d => d.getValue(columnId))).size\n}\n\nconst count: AggregationFn<any> = (_columnId, leafRows) => {\n  return leafRows.length\n}\n\nexport const aggregationFns = {\n  sum,\n  min,\n  max,\n  extent,\n  mean,\n  median,\n  unique,\n  uniqueCount,\n  count,\n}\n\nexport type BuiltInAggregationFn = keyof typeof aggregationFns\n", "import { RowModel } from '..'\nimport { BuiltInAggregationFn, aggregationFns } from '../aggregationFns'\nimport {\n  AggregationFns,\n  Cell,\n  Column,\n  ColumnDefTemplate,\n  OnChangeFn,\n  Row,\n  RowData,\n  Table,\n  TableFeature,\n  Updater,\n} from '../types'\nimport { isFunction, makeStateUpdater } from '../utils'\n\nexport type GroupingState = string[]\n\nexport interface GroupingTableState {\n  grouping: GroupingState\n}\n\nexport type AggregationFn<TData extends RowData> = (\n  columnId: string,\n  leafRows: Row<TData>[],\n  childRows: Row<TData>[]\n) => any\n\nexport type CustomAggregationFns = Record<string, AggregationFn<any>>\n\nexport type AggregationFnOption<TData extends RowData> =\n  | 'auto'\n  | keyof AggregationFns\n  | BuiltInAggregationFn\n  | AggregationFn<TData>\n\nexport interface GroupingColumnDef<TData extends RowData, TValue> {\n  /**\n   * The cell to display each row for the column if the cell is an aggregate. If a function is passed, it will be passed a props object with the context of the cell and should return the property type for your adapter (the exact type depends on the adapter being used).\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#aggregatedcell)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  aggregatedCell?: ColumnDefTemplate<\n    ReturnType<Cell<TData, TValue>['getContext']>\n  >\n  /**\n   * The resolved aggregation function for the column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#aggregationfn)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  aggregationFn?: AggregationFnOption<TData>\n  /**\n   * Enables/disables grouping for this column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#enablegrouping)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  enableGrouping?: boolean\n  /**\n   * Specify a value to be used for grouping rows on this column. If this option is not specified, the value derived from `accessorKey` / `accessorFn` will be used instead.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#getgroupingvalue)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  getGroupingValue?: (row: TData) => any\n}\n\nexport interface GroupingColumn<TData extends RowData> {\n  /**\n   * Returns the aggregation function for the column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#getaggregationfn)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  getAggregationFn: () => AggregationFn<TData> | undefined\n  /**\n   * Returns the automatically inferred aggregation function for the column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#getautoaggregationfn)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  getAutoAggregationFn: () => AggregationFn<TData> | undefined\n  /**\n   * Returns whether or not the column can be grouped.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#getcangroup)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  getCanGroup: () => boolean\n  /**\n   * Returns the index of the column in the grouping state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#getgroupedindex)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  getGroupedIndex: () => number\n  /**\n   * Returns whether or not the column is currently grouped.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#getisgrouped)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  getIsGrouped: () => boolean\n  /**\n   * Returns a function that toggles the grouping state of the column. This is useful for passing to the `onClick` prop of a button.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#gettogglegroupinghandler)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  getToggleGroupingHandler: () => () => void\n  /**\n   * Toggles the grouping state of the column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#togglegrouping)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  toggleGrouping: () => void\n}\n\nexport interface GroupingRow {\n  _groupingValuesCache: Record<string, any>\n  /**\n   * Returns the grouping value for any row and column (including leaf rows).\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#getgroupingvalue)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  getGroupingValue: (columnId: string) => unknown\n  /**\n   * Returns whether or not the row is currently grouped.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#getisgrouped)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  getIsGrouped: () => boolean\n  /**\n   * If this row is grouped, this is the id of the column that this row is grouped by.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#groupingcolumnid)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  groupingColumnId?: string\n  /**\n   * If this row is grouped, this is the unique/shared value for the `groupingColumnId` for all of the rows in this group.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#groupingvalue)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  groupingValue?: unknown\n}\n\nexport interface GroupingCell {\n  /**\n   * Returns whether or not the cell is currently aggregated.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#getisaggregated)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  getIsAggregated: () => boolean\n  /**\n   * Returns whether or not the cell is currently grouped.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#getisgrouped)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  getIsGrouped: () => boolean\n  /**\n   * Returns whether or not the cell is currently a placeholder cell.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#getisplaceholder)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  getIsPlaceholder: () => boolean\n}\n\nexport interface ColumnDefaultOptions {\n  enableGrouping: boolean\n  onGroupingChange: OnChangeFn<GroupingState>\n}\n\ninterface GroupingOptionsBase {\n  /**\n   * Enables/disables grouping for the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#enablegrouping)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  enableGrouping?: boolean\n  /**\n   * Returns the row model after grouping has taken place, but no further.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#getgroupedrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  getGroupedRowModel?: (table: Table<any>) => () => RowModel<any>\n  /**\n   * Grouping columns are automatically reordered by default to the start of the columns list. If you would rather remove them or leave them as-is, set the appropriate mode here.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#groupedcolumnmode)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  groupedColumnMode?: false | 'reorder' | 'remove'\n  /**\n   * Enables manual grouping. If this option is set to `true`, the table will not automatically group rows using `getGroupedRowModel()` and instead will expect you to manually group the rows before passing them to the table. This is useful if you are doing server-side grouping and aggregation.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#manualgrouping)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  manualGrouping?: boolean\n  /**\n   * If this function is provided, it will be called when the grouping state changes and you will be expected to manage the state yourself. You can pass the managed state back to the table via the `tableOptions.state.grouping` option.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#ongroupingchange)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  onGroupingChange?: OnChangeFn<GroupingState>\n}\n\ntype ResolvedAggregationFns = keyof AggregationFns extends never\n  ? {\n      aggregationFns?: Record<string, AggregationFn<any>>\n    }\n  : {\n      aggregationFns: Record<keyof AggregationFns, AggregationFn<any>>\n    }\n\nexport interface GroupingOptions\n  extends GroupingOptionsBase,\n    ResolvedAggregationFns {}\n\nexport type GroupingColumnMode = false | 'reorder' | 'remove'\n\nexport interface GroupingInstance<TData extends RowData> {\n  _getGroupedRowModel?: () => RowModel<TData>\n  /**\n   * Returns the row model for the table after grouping has been applied.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#getgroupedrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  getGroupedRowModel: () => RowModel<TData>\n  /**\n   * Returns the row model for the table before any grouping has been applied.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#getpregroupedrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  getPreGroupedRowModel: () => RowModel<TData>\n  /**\n   * Resets the **grouping** state to `initialState.grouping`, or `true` can be passed to force a default blank state reset to `[]`.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#resetgrouping)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  resetGrouping: (defaultState?: boolean) => void\n  /**\n   * Updates the grouping state of the table via an update function or value.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/grouping#setgrouping)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/grouping)\n   */\n  setGrouping: (updater: Updater<GroupingState>) => void\n}\n\n//\n\nexport const ColumnGrouping: TableFeature = {\n  getDefaultColumnDef: <TData extends RowData>(): GroupingColumnDef<\n    TData,\n    unknown\n  > => {\n    return {\n      aggregatedCell: props => (props.getValue() as any)?.toString?.() ?? null,\n      aggregationFn: 'auto',\n    }\n  },\n\n  getInitialState: (state): GroupingTableState => {\n    return {\n      grouping: [],\n      ...state,\n    }\n  },\n\n  getDefaultOptions: <TData extends RowData>(\n    table: Table<TData>\n  ): GroupingOptions => {\n    return {\n      onGroupingChange: makeStateUpdater('grouping', table),\n      groupedColumnMode: 'reorder',\n    }\n  },\n\n  createColumn: <TData extends RowData, TValue>(\n    column: Column<TData, TValue>,\n    table: Table<TData>\n  ): void => {\n    column.toggleGrouping = () => {\n      table.setGrouping(old => {\n        // Find any existing grouping for this column\n        if (old?.includes(column.id)) {\n          return old.filter(d => d !== column.id)\n        }\n\n        return [...(old ?? []), column.id]\n      })\n    }\n\n    column.getCanGroup = () => {\n      return (\n        (column.columnDef.enableGrouping ?? true) &&\n        (table.options.enableGrouping ?? true) &&\n        (!!column.accessorFn || !!column.columnDef.getGroupingValue)\n      )\n    }\n\n    column.getIsGrouped = () => {\n      return table.getState().grouping?.includes(column.id)\n    }\n\n    column.getGroupedIndex = () => table.getState().grouping?.indexOf(column.id)\n\n    column.getToggleGroupingHandler = () => {\n      const canGroup = column.getCanGroup()\n\n      return () => {\n        if (!canGroup) return\n        column.toggleGrouping()\n      }\n    }\n    column.getAutoAggregationFn = () => {\n      const firstRow = table.getCoreRowModel().flatRows[0]\n\n      const value = firstRow?.getValue(column.id)\n\n      if (typeof value === 'number') {\n        return aggregationFns.sum\n      }\n\n      if (Object.prototype.toString.call(value) === '[object Date]') {\n        return aggregationFns.extent\n      }\n    }\n    column.getAggregationFn = () => {\n      if (!column) {\n        throw new Error()\n      }\n\n      return isFunction(column.columnDef.aggregationFn)\n        ? column.columnDef.aggregationFn\n        : column.columnDef.aggregationFn === 'auto'\n          ? column.getAutoAggregationFn()\n          : table.options.aggregationFns?.[\n              column.columnDef.aggregationFn as string\n            ] ??\n            aggregationFns[\n              column.columnDef.aggregationFn as BuiltInAggregationFn\n            ]\n    }\n  },\n\n  createTable: <TData extends RowData>(table: Table<TData>): void => {\n    table.setGrouping = updater => table.options.onGroupingChange?.(updater)\n\n    table.resetGrouping = defaultState => {\n      table.setGrouping(defaultState ? [] : table.initialState?.grouping ?? [])\n    }\n\n    table.getPreGroupedRowModel = () => table.getFilteredRowModel()\n    table.getGroupedRowModel = () => {\n      if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {\n        table._getGroupedRowModel = table.options.getGroupedRowModel(table)\n      }\n\n      if (table.options.manualGrouping || !table._getGroupedRowModel) {\n        return table.getPreGroupedRowModel()\n      }\n\n      return table._getGroupedRowModel()\n    }\n  },\n\n  createRow: <TData extends RowData>(\n    row: Row<TData>,\n    table: Table<TData>\n  ): void => {\n    row.getIsGrouped = () => !!row.groupingColumnId\n    row.getGroupingValue = columnId => {\n      if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n        return row._groupingValuesCache[columnId]\n      }\n\n      const column = table.getColumn(columnId)\n\n      if (!column?.columnDef.getGroupingValue) {\n        return row.getValue(columnId)\n      }\n\n      row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(\n        row.original\n      )\n\n      return row._groupingValuesCache[columnId]\n    }\n    row._groupingValuesCache = {}\n  },\n\n  createCell: <TData extends RowData, TValue>(\n    cell: Cell<TData, TValue>,\n    column: Column<TData, TValue>,\n    row: Row<TData>,\n    table: Table<TData>\n  ): void => {\n    const getRenderValue = () =>\n      cell.getValue() ?? table.options.renderFallbackValue\n\n    cell.getIsGrouped = () =>\n      column.getIsGrouped() && column.id === row.groupingColumnId\n    cell.getIsPlaceholder = () => !cell.getIsGrouped() && column.getIsGrouped()\n    cell.getIsAggregated = () =>\n      !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!row.subRows?.length\n  },\n}\n\nexport function orderColumns<TData extends RowData>(\n  leafColumns: Column<TData, unknown>[],\n  grouping: string[],\n  groupedColumnMode?: GroupingColumnMode\n) {\n  if (!grouping?.length || !groupedColumnMode) {\n    return leafColumns\n  }\n\n  const nonGroupingColumns = leafColumns.filter(\n    col => !grouping.includes(col.id)\n  )\n\n  if (groupedColumnMode === 'remove') {\n    return nonGroupingColumns\n  }\n\n  const groupingColumns = grouping\n    .map(g => leafColumns.find(col => col.id === g)!)\n    .filter(Boolean)\n\n  return [...groupingColumns, ...nonGroupingColumns]\n}\n", "import { getMemoOptions, makeStateUpdater, memo } from '../utils'\n\nimport {\n  Column,\n  OnChangeFn,\n  RowData,\n  Table,\n  TableFeature,\n  Updater,\n} from '../types'\n\nimport { orderColumns } from './ColumnGrouping'\nimport { ColumnPinningPosition, _getVisibleLeafColumns } from '..'\n\nexport interface ColumnOrderTableState {\n  columnOrder: ColumnOrderState\n}\n\nexport type ColumnOrderState = string[]\n\nexport interface ColumnOrderOptions {\n  /**\n   * If provided, this function will be called with an `updaterFn` when `state.columnOrder` changes. This overrides the default internal state management, so you will need to persist the state change either fully or partially outside of the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-ordering#oncolumnorderchange)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-ordering)\n   */\n  onColumnOrderChange?: OnChangeFn<ColumnOrderState>\n}\n\nexport interface ColumnOrderColumn {\n  /**\n   * Returns the index of the column in the order of the visible columns. Optionally pass a `position` parameter to get the index of the column in a sub-section of the table\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-ordering#getindex)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-ordering)\n   */\n  getIndex: (position?: ColumnPinningPosition | 'center') => number\n  /**\n   * Returns `true` if the column is the first column in the order of the visible columns. Optionally pass a `position` parameter to check if the column is the first in a sub-section of the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-ordering#getisfirstcolumn)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-ordering)\n   */\n  getIsFirstColumn: (position?: ColumnPinningPosition | 'center') => boolean\n  /**\n   * Returns `true` if the column is the last column in the order of the visible columns. Optionally pass a `position` parameter to check if the column is the last in a sub-section of the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-ordering#getislastcolumn)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-ordering)\n   */\n  getIsLastColumn: (position?: ColumnPinningPosition | 'center') => boolean\n}\n\nexport interface ColumnOrderDefaultOptions {\n  onColumnOrderChange: OnChangeFn<ColumnOrderState>\n}\n\nexport interface ColumnOrderInstance<TData extends RowData> {\n  _getOrderColumnsFn: () => (\n    columns: Column<TData, unknown>[]\n  ) => Column<TData, unknown>[]\n  /**\n   * Resets the **columnOrder** state to `initialState.columnOrder`, or `true` can be passed to force a default blank state reset to `[]`.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-ordering#resetcolumnorder)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-ordering)\n   */\n  resetColumnOrder: (defaultState?: boolean) => void\n  /**\n   * Sets or updates the `state.columnOrder` state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-ordering#setcolumnorder)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-ordering)\n   */\n  setColumnOrder: (updater: Updater<ColumnOrderState>) => void\n}\n\n//\n\nexport const ColumnOrdering: TableFeature = {\n  getInitialState: (state): ColumnOrderTableState => {\n    return {\n      columnOrder: [],\n      ...state,\n    }\n  },\n\n  getDefaultOptions: <TData extends RowData>(\n    table: Table<TData>\n  ): ColumnOrderDefaultOptions => {\n    return {\n      onColumnOrderChange: makeStateUpdater('columnOrder', table),\n    }\n  },\n\n  createColumn: <TData extends RowData>(\n    column: Column<TData, unknown>,\n    table: Table<TData>\n  ): void => {\n    column.getIndex = memo(\n      position => [_getVisibleLeafColumns(table, position)],\n      columns => columns.findIndex(d => d.id === column.id),\n      getMemoOptions(table.options, 'debugColumns', 'getIndex')\n    )\n    column.getIsFirstColumn = position => {\n      const columns = _getVisibleLeafColumns(table, position)\n      return columns[0]?.id === column.id\n    }\n    column.getIsLastColumn = position => {\n      const columns = _getVisibleLeafColumns(table, position)\n      return columns[columns.length - 1]?.id === column.id\n    }\n  },\n\n  createTable: <TData extends RowData>(table: Table<TData>): void => {\n    table.setColumnOrder = updater =>\n      table.options.onColumnOrderChange?.(updater)\n    table.resetColumnOrder = defaultState => {\n      table.setColumnOrder(\n        defaultState ? [] : table.initialState.columnOrder ?? []\n      )\n    }\n    table._getOrderColumnsFn = memo(\n      () => [\n        table.getState().columnOrder,\n        table.getState().grouping,\n        table.options.groupedColumnMode,\n      ],\n      (columnOrder, grouping, groupedColumnMode) =>\n        (columns: Column<TData, unknown>[]) => {\n          // Sort grouped columns to the start of the column list\n          // before the headers are built\n          let orderedColumns: Column<TData, unknown>[] = []\n\n          // If there is no order, return the normal columns\n          if (!columnOrder?.length) {\n            orderedColumns = columns\n          } else {\n            const columnOrderCopy = [...columnOrder]\n\n            // If there is an order, make a copy of the columns\n            const columnsCopy = [...columns]\n\n            // And make a new ordered array of the columns\n\n            // Loop over the columns and place them in order into the new array\n            while (columnsCopy.length && columnOrderCopy.length) {\n              const targetColumnId = columnOrderCopy.shift()\n              const foundIndex = columnsCopy.findIndex(\n                d => d.id === targetColumnId\n              )\n              if (foundIndex > -1) {\n                orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]!)\n              }\n            }\n\n            // If there are any columns left, add them to the end\n            orderedColumns = [...orderedColumns, ...columnsCopy]\n          }\n\n          return orderColumns(orderedColumns, grouping, groupedColumnMode)\n        },\n      getMemoOptions(table.options, 'debugTable', '_getOrderColumnsFn')\n    )\n  },\n}\n", "import {\n  OnChangeFn,\n  Updater,\n  Table,\n  Column,\n  Row,\n  Cell,\n  RowData,\n  TableFeature,\n} from '../types'\nimport { getMemoOptions, makeStateUpdater, memo } from '../utils'\n\nexport type ColumnPinningPosition = false | 'left' | 'right'\n\nexport interface ColumnPinningState {\n  left?: string[]\n  right?: string[]\n}\n\nexport interface ColumnPinningTableState {\n  columnPinning: ColumnPinningState\n}\n\nexport interface ColumnPinningOptions {\n  /**\n   * Enables/disables column pinning for the table. Defaults to `true`.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-pinning#enablecolumnpinning)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-pinning)\n   */\n  enableColumnPinning?: boolean\n  /**\n   * @deprecated Use `enableColumnPinning` or `enableRowPinning` instead.\n   * Enables/disables all pinning for the table. Defaults to `true`.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-pinning#enablepinning)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-pinning)\n   */\n  enablePinning?: boolean\n  /**\n   * If provided, this function will be called with an `updaterFn` when `state.columnPinning` changes. This overrides the default internal state management, so you will also need to supply `state.columnPinning` from your own managed state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-pinning#oncolumnpinningchange)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/oncolumnpinningchange)\n   */\n  onColumnPinningChange?: OnChangeFn<ColumnPinningState>\n}\n\nexport interface ColumnPinningDefaultOptions {\n  onColumnPinningChange: OnChangeFn<ColumnPinningState>\n}\n\nexport interface ColumnPinningColumnDef {\n  /**\n   * Enables/disables column pinning for this column. Defaults to `true`.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-pinning#enablepinning-1)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-pinning)\n   */\n  enablePinning?: boolean\n}\n\nexport interface ColumnPinningColumn {\n  /**\n   * Returns whether or not the column can be pinned.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-pinning#getcanpin)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-pinning)\n   */\n  getCanPin: () => boolean\n  /**\n   * Returns the pinned position of the column. (`'left'`, `'right'` or `false`)\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-pinning#getispinned)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-pinning)\n   */\n  getIsPinned: () => ColumnPinningPosition\n  /**\n   * Returns the numeric pinned index of the column within a pinned column group.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-pinning#getpinnedindex)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-pinning)\n   */\n  getPinnedIndex: () => number\n  /**\n   * Pins a column to the `'left'` or `'right'`, or unpins the column to the center if `false` is passed.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-pinning#pin)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-pinning)\n   */\n  pin: (position: ColumnPinningPosition) => void\n}\n\nexport interface ColumnPinningRow<TData extends RowData> {\n  /**\n   * Returns all center pinned (unpinned) leaf cells in the row.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-pinning#getcentervisiblecells)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-pinning)\n   */\n  getCenterVisibleCells: () => Cell<TData, unknown>[]\n  /**\n   * Returns all left pinned leaf cells in the row.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-pinning#getleftvisiblecells)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-pinning)\n   */\n  getLeftVisibleCells: () => Cell<TData, unknown>[]\n  /**\n   * Returns all right pinned leaf cells in the row.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-pinning#getrightvisiblecells)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-pinning)\n   */\n  getRightVisibleCells: () => Cell<TData, unknown>[]\n}\n\nexport interface ColumnPinningInstance<TData extends RowData> {\n  /**\n   * Returns all center pinned (unpinned) leaf columns.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-pinning#getcenterleafcolumns)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-pinning)\n   */\n  getCenterLeafColumns: () => Column<TData, unknown>[]\n  /**\n   * Returns whether or not any columns are pinned. Optionally specify to only check for pinned columns in either the `left` or `right` position.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-pinning#getissomecolumnspinned)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-pinning)\n   */\n  getIsSomeColumnsPinned: (position?: ColumnPinningPosition) => boolean\n  /**\n   * Returns all left pinned leaf columns.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-pinning#getleftleafcolumns)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-pinning)\n   */\n  getLeftLeafColumns: () => Column<TData, unknown>[]\n  /**\n   * Returns all right pinned leaf columns.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-pinning#getrightleafcolumns)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-pinning)\n   */\n  getRightLeafColumns: () => Column<TData, unknown>[]\n  /**\n   * Resets the **columnPinning** state to `initialState.columnPinning`, or `true` can be passed to force a default blank state reset to `{ left: [], right: [], }`.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-pinning#resetcolumnpinning)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-pinning)\n   */\n  resetColumnPinning: (defaultState?: boolean) => void\n  /**\n   * Sets or updates the `state.columnPinning` state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-pinning#setcolumnpinning)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-pinning)\n   */\n  setColumnPinning: (updater: Updater<ColumnPinningState>) => void\n}\n\n//\n\nconst getDefaultColumnPinningState = (): ColumnPinningState => ({\n  left: [],\n  right: [],\n})\n\nexport const ColumnPinning: TableFeature = {\n  getInitialState: (state): ColumnPinningTableState => {\n    return {\n      columnPinning: getDefaultColumnPinningState(),\n      ...state,\n    }\n  },\n\n  getDefaultOptions: <TData extends RowData>(\n    table: Table<TData>\n  ): ColumnPinningDefaultOptions => {\n    return {\n      onColumnPinningChange: makeStateUpdater('columnPinning', table),\n    }\n  },\n\n  createColumn: <TData extends RowData, TValue>(\n    column: Column<TData, TValue>,\n    table: Table<TData>\n  ): void => {\n    column.pin = position => {\n      const columnIds = column\n        .getLeafColumns()\n        .map(d => d.id)\n        .filter(Boolean) as string[]\n\n      table.setColumnPinning(old => {\n        if (position === 'right') {\n          return {\n            left: (old?.left ?? []).filter(d => !columnIds?.includes(d)),\n            right: [\n              ...(old?.right ?? []).filter(d => !columnIds?.includes(d)),\n              ...columnIds,\n            ],\n          }\n        }\n\n        if (position === 'left') {\n          return {\n            left: [\n              ...(old?.left ?? []).filter(d => !columnIds?.includes(d)),\n              ...columnIds,\n            ],\n            right: (old?.right ?? []).filter(d => !columnIds?.includes(d)),\n          }\n        }\n\n        return {\n          left: (old?.left ?? []).filter(d => !columnIds?.includes(d)),\n          right: (old?.right ?? []).filter(d => !columnIds?.includes(d)),\n        }\n      })\n    }\n\n    column.getCanPin = () => {\n      const leafColumns = column.getLeafColumns()\n\n      return leafColumns.some(\n        d =>\n          (d.columnDef.enablePinning ?? true) &&\n          (table.options.enableColumnPinning ??\n            table.options.enablePinning ??\n            true)\n      )\n    }\n\n    column.getIsPinned = () => {\n      const leafColumnIds = column.getLeafColumns().map(d => d.id)\n\n      const { left, right } = table.getState().columnPinning\n\n      const isLeft = leafColumnIds.some(d => left?.includes(d))\n      const isRight = leafColumnIds.some(d => right?.includes(d))\n\n      return isLeft ? 'left' : isRight ? 'right' : false\n    }\n\n    column.getPinnedIndex = () => {\n      const position = column.getIsPinned()\n\n      return position\n        ? table.getState().columnPinning?.[position]?.indexOf(column.id) ?? -1\n        : 0\n    }\n  },\n\n  createRow: <TData extends RowData>(\n    row: Row<TData>,\n    table: Table<TData>\n  ): void => {\n    row.getCenterVisibleCells = memo(\n      () => [\n        row._getAllVisibleCells(),\n        table.getState().columnPinning.left,\n        table.getState().columnPinning.right,\n      ],\n      (allCells, left, right) => {\n        const leftAndRight: string[] = [...(left ?? []), ...(right ?? [])]\n\n        return allCells.filter(d => !leftAndRight.includes(d.column.id))\n      },\n      getMemoOptions(table.options, 'debugRows', 'getCenterVisibleCells')\n    )\n    row.getLeftVisibleCells = memo(\n      () => [row._getAllVisibleCells(), table.getState().columnPinning.left],\n      (allCells, left) => {\n        const cells = (left ?? [])\n          .map(columnId => allCells.find(cell => cell.column.id === columnId)!)\n          .filter(Boolean)\n          .map(d => ({ ...d, position: 'left' }) as Cell<TData, unknown>)\n\n        return cells\n      },\n      getMemoOptions(table.options, 'debugRows', 'getLeftVisibleCells')\n    )\n    row.getRightVisibleCells = memo(\n      () => [row._getAllVisibleCells(), table.getState().columnPinning.right],\n      (allCells, right) => {\n        const cells = (right ?? [])\n          .map(columnId => allCells.find(cell => cell.column.id === columnId)!)\n          .filter(Boolean)\n          .map(d => ({ ...d, position: 'right' }) as Cell<TData, unknown>)\n\n        return cells\n      },\n      getMemoOptions(table.options, 'debugRows', 'getRightVisibleCells')\n    )\n  },\n\n  createTable: <TData extends RowData>(table: Table<TData>): void => {\n    table.setColumnPinning = updater =>\n      table.options.onColumnPinningChange?.(updater)\n\n    table.resetColumnPinning = defaultState =>\n      table.setColumnPinning(\n        defaultState\n          ? getDefaultColumnPinningState()\n          : table.initialState?.columnPinning ?? getDefaultColumnPinningState()\n      )\n\n    table.getIsSomeColumnsPinned = position => {\n      const pinningState = table.getState().columnPinning\n\n      if (!position) {\n        return Boolean(pinningState.left?.length || pinningState.right?.length)\n      }\n      return Boolean(pinningState[position]?.length)\n    }\n\n    table.getLeftLeafColumns = memo(\n      () => [table.getAllLeafColumns(), table.getState().columnPinning.left],\n      (allColumns, left) => {\n        return (left ?? [])\n          .map(columnId => allColumns.find(column => column.id === columnId)!)\n          .filter(Boolean)\n      },\n      getMemoOptions(table.options, 'debugColumns', 'getLeftLeafColumns')\n    )\n\n    table.getRightLeafColumns = memo(\n      () => [table.getAllLeafColumns(), table.getState().columnPinning.right],\n      (allColumns, right) => {\n        return (right ?? [])\n          .map(columnId => allColumns.find(column => column.id === columnId)!)\n          .filter(Boolean)\n      },\n      getMemoOptions(table.options, 'debugColumns', 'getRightLeafColumns')\n    )\n\n    table.getCenterLeafColumns = memo(\n      () => [\n        table.getAllLeafColumns(),\n        table.getState().columnPinning.left,\n        table.getState().columnPinning.right,\n      ],\n      (allColumns, left, right) => {\n        const leftAndRight: string[] = [...(left ?? []), ...(right ?? [])]\n\n        return allColumns.filter(d => !leftAndRight.includes(d.id))\n      },\n      getMemoOptions(table.options, 'debugColumns', 'getCenterLeafColumns')\n    )\n  },\n}\n", "import { _getVisibleLeafColumns } from '..'\nimport {\n  RowData,\n  Column,\n  Header,\n  OnChangeFn,\n  Table,\n  Updater,\n  TableFeature,\n} from '../types'\nimport { getMemoOptions, makeStateUpdater, memo } from '../utils'\nimport { ColumnPinningPosition } from './ColumnPinning'\n\n//\n\nexport interface ColumnSizingTableState {\n  columnSizing: ColumnSizingState\n  columnSizingInfo: ColumnSizingInfoState\n}\n\nexport type ColumnSizingState = Record<string, number>\n\nexport interface ColumnSizingInfoState {\n  columnSizingStart: [string, number][]\n  deltaOffset: null | number\n  deltaPercentage: null | number\n  isResizingColumn: false | string\n  startOffset: null | number\n  startSize: null | number\n}\n\nexport type ColumnResizeMode = 'onChange' | 'onEnd'\n\nexport type ColumnResizeDirection = 'ltr' | 'rtl'\n\nexport interface ColumnSizingOptions {\n  /**\n   * Determines when the columnSizing state is updated. `onChange` updates the state when the user is dragging the resize handle. `onEnd` updates the state when the user releases the resize handle.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#columnresizemode)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  columnResizeMode?: ColumnResizeMode\n  /**\n   * Enables or disables column resizing for the column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#enablecolumnresizing)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  enableColumnResizing?: boolean\n  /**\n   * Enables or disables right-to-left support for resizing the column. defaults to 'ltr'.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#columnResizeDirection)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  columnResizeDirection?: ColumnResizeDirection\n  /**\n   * If provided, this function will be called with an `updaterFn` when `state.columnSizing` changes. This overrides the default internal state management, so you will also need to supply `state.columnSizing` from your own managed state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#oncolumnsizingchange)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  onColumnSizingChange?: OnChangeFn<ColumnSizingState>\n  /**\n   * If provided, this function will be called with an `updaterFn` when `state.columnSizingInfo` changes. This overrides the default internal state management, so you will also need to supply `state.columnSizingInfo` from your own managed state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#oncolumnsizinginfochange)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  onColumnSizingInfoChange?: OnChangeFn<ColumnSizingInfoState>\n}\n\nexport type ColumnSizingDefaultOptions = Pick<\n  ColumnSizingOptions,\n  | 'columnResizeMode'\n  | 'onColumnSizingChange'\n  | 'onColumnSizingInfoChange'\n  | 'columnResizeDirection'\n>\n\nexport interface ColumnSizingInstance {\n  /**\n   * If pinning, returns the total size of the center portion of the table by calculating the sum of the sizes of all unpinned/center leaf-columns.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#getcentertotalsize)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  getCenterTotalSize: () => number\n  /**\n   * Returns the total size of the left portion of the table by calculating the sum of the sizes of all left leaf-columns.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#getlefttotalsize)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  getLeftTotalSize: () => number\n  /**\n   * Returns the total size of the right portion of the table by calculating the sum of the sizes of all right leaf-columns.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#getrighttotalsize)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  getRightTotalSize: () => number\n  /**\n   * Returns the total size of the table by calculating the sum of the sizes of all leaf-columns.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#gettotalsize)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  getTotalSize: () => number\n  /**\n   * Resets column sizing to its initial state. If `defaultState` is `true`, the default state for the table will be used instead of the initialValue provided to the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#resetcolumnsizing)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  resetColumnSizing: (defaultState?: boolean) => void\n  /**\n   * Resets column sizing info to its initial state. If `defaultState` is `true`, the default state for the table will be used instead of the initialValue provided to the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#resetheadersizeinfo)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  resetHeaderSizeInfo: (defaultState?: boolean) => void\n  /**\n   * Sets the column sizing state using an updater function or a value. This will trigger the underlying `onColumnSizingChange` function if one is passed to the table options, otherwise the state will be managed automatically by the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#setcolumnsizing)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  setColumnSizing: (updater: Updater<ColumnSizingState>) => void\n  /**\n   * Sets the column sizing info state using an updater function or a value. This will trigger the underlying `onColumnSizingInfoChange` function if one is passed to the table options, otherwise the state will be managed automatically by the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#setcolumnsizinginfo)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  setColumnSizingInfo: (updater: Updater<ColumnSizingInfoState>) => void\n}\n\nexport interface ColumnSizingColumnDef {\n  /**\n   * Enables or disables column resizing for the column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#enableresizing)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  enableResizing?: boolean\n  /**\n   * The maximum allowed size for the column\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#maxsize)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  maxSize?: number\n  /**\n   * The minimum allowed size for the column\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#minsize)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  minSize?: number\n  /**\n   * The desired size for the column\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#size)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  size?: number\n}\n\nexport interface ColumnSizingColumn {\n  /**\n   * Returns `true` if the column can be resized.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#getcanresize)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  getCanResize: () => boolean\n  /**\n   * Returns `true` if the column is currently being resized.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#getisresizing)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  getIsResizing: () => boolean\n  /**\n   * Returns the current size of the column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#getsize)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  getSize: () => number\n  /**\n   * Returns the offset measurement along the row-axis (usually the x-axis for standard tables) for the header. This is effectively a sum of the offset measurements of all preceding (left) headers in relation to the current column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#getstart)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  getStart: (position?: ColumnPinningPosition | 'center') => number\n  /**\n   * Returns the offset measurement along the row-axis (usually the x-axis for standard tables) for the header. This is effectively a sum of the offset measurements of all succeeding (right) headers in relation to the current column.\n   */\n  getAfter: (position?: ColumnPinningPosition | 'center') => number\n  /**\n   * Resets the column to its initial size.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#resetsize)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  resetSize: () => void\n}\n\nexport interface ColumnSizingHeader {\n  /**\n   * Returns an event handler function that can be used to resize the header. It can be used as an:\n   * - `onMouseDown` handler\n   * - `onTouchStart` handler\n   *\n   * The dragging and release events are automatically handled for you.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#getresizehandler)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  getResizeHandler: (context?: Document) => (event: unknown) => void\n  /**\n   * Returns the current size of the header.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#getsize)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  getSize: () => number\n  /**\n   * Returns the offset measurement along the row-axis (usually the x-axis for standard tables) for the header. This is effectively a sum of the offset measurements of all preceding headers.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-sizing#getstart)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-sizing)\n   */\n  getStart: (position?: ColumnPinningPosition) => number\n}\n\n//\n\nexport const defaultColumnSizing = {\n  size: 150,\n  minSize: 20,\n  maxSize: Number.MAX_SAFE_INTEGER,\n}\n\nconst getDefaultColumnSizingInfoState = (): ColumnSizingInfoState => ({\n  startOffset: null,\n  startSize: null,\n  deltaOffset: null,\n  deltaPercentage: null,\n  isResizingColumn: false,\n  columnSizingStart: [],\n})\n\nexport const ColumnSizing: TableFeature = {\n  getDefaultColumnDef: (): ColumnSizingColumnDef => {\n    return defaultColumnSizing\n  },\n  getInitialState: (state): ColumnSizingTableState => {\n    return {\n      columnSizing: {},\n      columnSizingInfo: getDefaultColumnSizingInfoState(),\n      ...state,\n    }\n  },\n\n  getDefaultOptions: <TData extends RowData>(\n    table: Table<TData>\n  ): ColumnSizingDefaultOptions => {\n    return {\n      columnResizeMode: 'onEnd',\n      columnResizeDirection: 'ltr',\n      onColumnSizingChange: makeStateUpdater('columnSizing', table),\n      onColumnSizingInfoChange: makeStateUpdater('columnSizingInfo', table),\n    }\n  },\n\n  createColumn: <TData extends RowData, TValue>(\n    column: Column<TData, TValue>,\n    table: Table<TData>\n  ): void => {\n    column.getSize = () => {\n      const columnSize = table.getState().columnSizing[column.id]\n\n      return Math.min(\n        Math.max(\n          column.columnDef.minSize ?? defaultColumnSizing.minSize,\n          columnSize ?? column.columnDef.size ?? defaultColumnSizing.size\n        ),\n        column.columnDef.maxSize ?? defaultColumnSizing.maxSize\n      )\n    }\n\n    column.getStart = memo(\n      position => [\n        position,\n        _getVisibleLeafColumns(table, position),\n        table.getState().columnSizing,\n      ],\n      (position, columns) =>\n        columns\n          .slice(0, column.getIndex(position))\n          .reduce((sum, column) => sum + column.getSize(), 0),\n      getMemoOptions(table.options, 'debugColumns', 'getStart')\n    )\n\n    column.getAfter = memo(\n      position => [\n        position,\n        _getVisibleLeafColumns(table, position),\n        table.getState().columnSizing,\n      ],\n      (position, columns) =>\n        columns\n          .slice(column.getIndex(position) + 1)\n          .reduce((sum, column) => sum + column.getSize(), 0),\n      getMemoOptions(table.options, 'debugColumns', 'getAfter')\n    )\n\n    column.resetSize = () => {\n      table.setColumnSizing(({ [column.id]: _, ...rest }) => {\n        return rest\n      })\n    }\n    column.getCanResize = () => {\n      return (\n        (column.columnDef.enableResizing ?? true) &&\n        (table.options.enableColumnResizing ?? true)\n      )\n    }\n    column.getIsResizing = () => {\n      return table.getState().columnSizingInfo.isResizingColumn === column.id\n    }\n  },\n\n  createHeader: <TData extends RowData, TValue>(\n    header: Header<TData, TValue>,\n    table: Table<TData>\n  ): void => {\n    header.getSize = () => {\n      let sum = 0\n\n      const recurse = (header: Header<TData, TValue>) => {\n        if (header.subHeaders.length) {\n          header.subHeaders.forEach(recurse)\n        } else {\n          sum += header.column.getSize() ?? 0\n        }\n      }\n\n      recurse(header)\n\n      return sum\n    }\n    header.getStart = () => {\n      if (header.index > 0) {\n        const prevSiblingHeader = header.headerGroup.headers[header.index - 1]!\n        return prevSiblingHeader.getStart() + prevSiblingHeader.getSize()\n      }\n\n      return 0\n    }\n    header.getResizeHandler = _contextDocument => {\n      const column = table.getColumn(header.column.id)\n      const canResize = column?.getCanResize()\n\n      return (e: unknown) => {\n        if (!column || !canResize) {\n          return\n        }\n\n        ;(e as any).persist?.()\n\n        if (isTouchStartEvent(e)) {\n          // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n          if (e.touches && e.touches.length > 1) {\n            return\n          }\n        }\n\n        const startSize = header.getSize()\n\n        const columnSizingStart: [string, number][] = header\n          ? header.getLeafHeaders().map(d => [d.column.id, d.column.getSize()])\n          : [[column.id, column.getSize()]]\n\n        const clientX = isTouchStartEvent(e)\n          ? Math.round(e.touches[0]!.clientX)\n          : (e as MouseEvent).clientX\n\n        const newColumnSizing: ColumnSizingState = {}\n\n        const updateOffset = (\n          eventType: 'move' | 'end',\n          clientXPos?: number\n        ) => {\n          if (typeof clientXPos !== 'number') {\n            return\n          }\n\n          table.setColumnSizingInfo(old => {\n            const deltaDirection =\n              table.options.columnResizeDirection === 'rtl' ? -1 : 1\n            const deltaOffset =\n              (clientXPos - (old?.startOffset ?? 0)) * deltaDirection\n            const deltaPercentage = Math.max(\n              deltaOffset / (old?.startSize ?? 0),\n              -0.999999\n            )\n\n            old.columnSizingStart.forEach(([columnId, headerSize]) => {\n              newColumnSizing[columnId] =\n                Math.round(\n                  Math.max(headerSize + headerSize * deltaPercentage, 0) * 100\n                ) / 100\n            })\n\n            return {\n              ...old,\n              deltaOffset,\n              deltaPercentage,\n            }\n          })\n\n          if (\n            table.options.columnResizeMode === 'onChange' ||\n            eventType === 'end'\n          ) {\n            table.setColumnSizing(old => ({\n              ...old,\n              ...newColumnSizing,\n            }))\n          }\n        }\n\n        const onMove = (clientXPos?: number) => updateOffset('move', clientXPos)\n\n        const onEnd = (clientXPos?: number) => {\n          updateOffset('end', clientXPos)\n\n          table.setColumnSizingInfo(old => ({\n            ...old,\n            isResizingColumn: false,\n            startOffset: null,\n            startSize: null,\n            deltaOffset: null,\n            deltaPercentage: null,\n            columnSizingStart: [],\n          }))\n        }\n\n        const contextDocument =\n          _contextDocument || typeof document !== 'undefined' ? document : null\n\n        const mouseEvents = {\n          moveHandler: (e: MouseEvent) => onMove(e.clientX),\n          upHandler: (e: MouseEvent) => {\n            contextDocument?.removeEventListener(\n              'mousemove',\n              mouseEvents.moveHandler\n            )\n            contextDocument?.removeEventListener(\n              'mouseup',\n              mouseEvents.upHandler\n            )\n            onEnd(e.clientX)\n          },\n        }\n\n        const touchEvents = {\n          moveHandler: (e: TouchEvent) => {\n            if (e.cancelable) {\n              e.preventDefault()\n              e.stopPropagation()\n            }\n            onMove(e.touches[0]!.clientX)\n            return false\n          },\n          upHandler: (e: TouchEvent) => {\n            contextDocument?.removeEventListener(\n              'touchmove',\n              touchEvents.moveHandler\n            )\n            contextDocument?.removeEventListener(\n              'touchend',\n              touchEvents.upHandler\n            )\n            if (e.cancelable) {\n              e.preventDefault()\n              e.stopPropagation()\n            }\n            onEnd(e.touches[0]?.clientX)\n          },\n        }\n\n        const passiveIfSupported = passiveEventSupported()\n          ? { passive: false }\n          : false\n\n        if (isTouchStartEvent(e)) {\n          contextDocument?.addEventListener(\n            'touchmove',\n            touchEvents.moveHandler,\n            passiveIfSupported\n          )\n          contextDocument?.addEventListener(\n            'touchend',\n            touchEvents.upHandler,\n            passiveIfSupported\n          )\n        } else {\n          contextDocument?.addEventListener(\n            'mousemove',\n            mouseEvents.moveHandler,\n            passiveIfSupported\n          )\n          contextDocument?.addEventListener(\n            'mouseup',\n            mouseEvents.upHandler,\n            passiveIfSupported\n          )\n        }\n\n        table.setColumnSizingInfo(old => ({\n          ...old,\n          startOffset: clientX,\n          startSize,\n          deltaOffset: 0,\n          deltaPercentage: 0,\n          columnSizingStart,\n          isResizingColumn: column.id,\n        }))\n      }\n    }\n  },\n\n  createTable: <TData extends RowData>(table: Table<TData>): void => {\n    table.setColumnSizing = updater =>\n      table.options.onColumnSizingChange?.(updater)\n    table.setColumnSizingInfo = updater =>\n      table.options.onColumnSizingInfoChange?.(updater)\n    table.resetColumnSizing = defaultState => {\n      table.setColumnSizing(\n        defaultState ? {} : table.initialState.columnSizing ?? {}\n      )\n    }\n    table.resetHeaderSizeInfo = defaultState => {\n      table.setColumnSizingInfo(\n        defaultState\n          ? getDefaultColumnSizingInfoState()\n          : table.initialState.columnSizingInfo ??\n              getDefaultColumnSizingInfoState()\n      )\n    }\n    table.getTotalSize = () =>\n      table.getHeaderGroups()[0]?.headers.reduce((sum, header) => {\n        return sum + header.getSize()\n      }, 0) ?? 0\n    table.getLeftTotalSize = () =>\n      table.getLeftHeaderGroups()[0]?.headers.reduce((sum, header) => {\n        return sum + header.getSize()\n      }, 0) ?? 0\n    table.getCenterTotalSize = () =>\n      table.getCenterHeaderGroups()[0]?.headers.reduce((sum, header) => {\n        return sum + header.getSize()\n      }, 0) ?? 0\n    table.getRightTotalSize = () =>\n      table.getRightHeaderGroups()[0]?.headers.reduce((sum, header) => {\n        return sum + header.getSize()\n      }, 0) ?? 0\n  },\n}\n\nlet passiveSupported: boolean | null = null\nexport function passiveEventSupported() {\n  if (typeof passiveSupported === 'boolean') return passiveSupported\n\n  let supported = false\n  try {\n    const options = {\n      get passive() {\n        supported = true\n        return false\n      },\n    }\n\n    const noop = () => {}\n\n    window.addEventListener('test', noop, options)\n    window.removeEventListener('test', noop)\n  } catch (err) {\n    supported = false\n  }\n  passiveSupported = supported\n  return passiveSupported\n}\n\nfunction isTouchStartEvent(e: unknown): e is TouchEvent {\n  return (e as TouchEvent).type === 'touchstart'\n}\n", "import { ColumnPinningPosition } from '..'\nimport {\n  Cell,\n  Column,\n  OnChangeFn,\n  Table,\n  Updater,\n  Row,\n  RowData,\n  TableFeature,\n} from '../types'\nimport { getMemoOptions, makeStateUpdater, memo } from '../utils'\n\nexport type VisibilityState = Record<string, boolean>\n\nexport interface VisibilityTableState {\n  columnVisibility: VisibilityState\n}\n\nexport interface VisibilityOptions {\n  /**\n   * Whether to enable column hiding. Defaults to `true`.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-visibility#enablehiding)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-visibility)\n   */\n  enableHiding?: boolean\n  /**\n   * If provided, this function will be called with an `updaterFn` when `state.columnVisibility` changes. This overrides the default internal state management, so you will need to persist the state change either fully or partially outside of the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-visibility#oncolumnvisibilitychange)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-visibility)\n   */\n  onColumnVisibilityChange?: OnChangeFn<VisibilityState>\n}\n\nexport type VisibilityDefaultOptions = Pick<\n  VisibilityOptions,\n  'onColumnVisibilityChange'\n>\n\nexport interface VisibilityInstance<TData extends RowData> {\n  /**\n   * If column pinning, returns a flat array of leaf-node columns that are visible in the unpinned/center portion of the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-visibility#getcentervisibleleafcolumns)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-visibility)\n   */\n  getCenterVisibleLeafColumns: () => Column<TData, unknown>[]\n  /**\n   * Returns whether all columns are visible\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-visibility#getisallcolumnsvisible)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-visibility)\n   */\n  getIsAllColumnsVisible: () => boolean\n  /**\n   * Returns whether any columns are visible\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-visibility#getissomecolumnsvisible)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-visibility)\n   */\n  getIsSomeColumnsVisible: () => boolean\n  /**\n   * If column pinning, returns a flat array of leaf-node columns that are visible in the left portion of the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-visibility#getleftvisibleleafcolumns)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-visibility)\n   */\n  getLeftVisibleLeafColumns: () => Column<TData, unknown>[]\n  /**\n   * If column pinning, returns a flat array of leaf-node columns that are visible in the right portion of the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-visibility#getrightvisibleleafcolumns)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-visibility)\n   */\n  getRightVisibleLeafColumns: () => Column<TData, unknown>[]\n  /**\n   * Returns a handler for toggling the visibility of all columns, meant to be bound to a `input[type=checkbox]` element.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-visibility#gettoggleallcolumnsvisibilityhandler)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-visibility)\n   */\n  getToggleAllColumnsVisibilityHandler: () => (event: unknown) => void\n  /**\n   * Returns a flat array of columns that are visible, including parent columns.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-visibility#getvisibleflatcolumns)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-visibility)\n   */\n  getVisibleFlatColumns: () => Column<TData, unknown>[]\n  /**\n   * Returns a flat array of leaf-node columns that are visible.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-visibility#getvisibleleafcolumns)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-visibility)\n   */\n  getVisibleLeafColumns: () => Column<TData, unknown>[]\n  /**\n   * Resets the column visibility state to the initial state. If `defaultState` is provided, the state will be reset to `{}`\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-visibility#resetcolumnvisibility)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-visibility)\n   */\n  resetColumnVisibility: (defaultState?: boolean) => void\n  /**\n   * Sets or updates the `state.columnVisibility` state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-visibility#setcolumnvisibility)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-visibility)\n   */\n  setColumnVisibility: (updater: Updater<VisibilityState>) => void\n  /**\n   * Toggles the visibility of all columns.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-visibility#toggleallcolumnsvisible)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-visibility)\n   */\n  toggleAllColumnsVisible: (value?: boolean) => void\n}\n\nexport interface VisibilityColumnDef {\n  enableHiding?: boolean\n}\n\nexport interface VisibilityRow<TData extends RowData> {\n  _getAllVisibleCells: () => Cell<TData, unknown>[]\n  /**\n   * Returns an array of cells that account for column visibility for the row.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-visibility#getvisiblecells)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-visibility)\n   */\n  getVisibleCells: () => Cell<TData, unknown>[]\n}\n\nexport interface VisibilityColumn {\n  /**\n   * Returns whether the column can be hidden\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-visibility#getcanhide)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-visibility)\n   */\n  getCanHide: () => boolean\n  /**\n   * Returns whether the column is visible\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-visibility#getisvisible)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-visibility)\n   */\n  getIsVisible: () => boolean\n  /**\n   * Returns a function that can be used to toggle the column visibility. This function can be used to bind to an event handler to a checkbox.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-visibility#gettogglevisibilityhandler)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-visibility)\n   */\n  getToggleVisibilityHandler: () => (event: unknown) => void\n  /**\n   * Toggles the visibility of the column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/column-visibility#togglevisibility)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/column-visibility)\n   */\n  toggleVisibility: (value?: boolean) => void\n}\n\n//\n\nexport const ColumnVisibility: TableFeature = {\n  getInitialState: (state): VisibilityTableState => {\n    return {\n      columnVisibility: {},\n      ...state,\n    }\n  },\n\n  getDefaultOptions: <TData extends RowData>(\n    table: Table<TData>\n  ): VisibilityDefaultOptions => {\n    return {\n      onColumnVisibilityChange: makeStateUpdater('columnVisibility', table),\n    }\n  },\n\n  createColumn: <TData extends RowData, TValue>(\n    column: Column<TData, TValue>,\n    table: Table<TData>\n  ): void => {\n    column.toggleVisibility = value => {\n      if (column.getCanHide()) {\n        table.setColumnVisibility(old => ({\n          ...old,\n          [column.id]: value ?? !column.getIsVisible(),\n        }))\n      }\n    }\n    column.getIsVisible = () => {\n      const childColumns = column.columns\n      return (\n        (childColumns.length\n          ? childColumns.some(c => c.getIsVisible())\n          : table.getState().columnVisibility?.[column.id]) ?? true\n      )\n    }\n\n    column.getCanHide = () => {\n      return (\n        (column.columnDef.enableHiding ?? true) &&\n        (table.options.enableHiding ?? true)\n      )\n    }\n    column.getToggleVisibilityHandler = () => {\n      return (e: unknown) => {\n        column.toggleVisibility?.(\n          ((e as MouseEvent).target as HTMLInputElement).checked\n        )\n      }\n    }\n  },\n\n  createRow: <TData extends RowData>(\n    row: Row<TData>,\n    table: Table<TData>\n  ): void => {\n    row._getAllVisibleCells = memo(\n      () => [row.getAllCells(), table.getState().columnVisibility],\n      cells => {\n        return cells.filter(cell => cell.column.getIsVisible())\n      },\n      getMemoOptions(table.options, 'debugRows', '_getAllVisibleCells')\n    )\n    row.getVisibleCells = memo(\n      () => [\n        row.getLeftVisibleCells(),\n        row.getCenterVisibleCells(),\n        row.getRightVisibleCells(),\n      ],\n      (left, center, right) => [...left, ...center, ...right],\n      getMemoOptions(table.options, 'debugRows', 'getVisibleCells')\n    )\n  },\n\n  createTable: <TData extends RowData>(table: Table<TData>): void => {\n    const makeVisibleColumnsMethod = (\n      key: string,\n      getColumns: () => Column<TData, unknown>[]\n    ): (() => Column<TData, unknown>[]) => {\n      return memo(\n        () => [\n          getColumns(),\n          getColumns()\n            .filter(d => d.getIsVisible())\n            .map(d => d.id)\n            .join('_'),\n        ],\n        columns => {\n          return columns.filter(d => d.getIsVisible?.())\n        },\n        getMemoOptions(table.options, 'debugColumns', key)\n      )\n    }\n\n    table.getVisibleFlatColumns = makeVisibleColumnsMethod(\n      'getVisibleFlatColumns',\n      () => table.getAllFlatColumns()\n    )\n    table.getVisibleLeafColumns = makeVisibleColumnsMethod(\n      'getVisibleLeafColumns',\n      () => table.getAllLeafColumns()\n    )\n    table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod(\n      'getLeftVisibleLeafColumns',\n      () => table.getLeftLeafColumns()\n    )\n    table.getRightVisibleLeafColumns = makeVisibleColumnsMethod(\n      'getRightVisibleLeafColumns',\n      () => table.getRightLeafColumns()\n    )\n    table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod(\n      'getCenterVisibleLeafColumns',\n      () => table.getCenterLeafColumns()\n    )\n\n    table.setColumnVisibility = updater =>\n      table.options.onColumnVisibilityChange?.(updater)\n\n    table.resetColumnVisibility = defaultState => {\n      table.setColumnVisibility(\n        defaultState ? {} : table.initialState.columnVisibility ?? {}\n      )\n    }\n\n    table.toggleAllColumnsVisible = value => {\n      value = value ?? !table.getIsAllColumnsVisible()\n\n      table.setColumnVisibility(\n        table.getAllLeafColumns().reduce(\n          (obj, column) => ({\n            ...obj,\n            [column.id]: !value ? !column.getCanHide?.() : value,\n          }),\n          {}\n        )\n      )\n    }\n\n    table.getIsAllColumnsVisible = () =>\n      !table.getAllLeafColumns().some(column => !column.getIsVisible?.())\n\n    table.getIsSomeColumnsVisible = () =>\n      table.getAllLeafColumns().some(column => column.getIsVisible?.())\n\n    table.getToggleAllColumnsVisibilityHandler = () => {\n      return (e: unknown) => {\n        table.toggleAllColumnsVisible(\n          ((e as MouseEvent).target as HTMLInputElement)?.checked\n        )\n      }\n    }\n  },\n}\n\nexport function _getVisibleLeafColumns<TData extends RowData>(\n  table: Table<TData>,\n  position?: ColumnPinningPosition | 'center'\n) {\n  return !position\n    ? table.getVisibleLeafColumns()\n    : position === 'center'\n      ? table.getCenterVisibleLeafColumns()\n      : position === 'left'\n        ? table.getLeftVisibleLeafColumns()\n        : table.getRightVisibleLeafColumns()\n}\n", "import { RowModel } from '..'\nimport { Table, RowData, TableFeature } from '../types'\n\nexport interface GlobalFacetingInstance<TData extends RowData> {\n  _getGlobalFacetedMinMaxValues?: () => undefined | [number, number]\n  _getGlobalFacetedRowModel?: () => RowModel<TData>\n  _getGlobalFacetedUniqueValues?: () => Map<any, number>\n  /**\n   * Currently, this function returns the built-in `includesString` filter function. In future releases, it may return more dynamic filter functions based on the nature of the data provided.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/global-faceting#getglobalautofilterfn)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/global-faceting)\n   */\n  getGlobalFacetedMinMaxValues: () => undefined | [number, number]\n  /**\n   * Returns the row model for the table after **global** filtering has been applied.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/global-faceting#getglobalfacetedrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/global-faceting)\n   */\n  getGlobalFacetedRowModel: () => RowModel<TData>\n  /**\n   * Returns the faceted unique values for the global filter.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/global-faceting#getglobalfaceteduniquevalues)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/global-faceting)\n   */\n  getGlobalFacetedUniqueValues: () => Map<any, number>\n}\n\n//\n\nexport const GlobalFaceting: TableFeature = {\n  createTable: <TData extends RowData>(table: Table<TData>): void => {\n    table._getGlobalFacetedRowModel =\n      table.options.getFacetedRowModel &&\n      table.options.getFacetedRowModel(table, '__global__')\n\n    table.getGlobalFacetedRowModel = () => {\n      if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {\n        return table.getPreFilteredRowModel()\n      }\n\n      return table._getGlobalFacetedRowModel()\n    }\n\n    table._getGlobalFacetedUniqueValues =\n      table.options.getFacetedUniqueValues &&\n      table.options.getFacetedUniqueValues(table, '__global__')\n    table.getGlobalFacetedUniqueValues = () => {\n      if (!table._getGlobalFacetedUniqueValues) {\n        return new Map()\n      }\n\n      return table._getGlobalFacetedUniqueValues()\n    }\n\n    table._getGlobalFacetedMinMaxValues =\n      table.options.getFacetedMinMaxValues &&\n      table.options.getFacetedMinMaxValues(table, '__global__')\n    table.getGlobalFacetedMinMaxValues = () => {\n      if (!table._getGlobalFacetedMinMaxValues) {\n        return\n      }\n\n      return table._getGlobalFacetedMinMaxValues()\n    }\n  },\n}\n", "import { FilterFn, FilterFnOption } from '..'\nimport { BuiltInFilterFn, filterFns } from '../filterFns'\nimport {\n  Column,\n  OnChangeFn,\n  Table,\n  Updater,\n  RowData,\n  TableFeature,\n} from '../types'\nimport { isFunction, makeStateUpdater } from '../utils'\n\nexport interface GlobalFilterTableState {\n  globalFilter: any\n}\n\nexport interface GlobalFilterColumnDef {\n  /**\n   * Enables/disables the **global** filter for this column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/global-filtering#enableglobalfilter)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/global-filtering)\n   */\n  enableGlobalFilter?: boolean\n}\n\nexport interface GlobalFilterColumn {\n  /**\n   * Returns whether or not the column can be **globally** filtered. Set to `false` to disable a column from being scanned during global filtering.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/global-filtering#getcanglobalfilter)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/global-filtering)\n   */\n  getCanGlobalFilter: () => boolean\n}\n\nexport interface GlobalFilterOptions<TData extends RowData> {\n  /**\n   * Enables/disables **global** filtering for all columns.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/global-filtering#enableglobalfilter)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/global-filtering)\n   */\n  enableGlobalFilter?: boolean\n  /**\n   * If provided, this function will be called with the column and should return `true` or `false` to indicate whether this column should be used for global filtering.\n   *\n   * This is useful if the column can contain data that is not `string` or `number` (i.e. `undefined`).\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/global-filtering#getcolumncanglobalfilter)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/global-filtering)\n   */\n  getColumnCanGlobalFilter?: (column: Column<TData, unknown>) => boolean\n  /**\n   * The filter function to use for global filtering.\n   * - A `string` referencing a built-in filter function\n   * - A `string` that references a custom filter functions provided via the `tableOptions.filterFns` option\n   * - A custom filter function\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/global-filtering#globalfilterfn)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/global-filtering)\n   */\n  globalFilterFn?: FilterFnOption<TData>\n  /**\n   * If provided, this function will be called with an `updaterFn` when `state.globalFilter` changes. This overrides the default internal state management, so you will need to persist the state change either fully or partially outside of the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/global-filtering#onglobalfilterchange)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/global-filtering)\n   */\n  onGlobalFilterChange?: OnChangeFn<any>\n}\n\nexport interface GlobalFilterInstance<TData extends RowData> {\n  /**\n   * Currently, this function returns the built-in `includesString` filter function. In future releases, it may return more dynamic filter functions based on the nature of the data provided.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/global-filtering#getglobalautofilterfn)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/global-filtering)\n   */\n  getGlobalAutoFilterFn: () => FilterFn<TData> | undefined\n  /**\n   * Returns the filter function (either user-defined or automatic, depending on configuration) for the global filter.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/global-filtering#getglobalfilterfn)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/global-filtering)\n   */\n  getGlobalFilterFn: () => FilterFn<TData> | undefined\n  /**\n   * Resets the **globalFilter** state to `initialState.globalFilter`, or `true` can be passed to force a default blank state reset to `undefined`.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/global-filtering#resetglobalfilter)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/global-filtering)\n   */\n  resetGlobalFilter: (defaultState?: boolean) => void\n  /**\n   * Sets or updates the `state.globalFilter` state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/global-filtering#setglobalfilter)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/global-filtering)\n   */\n  setGlobalFilter: (updater: Updater<any>) => void\n}\n\n//\n\nexport const GlobalFiltering: TableFeature = {\n  getInitialState: (state): GlobalFilterTableState => {\n    return {\n      globalFilter: undefined,\n      ...state,\n    }\n  },\n\n  getDefaultOptions: <TData extends RowData>(\n    table: Table<TData>\n  ): GlobalFilterOptions<TData> => {\n    return {\n      onGlobalFilterChange: makeStateUpdater('globalFilter', table),\n      globalFilterFn: 'auto',\n      getColumnCanGlobalFilter: column => {\n        const value = table\n          .getCoreRowModel()\n          .flatRows[0]?._getAllCellsByColumnId()\n          [column.id]?.getValue()\n\n        return typeof value === 'string' || typeof value === 'number'\n      },\n    } as GlobalFilterOptions<TData>\n  },\n\n  createColumn: <TData extends RowData>(\n    column: Column<TData, unknown>,\n    table: Table<TData>\n  ): void => {\n    column.getCanGlobalFilter = () => {\n      return (\n        (column.columnDef.enableGlobalFilter ?? true) &&\n        (table.options.enableGlobalFilter ?? true) &&\n        (table.options.enableFilters ?? true) &&\n        (table.options.getColumnCanGlobalFilter?.(column) ?? true) &&\n        !!column.accessorFn\n      )\n    }\n  },\n\n  createTable: <TData extends RowData>(table: Table<TData>): void => {\n    table.getGlobalAutoFilterFn = () => {\n      return filterFns.includesString\n    }\n\n    table.getGlobalFilterFn = () => {\n      const { globalFilterFn: globalFilterFn } = table.options\n\n      return isFunction(globalFilterFn)\n        ? globalFilterFn\n        : globalFilterFn === 'auto'\n          ? table.getGlobalAutoFilterFn()\n          : table.options.filterFns?.[globalFilterFn as string] ??\n            filterFns[globalFilterFn as BuiltInFilterFn]\n    }\n\n    table.setGlobalFilter = updater => {\n      table.options.onGlobalFilterChange?.(updater)\n    }\n\n    table.resetGlobalFilter = defaultState => {\n      table.setGlobalFilter(\n        defaultState ? undefined : table.initialState.globalFilter\n      )\n    }\n  },\n}\n", "import { RowModel } from '..'\nimport {\n  OnChangeFn,\n  Table,\n  Row,\n  Updater,\n  RowData,\n  TableFeature,\n} from '../types'\nimport { makeStateUpdater } from '../utils'\n\nexport type ExpandedStateList = Record<string, boolean>\nexport type ExpandedState = true | Record<string, boolean>\nexport interface ExpandedTableState {\n  expanded: ExpandedState\n}\n\nexport interface ExpandedRow {\n  /**\n   * Returns whether the row can be expanded.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#getcanexpand)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  getCanExpand: () => boolean\n  /**\n   * Returns whether all parent rows of the row are expanded.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#getisallparentsexpanded)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  getIsAllParentsExpanded: () => boolean\n  /**\n   * Returns whether the row is expanded.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#getisexpanded)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  getIsExpanded: () => boolean\n  /**\n   * Returns a function that can be used to toggle the expanded state of the row. This function can be used to bind to an event handler to a button.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#gettoggleexpandedhandler)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  getToggleExpandedHandler: () => () => void\n  /**\n   * Toggles the expanded state (or sets it if `expanded` is provided) for the row.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#toggleexpanded)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  toggleExpanded: (expanded?: boolean) => void\n}\n\nexport interface ExpandedOptions<TData extends RowData> {\n  /**\n   * Enable this setting to automatically reset the expanded state of the table when expanding state changes.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#autoresetexpanded)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  autoResetExpanded?: boolean\n  /**\n   * Enable/disable expanding for all rows.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#enableexpanding)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  enableExpanding?: boolean\n  /**\n   * This function is responsible for returning the expanded row model. If this function is not provided, the table will not expand rows. You can use the default exported `getExpandedRowModel` function to get the expanded row model or implement your own.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#getexpandedrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  getExpandedRowModel?: (table: Table<any>) => () => RowModel<any>\n  /**\n   * If provided, allows you to override the default behavior of determining whether a row is currently expanded.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#getisrowexpanded)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  getIsRowExpanded?: (row: Row<TData>) => boolean\n  /**\n   * If provided, allows you to override the default behavior of determining whether a row can be expanded.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#getrowcanexpand)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  getRowCanExpand?: (row: Row<TData>) => boolean\n  /**\n   * Enables manual row expansion. If this is set to `true`, `getExpandedRowModel` will not be used to expand rows and you would be expected to perform the expansion in your own data model. This is useful if you are doing server-side expansion.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#manualexpanding)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  manualExpanding?: boolean\n  /**\n   * This function is called when the `expanded` table state changes. If a function is provided, you will be responsible for managing this state on your own. To pass the managed state back to the table, use the `tableOptions.state.expanded` option.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#onexpandedchange)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  onExpandedChange?: OnChangeFn<ExpandedState>\n  /**\n   * If `true` expanded rows will be paginated along with the rest of the table (which means expanded rows may span multiple pages). If `false` expanded rows will not be considered for pagination (which means expanded rows will always render on their parents page. This also means more rows will be rendered than the set page size)\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#paginateexpandedrows)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  paginateExpandedRows?: boolean\n}\n\nexport interface ExpandedInstance<TData extends RowData> {\n  _autoResetExpanded: () => void\n  _getExpandedRowModel?: () => RowModel<TData>\n  /**\n   * Returns whether there are any rows that can be expanded.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#getcansomerowsexpand)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  getCanSomeRowsExpand: () => boolean\n  /**\n   * Returns the maximum depth of the expanded rows.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#getexpandeddepth)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  getExpandedDepth: () => number\n  /**\n   * Returns the row model after expansion has been applied.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#getexpandedrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  getExpandedRowModel: () => RowModel<TData>\n  /**\n   * Returns whether all rows are currently expanded.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#getisallrowsexpanded)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  getIsAllRowsExpanded: () => boolean\n  /**\n   * Returns whether there are any rows that are currently expanded.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#getissomerowsexpanded)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  getIsSomeRowsExpanded: () => boolean\n  /**\n   * Returns the row model before expansion has been applied.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#getpreexpandedrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  getPreExpandedRowModel: () => RowModel<TData>\n  /**\n   * Returns a handler that can be used to toggle the expanded state of all rows. This handler is meant to be used with an `input[type=checkbox]` element.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#gettoggleallrowsexpandedhandler)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  getToggleAllRowsExpandedHandler: () => (event: unknown) => void\n  /**\n   * Resets the expanded state of the table to the initial state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#resetexpanded)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  resetExpanded: (defaultState?: boolean) => void\n  /**\n   * Updates the expanded state of the table via an update function or value.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#setexpanded)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  setExpanded: (updater: Updater<ExpandedState>) => void\n  /**\n   * Toggles the expanded state for all rows.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/expanding#toggleallrowsexpanded)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/expanding)\n   */\n  toggleAllRowsExpanded: (expanded?: boolean) => void\n}\n\n//\n\nexport const RowExpanding: TableFeature = {\n  getInitialState: (state): ExpandedTableState => {\n    return {\n      expanded: {},\n      ...state,\n    }\n  },\n\n  getDefaultOptions: <TData extends RowData>(\n    table: Table<TData>\n  ): ExpandedOptions<TData> => {\n    return {\n      onExpandedChange: makeStateUpdater('expanded', table),\n      paginateExpandedRows: true,\n    }\n  },\n\n  createTable: <TData extends RowData>(table: Table<TData>): void => {\n    let registered = false\n    let queued = false\n\n    table._autoResetExpanded = () => {\n      if (!registered) {\n        table._queue(() => {\n          registered = true\n        })\n        return\n      }\n\n      if (\n        table.options.autoResetAll ??\n        table.options.autoResetExpanded ??\n        !table.options.manualExpanding\n      ) {\n        if (queued) return\n        queued = true\n        table._queue(() => {\n          table.resetExpanded()\n          queued = false\n        })\n      }\n    }\n    table.setExpanded = updater => table.options.onExpandedChange?.(updater)\n    table.toggleAllRowsExpanded = expanded => {\n      if (expanded ?? !table.getIsAllRowsExpanded()) {\n        table.setExpanded(true)\n      } else {\n        table.setExpanded({})\n      }\n    }\n    table.resetExpanded = defaultState => {\n      table.setExpanded(defaultState ? {} : table.initialState?.expanded ?? {})\n    }\n    table.getCanSomeRowsExpand = () => {\n      return table\n        .getPrePaginationRowModel()\n        .flatRows.some(row => row.getCanExpand())\n    }\n    table.getToggleAllRowsExpandedHandler = () => {\n      return (e: unknown) => {\n        ;(e as any).persist?.()\n        table.toggleAllRowsExpanded()\n      }\n    }\n    table.getIsSomeRowsExpanded = () => {\n      const expanded = table.getState().expanded\n      return expanded === true || Object.values(expanded).some(Boolean)\n    }\n    table.getIsAllRowsExpanded = () => {\n      const expanded = table.getState().expanded\n\n      // If expanded is true, save some cycles and return true\n      if (typeof expanded === 'boolean') {\n        return expanded === true\n      }\n\n      if (!Object.keys(expanded).length) {\n        return false\n      }\n\n      // If any row is not expanded, return false\n      if (table.getRowModel().flatRows.some(row => !row.getIsExpanded())) {\n        return false\n      }\n\n      // They must all be expanded :shrug:\n      return true\n    }\n    table.getExpandedDepth = () => {\n      let maxDepth = 0\n\n      const rowIds =\n        table.getState().expanded === true\n          ? Object.keys(table.getRowModel().rowsById)\n          : Object.keys(table.getState().expanded)\n\n      rowIds.forEach(id => {\n        const splitId = id.split('.')\n        maxDepth = Math.max(maxDepth, splitId.length)\n      })\n\n      return maxDepth\n    }\n    table.getPreExpandedRowModel = () => table.getSortedRowModel()\n    table.getExpandedRowModel = () => {\n      if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {\n        table._getExpandedRowModel = table.options.getExpandedRowModel(table)\n      }\n\n      if (table.options.manualExpanding || !table._getExpandedRowModel) {\n        return table.getPreExpandedRowModel()\n      }\n\n      return table._getExpandedRowModel()\n    }\n  },\n\n  createRow: <TData extends RowData>(\n    row: Row<TData>,\n    table: Table<TData>\n  ): void => {\n    row.toggleExpanded = expanded => {\n      table.setExpanded(old => {\n        const exists = old === true ? true : !!old?.[row.id]\n\n        let oldExpanded: ExpandedStateList = {}\n\n        if (old === true) {\n          Object.keys(table.getRowModel().rowsById).forEach(rowId => {\n            oldExpanded[rowId] = true\n          })\n        } else {\n          oldExpanded = old\n        }\n\n        expanded = expanded ?? !exists\n\n        if (!exists && expanded) {\n          return {\n            ...oldExpanded,\n            [row.id]: true,\n          }\n        }\n\n        if (exists && !expanded) {\n          const { [row.id]: _, ...rest } = oldExpanded\n          return rest\n        }\n\n        return old\n      })\n    }\n    row.getIsExpanded = () => {\n      const expanded = table.getState().expanded\n\n      return !!(\n        table.options.getIsRowExpanded?.(row) ??\n        (expanded === true || expanded?.[row.id])\n      )\n    }\n    row.getCanExpand = () => {\n      return (\n        table.options.getRowCanExpand?.(row) ??\n        ((table.options.enableExpanding ?? true) && !!row.subRows?.length)\n      )\n    }\n    row.getIsAllParentsExpanded = () => {\n      let isFullyExpanded = true\n      let currentRow = row\n\n      while (isFullyExpanded && currentRow.parentId) {\n        currentRow = table.getRow(currentRow.parentId, true)\n        isFullyExpanded = currentRow.getIsExpanded()\n      }\n\n      return isFullyExpanded\n    }\n    row.getToggleExpandedHandler = () => {\n      const canExpand = row.getCanExpand()\n\n      return () => {\n        if (!canExpand) return\n        row.toggleExpanded()\n      }\n    }\n  },\n}\n", "import {\n  OnChangeFn,\n  Table,\n  RowModel,\n  Updater,\n  RowData,\n  TableFeature,\n} from '../types'\nimport {\n  functionalUpdate,\n  getMemoOptions,\n  makeStateUpdater,\n  memo,\n} from '../utils'\n\nexport interface PaginationState {\n  pageIndex: number\n  pageSize: number\n}\n\nexport interface PaginationTableState {\n  pagination: PaginationState\n}\n\nexport interface PaginationInitialTableState {\n  pagination?: Partial<PaginationState>\n}\n\nexport interface PaginationOptions {\n  /**\n   * If set to `true`, pagination will be reset to the first page when page-altering state changes eg. `data` is updated, filters change, grouping changes, etc.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#autoresetpageindex)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  autoResetPageIndex?: boolean\n  /**\n   * Returns the row model after pagination has taken place, but no further.\n   *\n   * Pagination columns are automatically reordered by default to the start of the columns list. If you would rather remove them or leave them as-is, set the appropriate mode here.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#getpaginationrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  getPaginationRowModel?: (table: Table<any>) => () => RowModel<any>\n  /**\n   * Enables manual pagination. If this option is set to `true`, the table will not automatically paginate rows using `getPaginationRowModel()` and instead will expect you to manually paginate the rows before passing them to the table. This is useful if you are doing server-side pagination and aggregation.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#manualpagination)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  manualPagination?: boolean\n  /**\n   * If this function is provided, it will be called when the pagination state changes and you will be expected to manage the state yourself. You can pass the managed state back to the table via the `tableOptions.state.pagination` option.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#onpaginationchange)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  onPaginationChange?: OnChangeFn<PaginationState>\n  /**\n   * When manually controlling pagination, you can supply a total `pageCount` value to the table if you know it (Or supply a `rowCount` and `pageCount` will be calculated). If you do not know how many pages there are, you can set this to `-1`.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#pagecount)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  pageCount?: number\n  /**\n   * When manually controlling pagination, you can supply a total `rowCount` value to the table if you know it. The `pageCount` can be calculated from this value and the `pageSize`.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#rowcount)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  rowCount?: number\n}\n\nexport interface PaginationDefaultOptions {\n  onPaginationChange: OnChangeFn<PaginationState>\n}\n\nexport interface PaginationInstance<TData extends RowData> {\n  _autoResetPageIndex: () => void\n  _getPaginationRowModel?: () => RowModel<TData>\n  /**\n   * Returns whether the table can go to the next page.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#getcannextpage)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  getCanNextPage: () => boolean\n  /**\n   * Returns whether the table can go to the previous page.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#getcanpreviouspage)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  getCanPreviousPage: () => boolean\n  /**\n   * Returns the page count. If manually paginating or controlling the pagination state, this will come directly from the `options.pageCount` table option, otherwise it will be calculated from the table data using the total row count and current page size.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#getpagecount)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  getPageCount: () => number\n  /**\n   * Returns the row count. If manually paginating or controlling the pagination state, this will come directly from the `options.rowCount` table option, otherwise it will be calculated from the table data.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#getrowcount)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  getRowCount: () => number\n  /**\n   * Returns an array of page options (zero-index-based) for the current page size.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#getpageoptions)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  getPageOptions: () => number[]\n  /**\n   * Returns the row model for the table after pagination has been applied.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#getpaginationrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  getPaginationRowModel: () => RowModel<TData>\n  /**\n   * Returns the row model for the table before any pagination has been applied.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#getprepaginationrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  getPrePaginationRowModel: () => RowModel<TData>\n  /**\n   * Increments the page index by one, if possible.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#nextpage)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  nextPage: () => void\n  /**\n   * Decrements the page index by one, if possible.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#previouspage)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  previousPage: () => void\n  /**\n   * Sets the page index to `0`.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#firstpage)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  firstPage: () => void\n  /**\n   * Sets the page index to the last page.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#lastpage)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  lastPage: () => void\n  /**\n   * Resets the page index to its initial state. If `defaultState` is `true`, the page index will be reset to `0` regardless of initial state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#resetpageindex)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  resetPageIndex: (defaultState?: boolean) => void\n  /**\n   * Resets the page size to its initial state. If `defaultState` is `true`, the page size will be reset to `10` regardless of initial state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#resetpagesize)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  resetPageSize: (defaultState?: boolean) => void\n  /**\n   * Resets the **pagination** state to `initialState.pagination`, or `true` can be passed to force a default blank state reset to `[]`.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#resetpagination)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  resetPagination: (defaultState?: boolean) => void\n  /**\n   * @deprecated The page count no longer exists in the pagination state. Just pass as a table option instead.\n   */\n  setPageCount: (updater: Updater<number>) => void\n  /**\n   * Updates the page index using the provided function or value in the `state.pagination.pageIndex` state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#setpageindex)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  setPageIndex: (updater: Updater<number>) => void\n  /**\n   * Updates the page size using the provided function or value in the `state.pagination.pageSize` state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#setpagesize)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  setPageSize: (updater: Updater<number>) => void\n  /**\n   * Sets or updates the `state.pagination` state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/pagination#setpagination)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/pagination)\n   */\n  setPagination: (updater: Updater<PaginationState>) => void\n}\n\n//\n\nconst defaultPageIndex = 0\nconst defaultPageSize = 10\n\nconst getDefaultPaginationState = (): PaginationState => ({\n  pageIndex: defaultPageIndex,\n  pageSize: defaultPageSize,\n})\n\nexport const RowPagination: TableFeature = {\n  getInitialState: (state): PaginationTableState => {\n    return {\n      ...state,\n      pagination: {\n        ...getDefaultPaginationState(),\n        ...state?.pagination,\n      },\n    }\n  },\n\n  getDefaultOptions: <TData extends RowData>(\n    table: Table<TData>\n  ): PaginationDefaultOptions => {\n    return {\n      onPaginationChange: makeStateUpdater('pagination', table),\n    }\n  },\n\n  createTable: <TData extends RowData>(table: Table<TData>): void => {\n    let registered = false\n    let queued = false\n\n    table._autoResetPageIndex = () => {\n      if (!registered) {\n        table._queue(() => {\n          registered = true\n        })\n        return\n      }\n\n      if (\n        table.options.autoResetAll ??\n        table.options.autoResetPageIndex ??\n        !table.options.manualPagination\n      ) {\n        if (queued) return\n        queued = true\n        table._queue(() => {\n          table.resetPageIndex()\n          queued = false\n        })\n      }\n    }\n    table.setPagination = updater => {\n      const safeUpdater: Updater<PaginationState> = old => {\n        let newState = functionalUpdate(updater, old)\n\n        return newState\n      }\n\n      return table.options.onPaginationChange?.(safeUpdater)\n    }\n    table.resetPagination = defaultState => {\n      table.setPagination(\n        defaultState\n          ? getDefaultPaginationState()\n          : table.initialState.pagination ?? getDefaultPaginationState()\n      )\n    }\n    table.setPageIndex = updater => {\n      table.setPagination(old => {\n        let pageIndex = functionalUpdate(updater, old.pageIndex)\n\n        const maxPageIndex =\n          typeof table.options.pageCount === 'undefined' ||\n          table.options.pageCount === -1\n            ? Number.MAX_SAFE_INTEGER\n            : table.options.pageCount - 1\n\n        pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex))\n\n        return {\n          ...old,\n          pageIndex,\n        }\n      })\n    }\n    table.resetPageIndex = defaultState => {\n      table.setPageIndex(\n        defaultState\n          ? defaultPageIndex\n          : table.initialState?.pagination?.pageIndex ?? defaultPageIndex\n      )\n    }\n    table.resetPageSize = defaultState => {\n      table.setPageSize(\n        defaultState\n          ? defaultPageSize\n          : table.initialState?.pagination?.pageSize ?? defaultPageSize\n      )\n    }\n    table.setPageSize = updater => {\n      table.setPagination(old => {\n        const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize))\n        const topRowIndex = old.pageSize * old.pageIndex!\n        const pageIndex = Math.floor(topRowIndex / pageSize)\n\n        return {\n          ...old,\n          pageIndex,\n          pageSize,\n        }\n      })\n    }\n    //deprecated\n    table.setPageCount = updater =>\n      table.setPagination(old => {\n        let newPageCount = functionalUpdate(\n          updater,\n          table.options.pageCount ?? -1\n        )\n\n        if (typeof newPageCount === 'number') {\n          newPageCount = Math.max(-1, newPageCount)\n        }\n\n        return {\n          ...old,\n          pageCount: newPageCount,\n        }\n      })\n\n    table.getPageOptions = memo(\n      () => [table.getPageCount()],\n      pageCount => {\n        let pageOptions: number[] = []\n        if (pageCount && pageCount > 0) {\n          pageOptions = [...new Array(pageCount)].fill(null).map((_, i) => i)\n        }\n        return pageOptions\n      },\n      getMemoOptions(table.options, 'debugTable', 'getPageOptions')\n    )\n\n    table.getCanPreviousPage = () => table.getState().pagination.pageIndex > 0\n\n    table.getCanNextPage = () => {\n      const { pageIndex } = table.getState().pagination\n\n      const pageCount = table.getPageCount()\n\n      if (pageCount === -1) {\n        return true\n      }\n\n      if (pageCount === 0) {\n        return false\n      }\n\n      return pageIndex < pageCount - 1\n    }\n\n    table.previousPage = () => {\n      return table.setPageIndex(old => old - 1)\n    }\n\n    table.nextPage = () => {\n      return table.setPageIndex(old => {\n        return old + 1\n      })\n    }\n\n    table.firstPage = () => {\n      return table.setPageIndex(0)\n    }\n\n    table.lastPage = () => {\n      return table.setPageIndex(table.getPageCount() - 1)\n    }\n\n    table.getPrePaginationRowModel = () => table.getExpandedRowModel()\n    table.getPaginationRowModel = () => {\n      if (\n        !table._getPaginationRowModel &&\n        table.options.getPaginationRowModel\n      ) {\n        table._getPaginationRowModel =\n          table.options.getPaginationRowModel(table)\n      }\n\n      if (table.options.manualPagination || !table._getPaginationRowModel) {\n        return table.getPrePaginationRowModel()\n      }\n\n      return table._getPaginationRowModel()\n    }\n\n    table.getPageCount = () => {\n      return (\n        table.options.pageCount ??\n        Math.ceil(table.getRowCount() / table.getState().pagination.pageSize)\n      )\n    }\n\n    table.getRowCount = () => {\n      return (\n        table.options.rowCount ?? table.getPrePaginationRowModel().rows.length\n      )\n    }\n  },\n}\n", "import {\n  OnChangeFn,\n  Updater,\n  Table,\n  Row,\n  RowData,\n  TableFeature,\n} from '../types'\nimport { getMemoOptions, makeStateUpdater, memo } from '../utils'\n\nexport type RowPinningPosition = false | 'top' | 'bottom'\n\nexport interface RowPinningState {\n  bottom?: string[]\n  top?: string[]\n}\n\nexport interface RowPinningTableState {\n  rowPinning: RowPinningState\n}\n\nexport interface RowPinningOptions<TData extends RowData> {\n  /**\n   * Enables/disables row pinning for the table. Defaults to `true`.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-pinning#enablerowpinning)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-pinning)\n   */\n  enableRowPinning?: boolean | ((row: Row<TData>) => boolean)\n  /**\n   * When `false`, pinned rows will not be visible if they are filtered or paginated out of the table. When `true`, pinned rows will always be visible regardless of filtering or pagination. Defaults to `true`.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-pinning#keeppinnedrows)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-pinning)\n   */\n  keepPinnedRows?: boolean\n  /**\n   * If provided, this function will be called with an `updaterFn` when `state.rowPinning` changes. This overrides the default internal state management, so you will also need to supply `state.rowPinning` from your own managed state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-pinning#onrowpinningchange)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/onrowpinningchange)\n   */\n  onRowPinningChange?: OnChangeFn<RowPinningState>\n}\n\nexport interface RowPinningDefaultOptions {\n  onRowPinningChange: OnChangeFn<RowPinningState>\n}\n\nexport interface RowPinningRow {\n  /**\n   * Returns whether or not the row can be pinned.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-pinning#getcanpin-1)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-pinning)\n   */\n  getCanPin: () => boolean\n  /**\n   * Returns the pinned position of the row. (`'top'`, `'bottom'` or `false`)\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-pinning#getispinned-1)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-pinning)\n   */\n  getIsPinned: () => RowPinningPosition\n  /**\n   * Returns the numeric pinned index of the row within a pinned row group.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-pinning#getpinnedindex-1)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-pinning)\n   */\n  getPinnedIndex: () => number\n  /**\n   * Pins a row to the `'top'` or `'bottom'`, or unpins the row to the center if `false` is passed.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-pinning#pin-1)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-pinning)\n   */\n  pin: (\n    position: RowPinningPosition,\n    includeLeafRows?: boolean,\n    includeParentRows?: boolean\n  ) => void\n}\n\nexport interface RowPinningInstance<TData extends RowData> {\n  _getPinnedRows: (\n    visiblePinnedRows: Array<Row<TData>>,\n    pinnedRowIds: Array<string> | undefined,\n    position: 'top' | 'bottom'\n  ) => Row<TData>[]\n  /**\n   * Returns all bottom pinned rows.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-pinning#getbottomrows)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-pinning)\n   */\n  getBottomRows: () => Row<TData>[]\n  /**\n   * Returns all rows that are not pinned to the top or bottom.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-pinning#getcenterrows)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-pinning)\n   */\n  getCenterRows: () => Row<TData>[]\n  /**\n   * Returns whether or not any rows are pinned. Optionally specify to only check for pinned rows in either the `top` or `bottom` position.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-pinning#getissomerowspinned)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-pinning)\n   */\n  getIsSomeRowsPinned: (position?: RowPinningPosition) => boolean\n  /**\n   * Returns all top pinned rows.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-pinning#gettoprows)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-pinning)\n   */\n  getTopRows: () => Row<TData>[]\n  /**\n   * Resets the **rowPinning** state to `initialState.rowPinning`, or `true` can be passed to force a default blank state reset to `{ top: [], bottom: [], }`.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-pinning#resetrowpinning)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-pinning)\n   */\n  resetRowPinning: (defaultState?: boolean) => void\n  /**\n   * Sets or updates the `state.rowPinning` state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-pinning#setrowpinning)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-pinning)\n   */\n  setRowPinning: (updater: Updater<RowPinningState>) => void\n}\n\n//\n\nconst getDefaultRowPinningState = (): RowPinningState => ({\n  top: [],\n  bottom: [],\n})\n\nexport const RowPinning: TableFeature = {\n  getInitialState: (state): RowPinningTableState => {\n    return {\n      rowPinning: getDefaultRowPinningState(),\n      ...state,\n    }\n  },\n\n  getDefaultOptions: <TData extends RowData>(\n    table: Table<TData>\n  ): RowPinningDefaultOptions => {\n    return {\n      onRowPinningChange: makeStateUpdater('rowPinning', table),\n    }\n  },\n\n  createRow: <TData extends RowData>(\n    row: Row<TData>,\n    table: Table<TData>\n  ): void => {\n    row.pin = (position, includeLeafRows, includeParentRows) => {\n      const leafRowIds = includeLeafRows\n        ? row.getLeafRows().map(({ id }) => id)\n        : []\n      const parentRowIds = includeParentRows\n        ? row.getParentRows().map(({ id }) => id)\n        : []\n      const rowIds = new Set([...parentRowIds, row.id, ...leafRowIds])\n\n      table.setRowPinning(old => {\n        if (position === 'bottom') {\n          return {\n            top: (old?.top ?? []).filter(d => !rowIds?.has(d)),\n            bottom: [\n              ...(old?.bottom ?? []).filter(d => !rowIds?.has(d)),\n              ...Array.from(rowIds),\n            ],\n          }\n        }\n\n        if (position === 'top') {\n          return {\n            top: [\n              ...(old?.top ?? []).filter(d => !rowIds?.has(d)),\n              ...Array.from(rowIds),\n            ],\n            bottom: (old?.bottom ?? []).filter(d => !rowIds?.has(d)),\n          }\n        }\n\n        return {\n          top: (old?.top ?? []).filter(d => !rowIds?.has(d)),\n          bottom: (old?.bottom ?? []).filter(d => !rowIds?.has(d)),\n        }\n      })\n    }\n    row.getCanPin = () => {\n      const { enableRowPinning, enablePinning } = table.options\n      if (typeof enableRowPinning === 'function') {\n        return enableRowPinning(row)\n      }\n      return enableRowPinning ?? enablePinning ?? true\n    }\n    row.getIsPinned = () => {\n      const rowIds = [row.id]\n\n      const { top, bottom } = table.getState().rowPinning\n\n      const isTop = rowIds.some(d => top?.includes(d))\n      const isBottom = rowIds.some(d => bottom?.includes(d))\n\n      return isTop ? 'top' : isBottom ? 'bottom' : false\n    }\n    row.getPinnedIndex = () => {\n      const position = row.getIsPinned()\n      if (!position) return -1\n\n      const visiblePinnedRowIds = (\n        position === 'top' ? table.getTopRows() : table.getBottomRows()\n      )?.map(({ id }) => id)\n\n      return visiblePinnedRowIds?.indexOf(row.id) ?? -1\n    }\n  },\n\n  createTable: <TData extends RowData>(table: Table<TData>): void => {\n    table.setRowPinning = updater => table.options.onRowPinningChange?.(updater)\n\n    table.resetRowPinning = defaultState =>\n      table.setRowPinning(\n        defaultState\n          ? getDefaultRowPinningState()\n          : table.initialState?.rowPinning ?? getDefaultRowPinningState()\n      )\n\n    table.getIsSomeRowsPinned = position => {\n      const pinningState = table.getState().rowPinning\n\n      if (!position) {\n        return Boolean(pinningState.top?.length || pinningState.bottom?.length)\n      }\n      return Boolean(pinningState[position]?.length)\n    }\n\n    table._getPinnedRows = (visibleRows, pinnedRowIds, position) => {\n      const rows =\n        table.options.keepPinnedRows ?? true\n          ? //get all rows that are pinned even if they would not be otherwise visible\n            //account for expanded parent rows, but not pagination or filtering\n            (pinnedRowIds ?? []).map(rowId => {\n              const row = table.getRow(rowId, true)\n              return row.getIsAllParentsExpanded() ? row : null\n            })\n          : //else get only visible rows that are pinned\n            (pinnedRowIds ?? []).map(\n              rowId => visibleRows.find(row => row.id === rowId)!\n            )\n\n      return rows.filter(Boolean).map(d => ({ ...d, position })) as Row<TData>[]\n    }\n\n    table.getTopRows = memo(\n      () => [table.getRowModel().rows, table.getState().rowPinning.top],\n      (allRows, topPinnedRowIds) =>\n        table._getPinnedRows(allRows, topPinnedRowIds, 'top'),\n      getMemoOptions(table.options, 'debugRows', 'getTopRows')\n    )\n\n    table.getBottomRows = memo(\n      () => [table.getRowModel().rows, table.getState().rowPinning.bottom],\n      (allRows, bottomPinnedRowIds) =>\n        table._getPinnedRows(allRows, bottomPinnedRowIds, 'bottom'),\n      getMemoOptions(table.options, 'debugRows', 'getBottomRows')\n    )\n\n    table.getCenterRows = memo(\n      () => [\n        table.getRowModel().rows,\n        table.getState().rowPinning.top,\n        table.getState().rowPinning.bottom,\n      ],\n      (allRows, top, bottom) => {\n        const topAndBottom = new Set([...(top ?? []), ...(bottom ?? [])])\n        return allRows.filter(d => !topAndBottom.has(d.id))\n      },\n      getMemoOptions(table.options, 'debugRows', 'getCenterRows')\n    )\n  },\n}\n", "import {\n  OnChangeFn,\n  Table,\n  Row,\n  RowModel,\n  Updater,\n  RowData,\n  TableFeature,\n} from '../types'\nimport { getMemoOptions, makeStateUpdater, memo } from '../utils'\n\nexport type RowSelectionState = Record<string, boolean>\n\nexport interface RowSelectionTableState {\n  rowSelection: RowSelectionState\n}\n\nexport interface RowSelectionOptions<TData extends RowData> {\n  /**\n   * - Enables/disables multiple row selection for all rows in the table OR\n   * - A function that given a row, returns whether to enable/disable multiple row selection for that row's children/grandchildren\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#enablemultirowselection)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  enableMultiRowSelection?: boolean | ((row: Row<TData>) => boolean)\n  /**\n   * - Enables/disables row selection for all rows in the table OR\n   * - A function that given a row, returns whether to enable/disable row selection for that row\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#enablerowselection)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  enableRowSelection?: boolean | ((row: Row<TData>) => boolean)\n  /**\n   * Enables/disables automatic sub-row selection when a parent row is selected, or a function that enables/disables automatic sub-row selection for each row.\n   * (Use in combination with expanding or grouping features)\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#enablesubrowselection)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  enableSubRowSelection?: boolean | ((row: Row<TData>) => boolean)\n  /**\n   * If provided, this function will be called with an `updaterFn` when `state.rowSelection` changes. This overrides the default internal state management, so you will need to persist the state change either fully or partially outside of the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#onrowselectionchange)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  onRowSelectionChange?: OnChangeFn<RowSelectionState>\n  // enableGroupingRowSelection?:\n  //   | boolean\n  //   | ((\n  //       row: Row<TData>\n  //     ) => boolean)\n  // isAdditiveSelectEvent?: (e: unknown) => boolean\n  // isInclusiveSelectEvent?: (e: unknown) => boolean\n  // selectRowsFn?: (\n  //   table: Table<TData>,\n  //   rowModel: RowModel<TData>\n  // ) => RowModel<TData>\n}\n\nexport interface RowSelectionRow {\n  /**\n   * Returns whether or not the row can multi-select.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#getcanmultiselect)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  getCanMultiSelect: () => boolean\n  /**\n   * Returns whether or not the row can be selected.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#getcanselect)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  getCanSelect: () => boolean\n  /**\n   * Returns whether or not the row can select sub rows automatically when the parent row is selected.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#getcanselectsubrows)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  getCanSelectSubRows: () => boolean\n  /**\n   * Returns whether or not all of the row's sub rows are selected.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#getisallsubrowsselected)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  getIsAllSubRowsSelected: () => boolean\n  /**\n   * Returns whether or not the row is selected.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#getisselected)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  getIsSelected: () => boolean\n  /**\n   * Returns whether or not some of the row's sub rows are selected.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#getissomeselected)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  getIsSomeSelected: () => boolean\n  /**\n   * Returns a handler that can be used to toggle the row.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#gettoggleselectedhandler)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  getToggleSelectedHandler: () => (event: unknown) => void\n  /**\n   * Selects/deselects the row.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#toggleselected)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  toggleSelected: (value?: boolean, opts?: { selectChildren?: boolean }) => void\n}\n\nexport interface RowSelectionInstance<TData extends RowData> {\n  /**\n   * Returns the row model of all rows that are selected after filtering has been applied.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#getfilteredselectedrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  getFilteredSelectedRowModel: () => RowModel<TData>\n  /**\n   * Returns the row model of all rows that are selected after grouping has been applied.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#getgroupedselectedrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  getGroupedSelectedRowModel: () => RowModel<TData>\n  /**\n   * Returns whether or not all rows on the current page are selected.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#getisallpagerowsselected)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  getIsAllPageRowsSelected: () => boolean\n  /**\n   * Returns whether or not all rows in the table are selected.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#getisallrowsselected)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  getIsAllRowsSelected: () => boolean\n  /**\n   * Returns whether or not any rows on the current page are selected.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#getissomepagerowsselected)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  getIsSomePageRowsSelected: () => boolean\n  /**\n   * Returns whether or not any rows in the table are selected.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#getissomerowsselected)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  getIsSomeRowsSelected: () => boolean\n  /**\n   * Returns the core row model of all rows before row selection has been applied.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#getpreselectedrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  getPreSelectedRowModel: () => RowModel<TData>\n  /**\n   * Returns the row model of all rows that are selected.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#getselectedrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  getSelectedRowModel: () => RowModel<TData>\n  /**\n   * Returns a handler that can be used to toggle all rows on the current page.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#gettoggleallpagerowsselectedhandler)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  getToggleAllPageRowsSelectedHandler: () => (event: unknown) => void\n  /**\n   * Returns a handler that can be used to toggle all rows in the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#gettoggleallrowsselectedhandler)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  getToggleAllRowsSelectedHandler: () => (event: unknown) => void\n  /**\n   * Resets the **rowSelection** state to the `initialState.rowSelection`, or `true` can be passed to force a default blank state reset to `{}`.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#resetrowselection)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  resetRowSelection: (defaultState?: boolean) => void\n  /**\n   * Sets or updates the `state.rowSelection` state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#setrowselection)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  setRowSelection: (updater: Updater<RowSelectionState>) => void\n  /**\n   * Selects/deselects all rows on the current page.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#toggleallpagerowsselected)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  toggleAllPageRowsSelected: (value?: boolean) => void\n  /**\n   * Selects/deselects all rows in the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/row-selection#toggleallrowsselected)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/row-selection)\n   */\n  toggleAllRowsSelected: (value?: boolean) => void\n}\n\n//\n\nexport const RowSelection: TableFeature = {\n  getInitialState: (state): RowSelectionTableState => {\n    return {\n      rowSelection: {},\n      ...state,\n    }\n  },\n\n  getDefaultOptions: <TData extends RowData>(\n    table: Table<TData>\n  ): RowSelectionOptions<TData> => {\n    return {\n      onRowSelectionChange: makeStateUpdater('rowSelection', table),\n      enableRowSelection: true,\n      enableMultiRowSelection: true,\n      enableSubRowSelection: true,\n      // enableGroupingRowSelection: false,\n      // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,\n      // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,\n    }\n  },\n\n  createTable: <TData extends RowData>(table: Table<TData>): void => {\n    table.setRowSelection = updater =>\n      table.options.onRowSelectionChange?.(updater)\n    table.resetRowSelection = defaultState =>\n      table.setRowSelection(\n        defaultState ? {} : table.initialState.rowSelection ?? {}\n      )\n    table.toggleAllRowsSelected = value => {\n      table.setRowSelection(old => {\n        value =\n          typeof value !== 'undefined' ? value : !table.getIsAllRowsSelected()\n\n        const rowSelection = { ...old }\n\n        const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows\n\n        // We don't use `mutateRowIsSelected` here for performance reasons.\n        // All of the rows are flat already, so it wouldn't be worth it\n        if (value) {\n          preGroupedFlatRows.forEach(row => {\n            if (!row.getCanSelect()) {\n              return\n            }\n            rowSelection[row.id] = true\n          })\n        } else {\n          preGroupedFlatRows.forEach(row => {\n            delete rowSelection[row.id]\n          })\n        }\n\n        return rowSelection\n      })\n    }\n    table.toggleAllPageRowsSelected = value =>\n      table.setRowSelection(old => {\n        const resolvedValue =\n          typeof value !== 'undefined'\n            ? value\n            : !table.getIsAllPageRowsSelected()\n\n        const rowSelection: RowSelectionState = { ...old }\n\n        table.getRowModel().rows.forEach(row => {\n          mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table)\n        })\n\n        return rowSelection\n      })\n\n    // addRowSelectionRange: rowId => {\n    //   const {\n    //     rows,\n    //     rowsById,\n    //     options: { selectGroupingRows, selectSubRows },\n    //   } = table\n\n    //   const findSelectedRow = (rows: Row[]) => {\n    //     let found\n    //     rows.find(d => {\n    //       if (d.getIsSelected()) {\n    //         found = d\n    //         return true\n    //       }\n    //       const subFound = findSelectedRow(d.subRows || [])\n    //       if (subFound) {\n    //         found = subFound\n    //         return true\n    //       }\n    //       return false\n    //     })\n    //     return found\n    //   }\n\n    //   const firstRow = findSelectedRow(rows) || rows[0]\n    //   const lastRow = rowsById[rowId]\n\n    //   let include = false\n    //   const selectedRowIds = {}\n\n    //   const addRow = (row: Row) => {\n    //     mutateRowIsSelected(selectedRowIds, row.id, true, {\n    //       rowsById,\n    //       selectGroupingRows: selectGroupingRows!,\n    //       selectSubRows: selectSubRows!,\n    //     })\n    //   }\n\n    //   table.rows.forEach(row => {\n    //     const isFirstRow = row.id === firstRow.id\n    //     const isLastRow = row.id === lastRow.id\n\n    //     if (isFirstRow || isLastRow) {\n    //       if (!include) {\n    //         include = true\n    //       } else if (include) {\n    //         addRow(row)\n    //         include = false\n    //       }\n    //     }\n\n    //     if (include) {\n    //       addRow(row)\n    //     }\n    //   })\n\n    //   table.setRowSelection(selectedRowIds)\n    // },\n    table.getPreSelectedRowModel = () => table.getCoreRowModel()\n    table.getSelectedRowModel = memo(\n      () => [table.getState().rowSelection, table.getCoreRowModel()],\n      (rowSelection, rowModel) => {\n        if (!Object.keys(rowSelection).length) {\n          return {\n            rows: [],\n            flatRows: [],\n            rowsById: {},\n          }\n        }\n\n        return selectRowsFn(table, rowModel)\n      },\n      getMemoOptions(table.options, 'debugTable', 'getSelectedRowModel')\n    )\n\n    table.getFilteredSelectedRowModel = memo(\n      () => [table.getState().rowSelection, table.getFilteredRowModel()],\n      (rowSelection, rowModel) => {\n        if (!Object.keys(rowSelection).length) {\n          return {\n            rows: [],\n            flatRows: [],\n            rowsById: {},\n          }\n        }\n\n        return selectRowsFn(table, rowModel)\n      },\n      getMemoOptions(table.options, 'debugTable', 'getFilteredSelectedRowModel')\n    )\n\n    table.getGroupedSelectedRowModel = memo(\n      () => [table.getState().rowSelection, table.getSortedRowModel()],\n      (rowSelection, rowModel) => {\n        if (!Object.keys(rowSelection).length) {\n          return {\n            rows: [],\n            flatRows: [],\n            rowsById: {},\n          }\n        }\n\n        return selectRowsFn(table, rowModel)\n      },\n      getMemoOptions(table.options, 'debugTable', 'getGroupedSelectedRowModel')\n    )\n\n    ///\n\n    // getGroupingRowCanSelect: rowId => {\n    //   const row = table.getRow(rowId)\n\n    //   if (!row) {\n    //     throw new Error()\n    //   }\n\n    //   if (typeof table.options.enableGroupingRowSelection === 'function') {\n    //     return table.options.enableGroupingRowSelection(row)\n    //   }\n\n    //   return table.options.enableGroupingRowSelection ?? false\n    // },\n\n    table.getIsAllRowsSelected = () => {\n      const preGroupedFlatRows = table.getFilteredRowModel().flatRows\n      const { rowSelection } = table.getState()\n\n      let isAllRowsSelected = Boolean(\n        preGroupedFlatRows.length && Object.keys(rowSelection).length\n      )\n\n      if (isAllRowsSelected) {\n        if (\n          preGroupedFlatRows.some(\n            row => row.getCanSelect() && !rowSelection[row.id]\n          )\n        ) {\n          isAllRowsSelected = false\n        }\n      }\n\n      return isAllRowsSelected\n    }\n\n    table.getIsAllPageRowsSelected = () => {\n      const paginationFlatRows = table\n        .getPaginationRowModel()\n        .flatRows.filter(row => row.getCanSelect())\n      const { rowSelection } = table.getState()\n\n      let isAllPageRowsSelected = !!paginationFlatRows.length\n\n      if (\n        isAllPageRowsSelected &&\n        paginationFlatRows.some(row => !rowSelection[row.id])\n      ) {\n        isAllPageRowsSelected = false\n      }\n\n      return isAllPageRowsSelected\n    }\n\n    table.getIsSomeRowsSelected = () => {\n      const totalSelected = Object.keys(\n        table.getState().rowSelection ?? {}\n      ).length\n      return (\n        totalSelected > 0 &&\n        totalSelected < table.getFilteredRowModel().flatRows.length\n      )\n    }\n\n    table.getIsSomePageRowsSelected = () => {\n      const paginationFlatRows = table.getPaginationRowModel().flatRows\n      return table.getIsAllPageRowsSelected()\n        ? false\n        : paginationFlatRows\n            .filter(row => row.getCanSelect())\n            .some(d => d.getIsSelected() || d.getIsSomeSelected())\n    }\n\n    table.getToggleAllRowsSelectedHandler = () => {\n      return (e: unknown) => {\n        table.toggleAllRowsSelected(\n          ((e as MouseEvent).target as HTMLInputElement).checked\n        )\n      }\n    }\n\n    table.getToggleAllPageRowsSelectedHandler = () => {\n      return (e: unknown) => {\n        table.toggleAllPageRowsSelected(\n          ((e as MouseEvent).target as HTMLInputElement).checked\n        )\n      }\n    }\n  },\n\n  createRow: <TData extends RowData>(\n    row: Row<TData>,\n    table: Table<TData>\n  ): void => {\n    row.toggleSelected = (value, opts) => {\n      const isSelected = row.getIsSelected()\n\n      table.setRowSelection(old => {\n        value = typeof value !== 'undefined' ? value : !isSelected\n\n        if (row.getCanSelect() && isSelected === value) {\n          return old\n        }\n\n        const selectedRowIds = { ...old }\n\n        mutateRowIsSelected(\n          selectedRowIds,\n          row.id,\n          value,\n          opts?.selectChildren ?? true,\n          table\n        )\n\n        return selectedRowIds\n      })\n    }\n    row.getIsSelected = () => {\n      const { rowSelection } = table.getState()\n      return isRowSelected(row, rowSelection)\n    }\n\n    row.getIsSomeSelected = () => {\n      const { rowSelection } = table.getState()\n      return isSubRowSelected(row, rowSelection, table) === 'some'\n    }\n\n    row.getIsAllSubRowsSelected = () => {\n      const { rowSelection } = table.getState()\n      return isSubRowSelected(row, rowSelection, table) === 'all'\n    }\n\n    row.getCanSelect = () => {\n      if (typeof table.options.enableRowSelection === 'function') {\n        return table.options.enableRowSelection(row)\n      }\n\n      return table.options.enableRowSelection ?? true\n    }\n\n    row.getCanSelectSubRows = () => {\n      if (typeof table.options.enableSubRowSelection === 'function') {\n        return table.options.enableSubRowSelection(row)\n      }\n\n      return table.options.enableSubRowSelection ?? true\n    }\n\n    row.getCanMultiSelect = () => {\n      if (typeof table.options.enableMultiRowSelection === 'function') {\n        return table.options.enableMultiRowSelection(row)\n      }\n\n      return table.options.enableMultiRowSelection ?? true\n    }\n    row.getToggleSelectedHandler = () => {\n      const canSelect = row.getCanSelect()\n\n      return (e: unknown) => {\n        if (!canSelect) return\n        row.toggleSelected(\n          ((e as MouseEvent).target as HTMLInputElement)?.checked\n        )\n      }\n    }\n  },\n}\n\nconst mutateRowIsSelected = <TData extends RowData>(\n  selectedRowIds: Record<string, boolean>,\n  id: string,\n  value: boolean,\n  includeChildren: boolean,\n  table: Table<TData>\n) => {\n  const row = table.getRow(id, true)\n\n  // const isGrouped = row.getIsGrouped()\n\n  // if ( // TODO: enforce grouping row selection rules\n  //   !isGrouped ||\n  //   (isGrouped && table.options.enableGroupingRowSelection)\n  // ) {\n  if (value) {\n    if (!row.getCanMultiSelect()) {\n      Object.keys(selectedRowIds).forEach(key => delete selectedRowIds[key])\n    }\n    if (row.getCanSelect()) {\n      selectedRowIds[id] = true\n    }\n  } else {\n    delete selectedRowIds[id]\n  }\n  // }\n\n  if (includeChildren && row.subRows?.length && row.getCanSelectSubRows()) {\n    row.subRows.forEach(row =>\n      mutateRowIsSelected(selectedRowIds, row.id, value, includeChildren, table)\n    )\n  }\n}\n\nexport function selectRowsFn<TData extends RowData>(\n  table: Table<TData>,\n  rowModel: RowModel<TData>\n): RowModel<TData> {\n  const rowSelection = table.getState().rowSelection\n\n  const newSelectedFlatRows: Row<TData>[] = []\n  const newSelectedRowsById: Record<string, Row<TData>> = {}\n\n  // Filters top level and nested rows\n  const recurseRows = (rows: Row<TData>[], depth = 0): Row<TData>[] => {\n    return rows\n      .map(row => {\n        const isSelected = isRowSelected(row, rowSelection)\n\n        if (isSelected) {\n          newSelectedFlatRows.push(row)\n          newSelectedRowsById[row.id] = row\n        }\n\n        if (row.subRows?.length) {\n          row = {\n            ...row,\n            subRows: recurseRows(row.subRows, depth + 1),\n          }\n        }\n\n        if (isSelected) {\n          return row\n        }\n      })\n      .filter(Boolean) as Row<TData>[]\n  }\n\n  return {\n    rows: recurseRows(rowModel.rows),\n    flatRows: newSelectedFlatRows,\n    rowsById: newSelectedRowsById,\n  }\n}\n\nexport function isRowSelected<TData extends RowData>(\n  row: Row<TData>,\n  selection: Record<string, boolean>\n): boolean {\n  return selection[row.id] ?? false\n}\n\nexport function isSubRowSelected<TData extends RowData>(\n  row: Row<TData>,\n  selection: Record<string, boolean>,\n  table: Table<TData>\n): boolean | 'some' | 'all' {\n  if (!row.subRows?.length) return false\n\n  let allChildrenSelected = true\n  let someSelected = false\n\n  row.subRows.forEach(subRow => {\n    // Bail out early if we know both of these\n    if (someSelected && !allChildrenSelected) {\n      return\n    }\n\n    if (subRow.getCanSelect()) {\n      if (isRowSelected(subRow, selection)) {\n        someSelected = true\n      } else {\n        allChildrenSelected = false\n      }\n    }\n\n    // Check row selection of nested subrows\n    if (subRow.subRows && subRow.subRows.length) {\n      const subRowChildrenSelected = isSubRowSelected(subRow, selection, table)\n      if (subRowChildrenSelected === 'all') {\n        someSelected = true\n      } else if (subRowChildrenSelected === 'some') {\n        someSelected = true\n        allChildrenSelected = false\n      } else {\n        allChildrenSelected = false\n      }\n    }\n  })\n\n  return allChildrenSelected ? 'all' : someSelected ? 'some' : false\n}\n", "import { SortingFn } from './features/RowSorting'\n\nexport const reSplitAlphaNumeric = /([0-9]+)/gm\n\nconst alphanumeric: SortingFn<any> = (rowA, rowB, columnId) => {\n  return compareAlphanumeric(\n    toString(rowA.getValue(columnId)).toLowerCase(),\n    toString(rowB.getValue(columnId)).toLowerCase()\n  )\n}\n\nconst alphanumericCaseSensitive: SortingFn<any> = (rowA, rowB, columnId) => {\n  return compareAlphanumeric(\n    toString(rowA.getValue(columnId)),\n    toString(rowB.getValue(columnId))\n  )\n}\n\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst text: SortingFn<any> = (rowA, rowB, columnId) => {\n  return compareBasic(\n    toString(rowA.getValue(columnId)).toLowerCase(),\n    toString(rowB.getValue(columnId)).toLowerCase()\n  )\n}\n\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst textCaseSensitive: SortingFn<any> = (rowA, rowB, columnId) => {\n  return compareBasic(\n    toString(rowA.getValue(columnId)),\n    toString(rowB.getValue(columnId))\n  )\n}\n\nconst datetime: SortingFn<any> = (rowA, rowB, columnId) => {\n  const a = rowA.getValue<Date>(columnId)\n  const b = rowB.getValue<Date>(columnId)\n\n  // Can handle nullish values\n  // Use > and < because == (and ===) doesn't work with\n  // Date objects (would require calling getTime()).\n  return a > b ? 1 : a < b ? -1 : 0\n}\n\nconst basic: SortingFn<any> = (rowA, rowB, columnId) => {\n  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId))\n}\n\n// Utils\n\nfunction compareBasic(a: any, b: any) {\n  return a === b ? 0 : a > b ? 1 : -1\n}\n\nfunction toString(a: any) {\n  if (typeof a === 'number') {\n    if (isNaN(a) || a === Infinity || a === -Infinity) {\n      return ''\n    }\n    return String(a)\n  }\n  if (typeof a === 'string') {\n    return a\n  }\n  return ''\n}\n\n// Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\nfunction compareAlphanumeric(aStr: string, bStr: string) {\n  // Split on number groups, but keep the delimiter\n  // Then remove falsey split values\n  const a = aStr.split(reSplitAlphaNumeric).filter(Boolean)\n  const b = bStr.split(reSplitAlphaNumeric).filter(Boolean)\n\n  // While\n  while (a.length && b.length) {\n    const aa = a.shift()!\n    const bb = b.shift()!\n\n    const an = parseInt(aa, 10)\n    const bn = parseInt(bb, 10)\n\n    const combo = [an, bn].sort()\n\n    // Both are string\n    if (isNaN(combo[0]!)) {\n      if (aa > bb) {\n        return 1\n      }\n      if (bb > aa) {\n        return -1\n      }\n      continue\n    }\n\n    // One is a string, one is a number\n    if (isNaN(combo[1]!)) {\n      return isNaN(an) ? -1 : 1\n    }\n\n    // Both are numbers\n    if (an > bn) {\n      return 1\n    }\n    if (bn > an) {\n      return -1\n    }\n  }\n\n  return a.length - b.length\n}\n\n// Exports\n\nexport const sortingFns = {\n  alphanumeric,\n  alphanumericCaseSensitive,\n  text,\n  textCaseSensitive,\n  datetime,\n  basic,\n}\n\nexport type BuiltInSortingFn = keyof typeof sortingFns\n", "import { RowModel } from '..'\nimport {\n  BuiltInSortingFn,\n  reSplitAlphaNumeric,\n  sortingFns,\n} from '../sortingFns'\n\nimport {\n  Column,\n  OnChangeFn,\n  Table,\n  Row,\n  Updater,\n  RowData,\n  SortingFns,\n  TableFeature,\n} from '../types'\n\nimport { isFunction, makeStateUpdater } from '../utils'\n\nexport type SortDirection = 'asc' | 'desc'\n\nexport interface ColumnSort {\n  desc: boolean\n  id: string\n}\n\nexport type SortingState = ColumnSort[]\n\nexport interface SortingTableState {\n  sorting: SortingState\n}\n\nexport interface SortingFn<TData extends RowData> {\n  (rowA: Row<TData>, rowB: Row<TData>, columnId: string): number\n}\n\nexport type CustomSortingFns<TData extends RowData> = Record<\n  string,\n  SortingFn<TData>\n>\n\nexport type SortingFnOption<TData extends RowData> =\n  | 'auto'\n  | keyof SortingFns\n  | BuiltInSortingFn\n  | SortingFn<TData>\n\nexport interface SortingColumnDef<TData extends RowData> {\n  /**\n   * Enables/Disables multi-sorting for this column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#enablemultisort)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  enableMultiSort?: boolean\n  /**\n   * Enables/Disables sorting for this column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#enablesorting)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  enableSorting?: boolean\n  /**\n   * Inverts the order of the sorting for this column. This is useful for values that have an inverted best/worst scale where lower numbers are better, eg. a ranking (1st, 2nd, 3rd) or golf-like scoring\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#invertsorting)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  invertSorting?: boolean\n  /**\n   * Set to `true` for sorting toggles on this column to start in the descending direction.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#sortdescfirst)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  sortDescFirst?: boolean\n  /**\n   * The sorting function to use with this column.\n   * - A `string` referencing a built-in sorting function\n   * - A custom sorting function\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#sortingfn)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  sortingFn?: SortingFnOption<TData>\n  /**\n   * The priority of undefined values when sorting this column.\n   * - `false`\n   *   - Undefined values will be considered tied and need to be sorted by the next column filter or original index (whichever applies)\n   * - `-1`\n   *   - Undefined values will be sorted with higher priority (ascending) (if ascending, undefined will appear on the beginning of the list)\n   * - `1`\n   *   - Undefined values will be sorted with lower priority (descending) (if ascending, undefined will appear on the end of the list)\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#sortundefined)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  sortUndefined?: false | -1 | 1 | 'first' | 'last'\n}\n\nexport interface SortingColumn<TData extends RowData> {\n  /**\n   * Removes this column from the table's sorting state\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#clearsorting)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  clearSorting: () => void\n  /**\n   * Returns a sort direction automatically inferred based on the columns values.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#getautosortdir)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  getAutoSortDir: () => SortDirection\n  /**\n   * Returns a sorting function automatically inferred based on the columns values.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#getautosortingfn)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  getAutoSortingFn: () => SortingFn<TData>\n  /**\n   * Returns whether this column can be multi-sorted.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#getcanmultisort)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  getCanMultiSort: () => boolean\n  /**\n   * Returns whether this column can be sorted.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#getcansort)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  getCanSort: () => boolean\n  /**\n   * Returns the first direction that should be used when sorting this column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#getfirstsortdir)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  getFirstSortDir: () => SortDirection\n  /**\n   * Returns the current sort direction of this column.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#getissorted)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  getIsSorted: () => false | SortDirection\n  /**\n   * Returns the next sorting order.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#getnextsortingorder)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  getNextSortingOrder: () => SortDirection | false\n  /**\n   * Returns the index position of this column's sorting within the sorting state\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#getsortindex)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  getSortIndex: () => number\n  /**\n   * Returns the resolved sorting function to be used for this column\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#getsortingfn)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  getSortingFn: () => SortingFn<TData>\n  /**\n   * Returns a function that can be used to toggle this column's sorting state. This is useful for attaching a click handler to the column header.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#gettogglesortinghandler)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  getToggleSortingHandler: () => undefined | ((event: unknown) => void)\n  /**\n   * Toggles this columns sorting state. If `desc` is provided, it will force the sort direction to that value. If `isMulti` is provided, it will additivity multi-sort the column (or toggle it if it is already sorted).\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#togglesorting)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  toggleSorting: (desc?: boolean, isMulti?: boolean) => void\n}\n\ninterface SortingOptionsBase {\n  /**\n   * Enables/disables the ability to remove multi-sorts\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#enablemultiremove)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  enableMultiRemove?: boolean\n  /**\n   * Enables/Disables multi-sorting for the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#enablemultisort)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  enableMultiSort?: boolean\n  /**\n   * Enables/Disables sorting for the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#enablesorting)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  enableSorting?: boolean\n  /**\n   * Enables/Disables the ability to remove sorting for the table.\n   * - If `true` then changing sort order will circle like: 'none' -> 'desc' -> 'asc' -> 'none' -> ...\n   * - If `false` then changing sort order will circle like: 'none' -> 'desc' -> 'asc' -> 'desc' -> 'asc' -> ...\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#enablesortingremoval)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  enableSortingRemoval?: boolean\n  /**\n   * This function is used to retrieve the sorted row model. If using server-side sorting, this function is not required. To use client-side sorting, pass the exported `getSortedRowModel()` from your adapter to your table or implement your own.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#getsortedrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  getSortedRowModel?: (table: Table<any>) => () => RowModel<any>\n  /**\n   * Pass a custom function that will be used to determine if a multi-sort event should be triggered. It is passed the event from the sort toggle handler and should return `true` if the event should trigger a multi-sort.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#ismultisortevent)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  isMultiSortEvent?: (e: unknown) => boolean\n  /**\n   * Enables manual sorting for the table. If this is `true`, you will be expected to sort your data before it is passed to the table. This is useful if you are doing server-side sorting.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#manualsorting)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  manualSorting?: boolean\n  /**\n   * Set a maximum number of columns that can be multi-sorted.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#maxmultisortcolcount)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  maxMultiSortColCount?: number\n  /**\n   * If provided, this function will be called with an `updaterFn` when `state.sorting` changes. This overrides the default internal state management, so you will need to persist the state change either fully or partially outside of the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#onsortingchange)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  onSortingChange?: OnChangeFn<SortingState>\n  /**\n   * If `true`, all sorts will default to descending as their first toggle state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#sortdescfirst)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  sortDescFirst?: boolean\n}\n\ntype ResolvedSortingFns = keyof SortingFns extends never\n  ? {\n      sortingFns?: Record<string, SortingFn<any>>\n    }\n  : {\n      sortingFns: Record<keyof SortingFns, SortingFn<any>>\n    }\n\nexport interface SortingOptions<TData extends RowData>\n  extends SortingOptionsBase,\n    ResolvedSortingFns {}\n\nexport interface SortingInstance<TData extends RowData> {\n  _getSortedRowModel?: () => RowModel<TData>\n  /**\n   * Returns the row model for the table before any sorting has been applied.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#getpresortedrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  getPreSortedRowModel: () => RowModel<TData>\n  /**\n   * Returns the row model for the table after sorting has been applied.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#getsortedrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  getSortedRowModel: () => RowModel<TData>\n  /**\n   * Resets the **sorting** state to `initialState.sorting`, or `true` can be passed to force a default blank state reset to `[]`.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#resetsorting)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  resetSorting: (defaultState?: boolean) => void\n  /**\n   * Sets or updates the `state.sorting` state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/features/sorting#setsorting)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/sorting)\n   */\n  setSorting: (updater: Updater<SortingState>) => void\n}\n\n//\n\nexport const RowSorting: TableFeature = {\n  getInitialState: (state): SortingTableState => {\n    return {\n      sorting: [],\n      ...state,\n    }\n  },\n\n  getDefaultColumnDef: <TData extends RowData>(): SortingColumnDef<TData> => {\n    return {\n      sortingFn: 'auto',\n      sortUndefined: 1,\n    }\n  },\n\n  getDefaultOptions: <TData extends RowData>(\n    table: Table<TData>\n  ): SortingOptions<TData> => {\n    return {\n      onSortingChange: makeStateUpdater('sorting', table),\n      isMultiSortEvent: (e: unknown) => {\n        return (e as MouseEvent).shiftKey\n      },\n    }\n  },\n\n  createColumn: <TData extends RowData, TValue>(\n    column: Column<TData, TValue>,\n    table: Table<TData>\n  ): void => {\n    column.getAutoSortingFn = () => {\n      const firstRows = table.getFilteredRowModel().flatRows.slice(10)\n\n      let isString = false\n\n      for (const row of firstRows) {\n        const value = row?.getValue(column.id)\n\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          return sortingFns.datetime\n        }\n\n        if (typeof value === 'string') {\n          isString = true\n\n          if (value.split(reSplitAlphaNumeric).length > 1) {\n            return sortingFns.alphanumeric\n          }\n        }\n      }\n\n      if (isString) {\n        return sortingFns.text\n      }\n\n      return sortingFns.basic\n    }\n    column.getAutoSortDir = () => {\n      const firstRow = table.getFilteredRowModel().flatRows[0]\n\n      const value = firstRow?.getValue(column.id)\n\n      if (typeof value === 'string') {\n        return 'asc'\n      }\n\n      return 'desc'\n    }\n    column.getSortingFn = () => {\n      if (!column) {\n        throw new Error()\n      }\n\n      return isFunction(column.columnDef.sortingFn)\n        ? column.columnDef.sortingFn\n        : column.columnDef.sortingFn === 'auto'\n          ? column.getAutoSortingFn()\n          : table.options.sortingFns?.[column.columnDef.sortingFn as string] ??\n            sortingFns[column.columnDef.sortingFn as BuiltInSortingFn]\n    }\n    column.toggleSorting = (desc, multi) => {\n      // if (column.columns.length) {\n      //   column.columns.forEach((c, i) => {\n      //     if (c.id) {\n      //       table.toggleColumnSorting(c.id, undefined, multi || !!i)\n      //     }\n      //   })\n      //   return\n      // }\n\n      // this needs to be outside of table.setSorting to be in sync with rerender\n      const nextSortingOrder = column.getNextSortingOrder()\n      const hasManualValue = typeof desc !== 'undefined' && desc !== null\n\n      table.setSorting(old => {\n        // Find any existing sorting for this column\n        const existingSorting = old?.find(d => d.id === column.id)\n        const existingIndex = old?.findIndex(d => d.id === column.id)\n\n        let newSorting: SortingState = []\n\n        // What should we do with this sort action?\n        let sortAction: 'add' | 'remove' | 'toggle' | 'replace'\n        let nextDesc = hasManualValue ? desc : nextSortingOrder === 'desc'\n\n        // Multi-mode\n        if (old?.length && column.getCanMultiSort() && multi) {\n          if (existingSorting) {\n            sortAction = 'toggle'\n          } else {\n            sortAction = 'add'\n          }\n        } else {\n          // Normal mode\n          if (old?.length && existingIndex !== old.length - 1) {\n            sortAction = 'replace'\n          } else if (existingSorting) {\n            sortAction = 'toggle'\n          } else {\n            sortAction = 'replace'\n          }\n        }\n\n        // Handle toggle states that will remove the sorting\n        if (sortAction === 'toggle') {\n          // If we are \"actually\" toggling (not a manual set value), should we remove the sorting?\n          if (!hasManualValue) {\n            // Is our intention to remove?\n            if (!nextSortingOrder) {\n              sortAction = 'remove'\n            }\n          }\n        }\n\n        if (sortAction === 'add') {\n          newSorting = [\n            ...old,\n            {\n              id: column.id,\n              desc: nextDesc,\n            },\n          ]\n          // Take latest n columns\n          newSorting.splice(\n            0,\n            newSorting.length -\n              (table.options.maxMultiSortColCount ?? Number.MAX_SAFE_INTEGER)\n          )\n        } else if (sortAction === 'toggle') {\n          // This flips (or sets) the\n          newSorting = old.map(d => {\n            if (d.id === column.id) {\n              return {\n                ...d,\n                desc: nextDesc,\n              }\n            }\n            return d\n          })\n        } else if (sortAction === 'remove') {\n          newSorting = old.filter(d => d.id !== column.id)\n        } else {\n          newSorting = [\n            {\n              id: column.id,\n              desc: nextDesc,\n            },\n          ]\n        }\n\n        return newSorting\n      })\n    }\n\n    column.getFirstSortDir = () => {\n      const sortDescFirst =\n        column.columnDef.sortDescFirst ??\n        table.options.sortDescFirst ??\n        column.getAutoSortDir() === 'desc'\n      return sortDescFirst ? 'desc' : 'asc'\n    }\n\n    column.getNextSortingOrder = (multi?: boolean) => {\n      const firstSortDirection = column.getFirstSortDir()\n      const isSorted = column.getIsSorted()\n\n      if (!isSorted) {\n        return firstSortDirection\n      }\n\n      if (\n        isSorted !== firstSortDirection &&\n        (table.options.enableSortingRemoval ?? true) && // If enableSortRemove, enable in general\n        (multi ? table.options.enableMultiRemove ?? true : true) // If multi, don't allow if enableMultiRemove))\n      ) {\n        return false\n      }\n      return isSorted === 'desc' ? 'asc' : 'desc'\n    }\n\n    column.getCanSort = () => {\n      return (\n        (column.columnDef.enableSorting ?? true) &&\n        (table.options.enableSorting ?? true) &&\n        !!column.accessorFn\n      )\n    }\n\n    column.getCanMultiSort = () => {\n      return (\n        column.columnDef.enableMultiSort ??\n        table.options.enableMultiSort ??\n        !!column.accessorFn\n      )\n    }\n\n    column.getIsSorted = () => {\n      const columnSort = table.getState().sorting?.find(d => d.id === column.id)\n\n      return !columnSort ? false : columnSort.desc ? 'desc' : 'asc'\n    }\n\n    column.getSortIndex = () =>\n      table.getState().sorting?.findIndex(d => d.id === column.id) ?? -1\n\n    column.clearSorting = () => {\n      //clear sorting for just 1 column\n      table.setSorting(old =>\n        old?.length ? old.filter(d => d.id !== column.id) : []\n      )\n    }\n\n    column.getToggleSortingHandler = () => {\n      const canSort = column.getCanSort()\n\n      return (e: unknown) => {\n        if (!canSort) return\n        ;(e as any).persist?.()\n        column.toggleSorting?.(\n          undefined,\n          column.getCanMultiSort() ? table.options.isMultiSortEvent?.(e) : false\n        )\n      }\n    }\n  },\n\n  createTable: <TData extends RowData>(table: Table<TData>): void => {\n    table.setSorting = updater => table.options.onSortingChange?.(updater)\n    table.resetSorting = defaultState => {\n      table.setSorting(defaultState ? [] : table.initialState?.sorting ?? [])\n    }\n    table.getPreSortedRowModel = () => table.getGroupedRowModel()\n    table.getSortedRowModel = () => {\n      if (!table._getSortedRowModel && table.options.getSortedRowModel) {\n        table._getSortedRowModel = table.options.getSortedRowModel(table)\n      }\n\n      if (table.options.manualSorting || !table._getSortedRowModel) {\n        return table.getPreSortedRowModel()\n      }\n\n      return table._getSortedRowModel()\n    }\n  },\n}\n", "import { functionalUpdate, getMemoOptions, memo, RequiredKeys } from '../utils'\n\nimport {\n  Updater,\n  TableOptionsResolved,\n  TableState,\n  Table,\n  InitialTableState,\n  Row,\n  Column,\n  RowModel,\n  ColumnDef,\n  TableOptions,\n  RowData,\n  TableMeta,\n  ColumnDefResolved,\n  GroupColumnDef,\n  TableFeature,\n} from '../types'\n\n//\nimport { createColumn } from './column'\nimport { Headers } from './headers'\n//\n\nimport { ColumnFaceting } from '../features/ColumnFaceting'\nimport { ColumnFiltering } from '../features/ColumnFiltering'\nimport { ColumnGrouping } from '../features/ColumnGrouping'\nimport { ColumnOrdering } from '../features/ColumnOrdering'\nimport { ColumnPinning } from '../features/ColumnPinning'\nimport { ColumnSizing } from '../features/ColumnSizing'\nimport { ColumnVisibility } from '../features/ColumnVisibility'\nimport { GlobalFaceting } from '../features/GlobalFaceting'\nimport { GlobalFiltering } from '../features/GlobalFiltering'\nimport { RowExpanding } from '../features/RowExpanding'\nimport { RowPagination } from '../features/RowPagination'\nimport { RowPinning } from '../features/RowPinning'\nimport { RowSelection } from '../features/RowSelection'\nimport { RowSorting } from '../features/RowSorting'\n\nconst builtInFeatures = [\n  Headers,\n  ColumnVisibility,\n  ColumnOrdering,\n  ColumnPinning,\n  ColumnFaceting,\n  ColumnFiltering,\n  GlobalFaceting, //depends on ColumnFaceting\n  GlobalFiltering, //depends on ColumnFiltering\n  RowSorting,\n  ColumnGrouping, //depends on RowSorting\n  RowExpanding,\n  RowPagination,\n  RowPinning,\n  RowSelection,\n  ColumnSizing,\n] as const\n\n//\n\nexport interface CoreTableState {}\n\nexport interface CoreOptions<TData extends RowData> {\n  /**\n   * An array of extra features that you can add to the table instance.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#_features)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  _features?: TableFeature[]\n  /**\n   * Set this option to override any of the `autoReset...` feature options.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#autoresetall)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  autoResetAll?: boolean\n  /**\n   * The array of column defs to use for the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#columns)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  columns: ColumnDef<TData, any>[]\n  /**\n   * The data for the table to display. This array should match the type you provided to `table.setRowType<...>`. Columns can access this data via string/index or a functional accessor. When the `data` option changes reference, the table will reprocess the data.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#data)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  data: TData[]\n  /**\n   * Set this option to `true` to output all debugging information to the console.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#debugall)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  debugAll?: boolean\n  /**\n   * Set this option to `true` to output cell debugging information to the console.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#debugcells]\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  debugCells?: boolean\n  /**\n   * Set this option to `true` to output column debugging information to the console.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#debugcolumns)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  debugColumns?: boolean\n  /**\n   * Set this option to `true` to output header debugging information to the console.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#debugheaders)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  debugHeaders?: boolean\n  /**\n   * Set this option to `true` to output row debugging information to the console.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#debugrows)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  debugRows?: boolean\n  /**\n   * Set this option to `true` to output table debugging information to the console.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#debugtable)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  debugTable?: boolean\n  /**\n   * Default column options to use for all column defs supplied to the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#defaultcolumn)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  defaultColumn?: Partial<ColumnDef<TData, unknown>>\n  /**\n   * This required option is a factory for a function that computes and returns the core row model for the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#getcorerowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  getCoreRowModel: (table: Table<any>) => () => RowModel<any>\n  /**\n   * This optional function is used to derive a unique ID for any given row. If not provided the rows index is used (nested rows join together with `.` using their grandparents' index eg. `index.index.index`). If you need to identify individual rows that are originating from any server-side operations, it's suggested you use this function to return an ID that makes sense regardless of network IO/ambiguity eg. a userId, taskId, database ID field, etc.\n   * @example getRowId: row => row.userId\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#getrowid)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  getRowId?: (originalRow: TData, index: number, parent?: Row<TData>) => string\n  /**\n   * This optional function is used to access the sub rows for any given row. If you are using nested rows, you will need to use this function to return the sub rows object (or undefined) from the row.\n   * @example getSubRows: row => row.subRows\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#getsubrows)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  getSubRows?: (originalRow: TData, index: number) => undefined | TData[]\n  /**\n   * Use this option to optionally pass initial state to the table. This state will be used when resetting various table states either automatically by the table (eg. `options.autoResetPageIndex`) or via functions like `table.resetRowSelection()`. Most reset function allow you optionally pass a flag to reset to a blank/default state instead of the initial state.\n   *\n   * Table state will not be reset when this object changes, which also means that the initial state object does not need to be stable.\n   *\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#initialstate)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  initialState?: InitialTableState\n  /**\n   * This option is used to optionally implement the merging of table options.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#mergeoptions)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  mergeOptions?: (\n    defaultOptions: TableOptions<TData>,\n    options: Partial<TableOptions<TData>>\n  ) => TableOptions<TData>\n  /**\n   * You can pass any object to `options.meta` and access it anywhere the `table` is available via `table.options.meta`.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#meta)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  meta?: TableMeta<TData>\n  /**\n   * The `onStateChange` option can be used to optionally listen to state changes within the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#onstatechange)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  onStateChange: (updater: Updater<TableState>) => void\n  /**\n   * Value used when the desired value is not found in the data.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#renderfallbackvalue)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  renderFallbackValue: any\n  /**\n   * The `state` option can be used to optionally _control_ part or all of the table state. The state you pass here will merge with and overwrite the internal automatically-managed state to produce the final state for the table. You can also listen to state changes via the `onStateChange` option.\n   * > Note: Any state passed in here will override both the internal state and any other `initialState` you provide.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#state)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  state: Partial<TableState>\n}\n\nexport interface CoreInstance<TData extends RowData> {\n  _features: readonly TableFeature[]\n  _getAllFlatColumnsById: () => Record<string, Column<TData, unknown>>\n  _getColumnDefs: () => ColumnDef<TData, unknown>[]\n  _getCoreRowModel?: () => RowModel<TData>\n  _getDefaultColumnDef: () => Partial<ColumnDef<TData, unknown>>\n  _getRowId: (_: TData, index: number, parent?: Row<TData>) => string\n  _queue: (cb: () => void) => void\n  /**\n   * Returns all columns in the table in their normalized and nested hierarchy.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#getallcolumns)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  getAllColumns: () => Column<TData, unknown>[]\n  /**\n   * Returns all columns in the table flattened to a single level.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#getallflatcolumns)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  getAllFlatColumns: () => Column<TData, unknown>[]\n  /**\n   * Returns all leaf-node columns in the table flattened to a single level. This does not include parent columns.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#getallleafcolumns)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  getAllLeafColumns: () => Column<TData, unknown>[]\n  /**\n   * Returns a single column by its ID.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#getcolumn)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  getColumn: (columnId: string) => Column<TData, unknown> | undefined\n  /**\n   * Returns the core row model before any processing has been applied.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#getcorerowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  getCoreRowModel: () => RowModel<TData>\n  /**\n   * Returns the row with the given ID.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#getrow)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  getRow: (id: string, searchAll?: boolean) => Row<TData>\n  /**\n   * Returns the final model after all processing from other used features has been applied. This is the row model that is most commonly used for rendering.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#getrowmodel)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  getRowModel: () => RowModel<TData>\n  /**\n   * Call this function to get the table's current state. It's recommended to use this function and its state, especially when managing the table state manually. It is the exact same state used internally by the table for every feature and function it provides.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#getstate)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  getState: () => TableState\n  /**\n   * This is the resolved initial state of the table.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#initialstate)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  initialState: TableState\n  /**\n   * A read-only reference to the table's current options.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#options)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  options: RequiredKeys<TableOptionsResolved<TData>, 'state'>\n  /**\n   * Call this function to reset the table state to the initial state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#reset)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  reset: () => void\n  /**\n   * This function can be used to update the table options.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#setoptions)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  setOptions: (newOptions: Updater<TableOptionsResolved<TData>>) => void\n  /**\n   * Call this function to update the table state.\n   * @link [API Docs](https://tanstack.com/table/v8/docs/api/core/table#setstate)\n   * @link [Guide](https://tanstack.com/table/v8/docs/guide/tables)\n   */\n  setState: (updater: Updater<TableState>) => void\n}\n\nexport function createTable<TData extends RowData>(\n  options: TableOptionsResolved<TData>\n): Table<TData> {\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    (options.debugAll || options.debugTable)\n  ) {\n    console.info('Creating Table Instance...')\n  }\n\n  const _features = [...builtInFeatures, ...(options._features ?? [])]\n\n  let table = { _features } as unknown as Table<TData>\n\n  const defaultOptions = table._features.reduce((obj, feature) => {\n    return Object.assign(obj, feature.getDefaultOptions?.(table))\n  }, {}) as TableOptionsResolved<TData>\n\n  const mergeOptions = (options: TableOptionsResolved<TData>) => {\n    if (table.options.mergeOptions) {\n      return table.options.mergeOptions(defaultOptions, options)\n    }\n\n    return {\n      ...defaultOptions,\n      ...options,\n    }\n  }\n\n  const coreInitialState: CoreTableState = {}\n\n  let initialState = {\n    ...coreInitialState,\n    ...(options.initialState ?? {}),\n  } as TableState\n\n  table._features.forEach(feature => {\n    initialState = (feature.getInitialState?.(initialState) ??\n      initialState) as TableState\n  })\n\n  const queued: (() => void)[] = []\n  let queuedTimeout = false\n\n  const coreInstance: CoreInstance<TData> = {\n    _features,\n    options: {\n      ...defaultOptions,\n      ...options,\n    },\n    initialState,\n    _queue: cb => {\n      queued.push(cb)\n\n      if (!queuedTimeout) {\n        queuedTimeout = true\n\n        // Schedule a microtask to run the queued callbacks after\n        // the current call stack (render, etc) has finished.\n        Promise.resolve()\n          .then(() => {\n            while (queued.length) {\n              queued.shift()!()\n            }\n            queuedTimeout = false\n          })\n          .catch(error =>\n            setTimeout(() => {\n              throw error\n            })\n          )\n      }\n    },\n    reset: () => {\n      table.setState(table.initialState)\n    },\n    setOptions: updater => {\n      const newOptions = functionalUpdate(updater, table.options)\n      table.options = mergeOptions(newOptions) as RequiredKeys<\n        TableOptionsResolved<TData>,\n        'state'\n      >\n    },\n\n    getState: () => {\n      return table.options.state as TableState\n    },\n\n    setState: (updater: Updater<TableState>) => {\n      table.options.onStateChange?.(updater)\n    },\n\n    _getRowId: (row: TData, index: number, parent?: Row<TData>) =>\n      table.options.getRowId?.(row, index, parent) ??\n      `${parent ? [parent.id, index].join('.') : index}`,\n\n    getCoreRowModel: () => {\n      if (!table._getCoreRowModel) {\n        table._getCoreRowModel = table.options.getCoreRowModel(table)\n      }\n\n      return table._getCoreRowModel!()\n    },\n\n    // The final calls start at the bottom of the model,\n    // expanded rows, which then work their way up\n\n    getRowModel: () => {\n      return table.getPaginationRowModel()\n    },\n    //in next version, we should just pass in the row model as the optional 2nd arg\n    getRow: (id: string, searchAll?: boolean) => {\n      let row = (\n        searchAll ? table.getPrePaginationRowModel() : table.getRowModel()\n      ).rowsById[id]\n\n      if (!row) {\n        row = table.getCoreRowModel().rowsById[id]\n        if (!row) {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(`getRow could not find row with ID: ${id}`)\n          }\n          throw new Error()\n        }\n      }\n\n      return row\n    },\n    _getDefaultColumnDef: memo(\n      () => [table.options.defaultColumn],\n      defaultColumn => {\n        defaultColumn = (defaultColumn ?? {}) as Partial<\n          ColumnDef<TData, unknown>\n        >\n\n        return {\n          header: props => {\n            const resolvedColumnDef = props.header.column\n              .columnDef as ColumnDefResolved<TData>\n\n            if (resolvedColumnDef.accessorKey) {\n              return resolvedColumnDef.accessorKey\n            }\n\n            if (resolvedColumnDef.accessorFn) {\n              return resolvedColumnDef.id\n            }\n\n            return null\n          },\n          // footer: props => props.header.column.id,\n          cell: props => props.renderValue<any>()?.toString?.() ?? null,\n          ...table._features.reduce((obj, feature) => {\n            return Object.assign(obj, feature.getDefaultColumnDef?.())\n          }, {}),\n          ...defaultColumn,\n        } as Partial<ColumnDef<TData, unknown>>\n      },\n      getMemoOptions(options, 'debugColumns', '_getDefaultColumnDef')\n    ),\n\n    _getColumnDefs: () => table.options.columns,\n\n    getAllColumns: memo(\n      () => [table._getColumnDefs()],\n      columnDefs => {\n        const recurseColumns = (\n          columnDefs: ColumnDef<TData, unknown>[],\n          parent?: Column<TData, unknown>,\n          depth = 0\n        ): Column<TData, unknown>[] => {\n          return columnDefs.map(columnDef => {\n            const column = createColumn(table, columnDef, depth, parent)\n\n            const groupingColumnDef = columnDef as GroupColumnDef<\n              TData,\n              unknown\n            >\n\n            column.columns = groupingColumnDef.columns\n              ? recurseColumns(groupingColumnDef.columns, column, depth + 1)\n              : []\n\n            return column\n          })\n        }\n\n        return recurseColumns(columnDefs)\n      },\n      getMemoOptions(options, 'debugColumns', 'getAllColumns')\n    ),\n\n    getAllFlatColumns: memo(\n      () => [table.getAllColumns()],\n      allColumns => {\n        return allColumns.flatMap(column => {\n          return column.getFlatColumns()\n        })\n      },\n      getMemoOptions(options, 'debugColumns', 'getAllFlatColumns')\n    ),\n\n    _getAllFlatColumnsById: memo(\n      () => [table.getAllFlatColumns()],\n      flatColumns => {\n        return flatColumns.reduce(\n          (acc, column) => {\n            acc[column.id] = column\n            return acc\n          },\n          {} as Record<string, Column<TData, unknown>>\n        )\n      },\n      getMemoOptions(options, 'debugColumns', 'getAllFlatColumnsById')\n    ),\n\n    getAllLeafColumns: memo(\n      () => [table.getAllColumns(), table._getOrderColumnsFn()],\n      (allColumns, orderColumns) => {\n        let leafColumns = allColumns.flatMap(column => column.getLeafColumns())\n        return orderColumns(leafColumns)\n      },\n      getMemoOptions(options, 'debugColumns', 'getAllLeafColumns')\n    ),\n\n    getColumn: columnId => {\n      const column = table._getAllFlatColumnsById()[columnId]\n\n      if (process.env.NODE_ENV !== 'production' && !column) {\n        console.error(`[Table] Column with id '${columnId}' does not exist.`)\n      }\n\n      return column\n    },\n  }\n\n  Object.assign(table, coreInstance)\n\n  for (let index = 0; index < table._features.length; index++) {\n    const feature = table._features[index]\n    feature?.createTable?.(table)\n  }\n\n  return table\n}\n", "import { createRow } from '../core/row'\nimport { Table, Row, RowModel, RowData } from '../types'\nimport { getMemoOptions, memo } from '../utils'\n\nexport function getCoreRowModel<TData extends RowData>(): (\n  table: Table<TData>\n) => () => RowModel<TData> {\n  return table =>\n    memo(\n      () => [table.options.data],\n      (\n        data\n      ): {\n        rows: Row<TData>[]\n        flatRows: Row<TData>[]\n        rowsById: Record<string, Row<TData>>\n      } => {\n        const rowModel: RowModel<TData> = {\n          rows: [],\n          flatRows: [],\n          rowsById: {},\n        }\n\n        const accessRows = (\n          originalRows: TData[],\n          depth = 0,\n          parentRow?: Row<TData>\n        ): Row<TData>[] => {\n          const rows = [] as Row<TData>[]\n\n          for (let i = 0; i < originalRows.length; i++) {\n            // This could be an expensive check at scale, so we should move it somewhere else, but where?\n            // if (!id) {\n            //   if (process.env.NODE_ENV !== 'production') {\n            //     throw new Error(`getRowId expected an ID, but got ${id}`)\n            //   }\n            // }\n\n            // Make the row\n            const row = createRow(\n              table,\n              table._getRowId(originalRows[i]!, i, parentRow),\n              originalRows[i]!,\n              i,\n              depth,\n              undefined,\n              parentRow?.id\n            )\n\n            // Keep track of every row in a flat array\n            rowModel.flatRows.push(row)\n            // Also keep track of every row by its ID\n            rowModel.rowsById[row.id] = row\n            // Push table row into parent\n            rows.push(row)\n\n            // Get the original subrows\n            if (table.options.getSubRows) {\n              row.originalSubRows = table.options.getSubRows(\n                originalRows[i]!,\n                i\n              )\n\n              // Then recursively access them\n              if (row.originalSubRows?.length) {\n                row.subRows = accessRows(row.originalSubRows, depth + 1, row)\n              }\n            }\n          }\n\n          return rows\n        }\n\n        rowModel.rows = accessRows(data)\n\n        return rowModel\n      },\n      getMemoOptions(table.options, 'debugTable', 'getRowModel', () =>\n        table._autoResetPageIndex()\n      )\n    )\n}\n", "import { Table, Row, RowModel, RowData } from '../types'\nimport { getMemoOptions, memo } from '../utils'\n\nexport function getExpandedRowModel<TData extends RowData>(): (\n  table: Table<TData>\n) => () => RowModel<TData> {\n  return table =>\n    memo(\n      () => [\n        table.getState().expanded,\n        table.getPreExpandedRowModel(),\n        table.options.paginateExpandedRows,\n      ],\n      (expanded, rowModel, paginateExpandedRows) => {\n        if (\n          !rowModel.rows.length ||\n          (expanded !== true && !Object.keys(expanded ?? {}).length)\n        ) {\n          return rowModel\n        }\n\n        if (!paginateExpandedRows) {\n          // Only expand rows at this point if they are being paginated\n          return rowModel\n        }\n\n        return expandRows(rowModel)\n      },\n      getMemoOptions(table.options, 'debugTable', 'getExpandedRowModel')\n    )\n}\n\nexport function expandRows<TData extends RowData>(rowModel: RowModel<TData>) {\n  const expandedRows: Row<TData>[] = []\n\n  const handleRow = (row: Row<TData>) => {\n    expandedRows.push(row)\n\n    if (row.subRows?.length && row.getIsExpanded()) {\n      row.subRows.forEach(handleRow)\n    }\n  }\n\n  rowModel.rows.forEach(handleRow)\n\n  return {\n    rows: expandedRows,\n    flatRows: rowModel.flatRows,\n    rowsById: rowModel.rowsById,\n  }\n}\n", "import { Table, RowData } from '../types'\nimport { getMemoOptions, memo } from '../utils'\n\nexport function getFacetedMinMaxValues<TData extends RowData>(): (\n  table: Table<TData>,\n  columnId: string\n) => () => undefined | [number, number] {\n  return (table, columnId) =>\n    memo(\n      () => [table.getColumn(columnId)?.getFacetedRowModel()],\n      facetedRowModel => {\n        if (!facetedRowModel) return undefined\n\n        const firstValue =\n          facetedRowModel.flatRows[0]?.getUniqueValues(columnId)\n\n        if (typeof firstValue === 'undefined') {\n          return undefined\n        }\n\n        let facetedMinMaxValues: [any, any] = [firstValue, firstValue]\n\n        for (let i = 0; i < facetedRowModel.flatRows.length; i++) {\n          const values =\n            facetedRowModel.flatRows[i]!.getUniqueValues<number>(columnId)\n\n          for (let j = 0; j < values.length; j++) {\n            const value = values[j]!\n\n            if (value < facetedMinMaxValues[0]) {\n              facetedMinMaxValues[0] = value\n            } else if (value > facetedMinMaxValues[1]) {\n              facetedMinMaxValues[1] = value\n            }\n          }\n        }\n\n        return facetedMinMaxValues\n      },\n      getMemoOptions(table.options, 'debugTable', 'getFacetedMinMaxValues')\n    )\n}\n", "import { createRow } from '../core/row'\nimport { Row, RowModel, Table, RowData } from '../types'\n\nexport function filterRows<TData extends RowData>(\n  rows: Row<TData>[],\n  filterRowImpl: (row: Row<TData>) => any,\n  table: Table<TData>\n) {\n  if (table.options.filterFromLeafRows) {\n    return filterRowModelFromLeafs(rows, filterRowImpl, table)\n  }\n\n  return filterRowModelFromRoot(rows, filterRowImpl, table)\n}\n\nfunction filterRowModelFromLeafs<TData extends RowData>(\n  rowsToFilter: Row<TData>[],\n  filterRow: (row: Row<TData>) => Row<TData>[],\n  table: Table<TData>\n): RowModel<TData> {\n  const newFilteredFlatRows: Row<TData>[] = []\n  const newFilteredRowsById: Record<string, Row<TData>> = {}\n  const maxDepth = table.options.maxLeafRowFilterDepth ?? 100\n\n  const recurseFilterRows = (rowsToFilter: Row<TData>[], depth = 0) => {\n    const rows: Row<TData>[] = []\n\n    // Filter from children up first\n    for (let i = 0; i < rowsToFilter.length; i++) {\n      let row = rowsToFilter[i]!\n\n      const newRow = createRow(\n        table,\n        row.id,\n        row.original,\n        row.index,\n        row.depth,\n        undefined,\n        row.parentId\n      )\n      newRow.columnFilters = row.columnFilters\n\n      if (row.subRows?.length && depth < maxDepth) {\n        newRow.subRows = recurseFilterRows(row.subRows, depth + 1)\n        row = newRow\n\n        if (filterRow(row) && !newRow.subRows.length) {\n          rows.push(row)\n          newFilteredRowsById[row.id] = row\n          newFilteredFlatRows.push(row)\n          continue\n        }\n\n        if (filterRow(row) || newRow.subRows.length) {\n          rows.push(row)\n          newFilteredRowsById[row.id] = row\n          newFilteredFlatRows.push(row)\n          continue\n        }\n      } else {\n        row = newRow\n        if (filterRow(row)) {\n          rows.push(row)\n          newFilteredRowsById[row.id] = row\n          newFilteredFlatRows.push(row)\n        }\n      }\n    }\n\n    return rows\n  }\n\n  return {\n    rows: recurseFilterRows(rowsToFilter),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById,\n  }\n}\n\nfunction filterRowModelFromRoot<TData extends RowData>(\n  rowsToFilter: Row<TData>[],\n  filterRow: (row: Row<TData>) => any,\n  table: Table<TData>\n): RowModel<TData> {\n  const newFilteredFlatRows: Row<TData>[] = []\n  const newFilteredRowsById: Record<string, Row<TData>> = {}\n  const maxDepth = table.options.maxLeafRowFilterDepth ?? 100\n\n  // Filters top level and nested rows\n  const recurseFilterRows = (rowsToFilter: Row<TData>[], depth = 0) => {\n    // Filter from parents downward first\n\n    const rows: Row<TData>[] = []\n\n    // Apply the filter to any subRows\n    for (let i = 0; i < rowsToFilter.length; i++) {\n      let row = rowsToFilter[i]!\n\n      const pass = filterRow(row)\n\n      if (pass) {\n        if (row.subRows?.length && depth < maxDepth) {\n          const newRow = createRow(\n            table,\n            row.id,\n            row.original,\n            row.index,\n            row.depth,\n            undefined,\n            row.parentId\n          )\n          newRow.subRows = recurseFilterRows(row.subRows, depth + 1)\n          row = newRow\n        }\n\n        rows.push(row)\n        newFilteredFlatRows.push(row)\n        newFilteredRowsById[row.id] = row\n      }\n    }\n\n    return rows\n  }\n\n  return {\n    rows: recurseFilterRows(rowsToFilter),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById,\n  }\n}\n", "import { Table, RowModel, Row, RowData } from '../types'\nimport { getMemoOptions, memo } from '../utils'\nimport { filterRows } from './filterRowsUtils'\n\nexport function getFacetedRowModel<TData extends RowData>(): (\n  table: Table<TData>,\n  columnId: string\n) => () => RowModel<TData> {\n  return (table, columnId) =>\n    memo(\n      () => [\n        table.getPreFilteredRowModel(),\n        table.getState().columnFilters,\n        table.getState().globalFilter,\n        table.getFilteredRowModel(),\n      ],\n      (preRowModel, columnFilters, globalFilter) => {\n        if (\n          !preRowModel.rows.length ||\n          (!columnFilters?.length && !globalFilter)\n        ) {\n          return preRowModel\n        }\n\n        const filterableIds = [\n          ...columnFilters.map(d => d.id).filter(d => d !== columnId),\n          globalFilter ? '__global__' : undefined,\n        ].filter(Boolean) as string[]\n\n        const filterRowsImpl = (row: Row<TData>) => {\n          // Horizontally filter rows through each column\n          for (let i = 0; i < filterableIds.length; i++) {\n            if (row.columnFilters[filterableIds[i]!] === false) {\n              return false\n            }\n          }\n          return true\n        }\n\n        return filterRows(preRowModel.rows, filterRowsImpl, table)\n      },\n      getMemoOptions(table.options, 'debugTable', 'getFacetedRowModel')\n    )\n}\n", "import { Table, RowData } from '../types'\nimport { getMemoOptions, memo } from '../utils'\n\nexport function getFacetedUniqueValues<TData extends RowData>(): (\n  table: Table<TData>,\n  columnId: string\n) => () => Map<any, number> {\n  return (table, columnId) =>\n    memo(\n      () => [table.getColumn(columnId)?.getFacetedRowModel()],\n      facetedRowModel => {\n        if (!facetedRowModel) return new Map()\n\n        let facetedUniqueValues = new Map<any, number>()\n\n        for (let i = 0; i < facetedRowModel.flatRows.length; i++) {\n          const values =\n            facetedRowModel.flatRows[i]!.getUniqueValues<number>(columnId)\n\n          for (let j = 0; j < values.length; j++) {\n            const value = values[j]!\n\n            if (facetedUniqueValues.has(value)) {\n              facetedUniqueValues.set(\n                value,\n                (facetedUniqueValues.get(value) ?? 0) + 1\n              )\n            } else {\n              facetedUniqueValues.set(value, 1)\n            }\n          }\n        }\n\n        return facetedUniqueValues\n      },\n      getMemoOptions(\n        table.options,\n        'debugTable',\n        `getFacetedUniqueValues_${columnId}`\n      )\n    )\n}\n", "import { ResolvedColumnFilter } from '../features/ColumnFiltering'\nimport { Table, RowModel, Row, RowData } from '../types'\nimport { getMemoOptions, memo } from '../utils'\nimport { filterRows } from './filterRowsUtils'\n\nexport function getFilteredRowModel<TData extends RowData>(): (\n  table: Table<TData>\n) => () => RowModel<TData> {\n  return table =>\n    memo(\n      () => [\n        table.getPreFilteredRowModel(),\n        table.getState().columnFilters,\n        table.getState().globalFilter,\n      ],\n      (rowModel, columnFilters, globalFilter) => {\n        if (\n          !rowModel.rows.length ||\n          (!columnFilters?.length && !globalFilter)\n        ) {\n          for (let i = 0; i < rowModel.flatRows.length; i++) {\n            rowModel.flatRows[i]!.columnFilters = {}\n            rowModel.flatRows[i]!.columnFiltersMeta = {}\n          }\n          return rowModel\n        }\n\n        const resolvedColumnFilters: ResolvedColumnFilter<TData>[] = []\n        const resolvedGlobalFilters: ResolvedColumnFilter<TData>[] = []\n\n        ;(columnFilters ?? []).forEach(d => {\n          const column = table.getColumn(d.id)\n\n          if (!column) {\n            return\n          }\n\n          const filterFn = column.getFilterFn()\n\n          if (!filterFn) {\n            if (process.env.NODE_ENV !== 'production') {\n              console.warn(\n                `Could not find a valid 'column.filterFn' for column with the ID: ${column.id}.`\n              )\n            }\n            return\n          }\n\n          resolvedColumnFilters.push({\n            id: d.id,\n            filterFn,\n            resolvedValue: filterFn.resolveFilterValue?.(d.value) ?? d.value,\n          })\n        })\n\n        const filterableIds = (columnFilters ?? []).map(d => d.id)\n\n        const globalFilterFn = table.getGlobalFilterFn()\n\n        const globallyFilterableColumns = table\n          .getAllLeafColumns()\n          .filter(column => column.getCanGlobalFilter())\n\n        if (\n          globalFilter &&\n          globalFilterFn &&\n          globallyFilterableColumns.length\n        ) {\n          filterableIds.push('__global__')\n\n          globallyFilterableColumns.forEach(column => {\n            resolvedGlobalFilters.push({\n              id: column.id,\n              filterFn: globalFilterFn,\n              resolvedValue:\n                globalFilterFn.resolveFilterValue?.(globalFilter) ??\n                globalFilter,\n            })\n          })\n        }\n\n        let currentColumnFilter\n        let currentGlobalFilter\n\n        // Flag the prefiltered row model with each filter state\n        for (let j = 0; j < rowModel.flatRows.length; j++) {\n          const row = rowModel.flatRows[j]!\n\n          row.columnFilters = {}\n\n          if (resolvedColumnFilters.length) {\n            for (let i = 0; i < resolvedColumnFilters.length; i++) {\n              currentColumnFilter = resolvedColumnFilters[i]!\n              const id = currentColumnFilter.id\n\n              // Tag the row with the column filter state\n              row.columnFilters[id] = currentColumnFilter.filterFn(\n                row,\n                id,\n                currentColumnFilter.resolvedValue,\n                filterMeta => {\n                  row.columnFiltersMeta[id] = filterMeta\n                }\n              )\n            }\n          }\n\n          if (resolvedGlobalFilters.length) {\n            for (let i = 0; i < resolvedGlobalFilters.length; i++) {\n              currentGlobalFilter = resolvedGlobalFilters[i]!\n              const id = currentGlobalFilter.id\n              // Tag the row with the first truthy global filter state\n              if (\n                currentGlobalFilter.filterFn(\n                  row,\n                  id,\n                  currentGlobalFilter.resolvedValue,\n                  filterMeta => {\n                    row.columnFiltersMeta[id] = filterMeta\n                  }\n                )\n              ) {\n                row.columnFilters.__global__ = true\n                break\n              }\n            }\n\n            if (row.columnFilters.__global__ !== true) {\n              row.columnFilters.__global__ = false\n            }\n          }\n        }\n\n        const filterRowsImpl = (row: Row<TData>) => {\n          // Horizontally filter rows through each column\n          for (let i = 0; i < filterableIds.length; i++) {\n            if (row.columnFilters[filterableIds[i]!] === false) {\n              return false\n            }\n          }\n          return true\n        }\n\n        // Filter final rows using all of the active filters\n        return filterRows(rowModel.rows, filterRowsImpl, table)\n      },\n      getMemoOptions(table.options, 'debugTable', 'getFilteredRowModel', () =>\n        table._autoResetPageIndex()\n      )\n    )\n}\n", "import { createRow } from '../core/row'\nimport { Table, Row, RowModel, RowData } from '../types'\nimport { flattenBy, getMemoOptions, memo } from '../utils'\n\nexport function getGroupedRowModel<TData extends RowData>(): (\n  table: Table<TData>\n) => () => RowModel<TData> {\n  return table =>\n    memo(\n      () => [table.getState().grouping, table.getPreGroupedRowModel()],\n      (grouping, rowModel) => {\n        if (!rowModel.rows.length || !grouping.length) {\n          return rowModel\n        }\n\n        // Filter the grouping list down to columns that exist\n        const existingGrouping = grouping.filter(columnId =>\n          table.getColumn(columnId)\n        )\n\n        const groupedFlatRows: Row<TData>[] = []\n        const groupedRowsById: Record<string, Row<TData>> = {}\n        // const onlyGroupedFlatRows: Row[] = [];\n        // const onlyGroupedRowsById: Record<RowId, Row> = {};\n        // const nonGroupedFlatRows: Row[] = [];\n        // const nonGroupedRowsById: Record<RowId, Row> = {};\n\n        // Recursively group the data\n        const groupUpRecursively = (\n          rows: Row<TData>[],\n          depth = 0,\n          parentId?: string\n        ) => {\n          // Grouping depth has been been met\n          // Stop grouping and simply rewrite thd depth and row relationships\n          if (depth >= existingGrouping.length) {\n            return rows.map(row => {\n              row.depth = depth\n\n              groupedFlatRows.push(row)\n              groupedRowsById[row.id] = row\n\n              if (row.subRows) {\n                row.subRows = groupUpRecursively(row.subRows, depth + 1, row.id)\n              }\n\n              return row\n            })\n          }\n\n          const columnId: string = existingGrouping[depth]!\n\n          // Group the rows together for this level\n          const rowGroupsMap = groupBy(rows, columnId)\n\n          // Peform aggregations for each group\n          const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map(\n            ([groupingValue, groupedRows], index) => {\n              let id = `${columnId}:${groupingValue}`\n              id = parentId ? `${parentId}>${id}` : id\n\n              // First, Recurse to group sub rows before aggregation\n              const subRows = groupUpRecursively(groupedRows, depth + 1, id)\n\n              // Flatten the leaf rows of the rows in this group\n              const leafRows = depth\n                ? flattenBy(groupedRows, row => row.subRows)\n                : groupedRows\n\n              const row = createRow(\n                table,\n                id,\n                leafRows[0]!.original,\n                index,\n                depth,\n                undefined,\n                parentId\n              )\n\n              Object.assign(row, {\n                groupingColumnId: columnId,\n                groupingValue,\n                subRows,\n                leafRows,\n                getValue: (columnId: string) => {\n                  // Don't aggregate columns that are in the grouping\n                  if (existingGrouping.includes(columnId)) {\n                    if (row._valuesCache.hasOwnProperty(columnId)) {\n                      return row._valuesCache[columnId]\n                    }\n\n                    if (groupedRows[0]) {\n                      row._valuesCache[columnId] =\n                        groupedRows[0].getValue(columnId) ?? undefined\n                    }\n\n                    return row._valuesCache[columnId]\n                  }\n\n                  if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n                    return row._groupingValuesCache[columnId]\n                  }\n\n                  // Aggregate the values\n                  const column = table.getColumn(columnId)\n                  const aggregateFn = column?.getAggregationFn()\n\n                  if (aggregateFn) {\n                    row._groupingValuesCache[columnId] = aggregateFn(\n                      columnId,\n                      leafRows,\n                      groupedRows\n                    )\n\n                    return row._groupingValuesCache[columnId]\n                  }\n                },\n              })\n\n              subRows.forEach(subRow => {\n                groupedFlatRows.push(subRow)\n                groupedRowsById[subRow.id] = subRow\n                // if (subRow.getIsGrouped?.()) {\n                //   onlyGroupedFlatRows.push(subRow);\n                //   onlyGroupedRowsById[subRow.id] = subRow;\n                // } else {\n                //   nonGroupedFlatRows.push(subRow);\n                //   nonGroupedRowsById[subRow.id] = subRow;\n                // }\n              })\n\n              return row\n            }\n          )\n\n          return aggregatedGroupedRows\n        }\n\n        const groupedRows = groupUpRecursively(rowModel.rows, 0)\n\n        groupedRows.forEach(subRow => {\n          groupedFlatRows.push(subRow)\n          groupedRowsById[subRow.id] = subRow\n          // if (subRow.getIsGrouped?.()) {\n          //   onlyGroupedFlatRows.push(subRow);\n          //   onlyGroupedRowsById[subRow.id] = subRow;\n          // } else {\n          //   nonGroupedFlatRows.push(subRow);\n          //   nonGroupedRowsById[subRow.id] = subRow;\n          // }\n        })\n\n        return {\n          rows: groupedRows,\n          flatRows: groupedFlatRows,\n          rowsById: groupedRowsById,\n        }\n      },\n      getMemoOptions(table.options, 'debugTable', 'getGroupedRowModel', () => {\n        table._queue(() => {\n          table._autoResetExpanded()\n          table._autoResetPageIndex()\n        })\n      })\n    )\n}\n\nfunction groupBy<TData extends RowData>(rows: Row<TData>[], columnId: string) {\n  const groupMap = new Map<any, Row<TData>[]>()\n\n  return rows.reduce((map, row) => {\n    const resKey = `${row.getGroupingValue(columnId)}`\n    const previous = map.get(resKey)\n    if (!previous) {\n      map.set(resKey, [row])\n    } else {\n      previous.push(row)\n    }\n    return map\n  }, groupMap)\n}\n", "import { Table, RowModel, Row, RowData } from '../types'\nimport { getMemoOptions, memo } from '../utils'\nimport { expandRows } from './getExpandedRowModel'\n\nexport function getPaginationRowModel<TData extends RowData>(opts?: {\n  initialSync: boolean\n}): (table: Table<TData>) => () => RowModel<TData> {\n  return table =>\n    memo(\n      () => [\n        table.getState().pagination,\n        table.getPrePaginationRowModel(),\n        table.options.paginateExpandedRows\n          ? undefined\n          : table.getState().expanded,\n      ],\n      (pagination, rowModel) => {\n        if (!rowModel.rows.length) {\n          return rowModel\n        }\n\n        const { pageSize, pageIndex } = pagination\n        let { rows, flatRows, rowsById } = rowModel\n        const pageStart = pageSize * pageIndex\n        const pageEnd = pageStart + pageSize\n\n        rows = rows.slice(pageStart, pageEnd)\n\n        let paginatedRowModel: RowModel<TData>\n\n        if (!table.options.paginateExpandedRows) {\n          paginatedRowModel = expandRows({\n            rows,\n            flatRows,\n            rowsById,\n          })\n        } else {\n          paginatedRowModel = {\n            rows,\n            flatRows,\n            rowsById,\n          }\n        }\n\n        paginatedRowModel.flatRows = []\n\n        const handleRow = (row: Row<TData>) => {\n          paginatedRowModel.flatRows.push(row)\n          if (row.subRows.length) {\n            row.subRows.forEach(handleRow)\n          }\n        }\n\n        paginatedRowModel.rows.forEach(handleRow)\n\n        return paginatedRowModel\n      },\n      getMemoOptions(table.options, 'debugTable', 'getPaginationRowModel')\n    )\n}\n", "import { Table, Row, RowModel, RowData } from '../types'\nimport { SortingFn } from '../features/RowSorting'\nimport { getMemoOptions, memo } from '../utils'\n\nexport function getSortedRowModel<TData extends RowData>(): (\n  table: Table<TData>\n) => () => RowModel<TData> {\n  return table =>\n    memo(\n      () => [table.getState().sorting, table.getPreSortedRowModel()],\n      (sorting, rowModel) => {\n        if (!rowModel.rows.length || !sorting?.length) {\n          return rowModel\n        }\n\n        const sortingState = table.getState().sorting\n\n        const sortedFlatRows: Row<TData>[] = []\n\n        // Filter out sortings that correspond to non existing columns\n        const availableSorting = sortingState.filter(sort =>\n          table.getColumn(sort.id)?.getCanSort()\n        )\n\n        const columnInfoById: Record<\n          string,\n          {\n            sortUndefined?: false | -1 | 1 | 'first' | 'last'\n            invertSorting?: boolean\n            sortingFn: SortingFn<TData>\n          }\n        > = {}\n\n        availableSorting.forEach(sortEntry => {\n          const column = table.getColumn(sortEntry.id)\n          if (!column) return\n\n          columnInfoById[sortEntry.id] = {\n            sortUndefined: column.columnDef.sortUndefined,\n            invertSorting: column.columnDef.invertSorting,\n            sortingFn: column.getSortingFn(),\n          }\n        })\n\n        const sortData = (rows: Row<TData>[]) => {\n          // This will also perform a stable sorting using the row index\n          // if needed.\n          const sortedData = rows.map(row => ({ ...row }))\n\n          sortedData.sort((rowA, rowB) => {\n            for (let i = 0; i < availableSorting.length; i += 1) {\n              const sortEntry = availableSorting[i]!\n              const columnInfo = columnInfoById[sortEntry.id]!\n              const sortUndefined = columnInfo.sortUndefined\n              const isDesc = sortEntry?.desc ?? false\n\n              let sortInt = 0\n\n              // All sorting ints should always return in ascending order\n              if (sortUndefined) {\n                const aValue = rowA.getValue(sortEntry.id)\n                const bValue = rowB.getValue(sortEntry.id)\n\n                const aUndefined = aValue === undefined\n                const bUndefined = bValue === undefined\n\n                if (aUndefined || bUndefined) {\n                  if (sortUndefined === 'first') return aUndefined ? -1 : 1\n                  if (sortUndefined === 'last') return aUndefined ? 1 : -1\n                  sortInt =\n                    aUndefined && bUndefined\n                      ? 0\n                      : aUndefined\n                        ? sortUndefined\n                        : -sortUndefined\n                }\n              }\n\n              if (sortInt === 0) {\n                sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id)\n              }\n\n              // If sorting is non-zero, take care of desc and inversion\n              if (sortInt !== 0) {\n                if (isDesc) {\n                  sortInt *= -1\n                }\n\n                if (columnInfo.invertSorting) {\n                  sortInt *= -1\n                }\n\n                return sortInt\n              }\n            }\n\n            return rowA.index - rowB.index\n          })\n\n          // If there are sub-rows, sort them\n          sortedData.forEach(row => {\n            sortedFlatRows.push(row)\n            if (row.subRows?.length) {\n              row.subRows = sortData(row.subRows)\n            }\n          })\n\n          return sortedData\n        }\n\n        return {\n          rows: sortData(rowModel.rows),\n          flatRows: sortedFlatRows,\n          rowsById: rowModel.rowsById,\n        }\n      },\n      getMemoOptions(table.options, 'debugTable', 'getSortedRowModel', () =>\n        table._autoResetPageIndex()\n      )\n    )\n}\n", "import * as React from 'react'\nexport * from '@tanstack/table-core'\n\nimport {\n  TableOptions,\n  TableOptionsResolved,\n  RowData,\n  createTable,\n} from '@tanstack/table-core'\n\nexport type Renderable<TProps> = React.ReactNode | React.ComponentType<TProps>\n\n//\n\n/**\n * If rendering headers, cells, or footers with custom markup, use flexRender instead of `cell.getValue()` or `cell.renderValue()`.\n */\nexport function flexRender<TProps extends object>(\n  Comp: Renderable<TProps>,\n  props: TProps\n): React.ReactNode | JSX.Element {\n  return !Comp ? null : isReactComponent<TProps>(Comp) ? (\n    <Comp {...props} />\n  ) : (\n    Comp\n  )\n}\n\nfunction isReactComponent<TProps>(\n  component: unknown\n): component is React.ComponentType<TProps> {\n  return (\n    isClassComponent(component) ||\n    typeof component === 'function' ||\n    isExoticComponent(component)\n  )\n}\n\nfunction isClassComponent(component: any) {\n  return (\n    typeof component === 'function' &&\n    (() => {\n      const proto = Object.getPrototypeOf(component)\n      return proto.prototype && proto.prototype.isReactComponent\n    })()\n  )\n}\n\nfunction isExoticComponent(component: any) {\n  return (\n    typeof component === 'object' &&\n    typeof component.$$typeof === 'symbol' &&\n    ['react.memo', 'react.forward_ref'].includes(component.$$typeof.description)\n  )\n}\n\nexport function useReactTable<TData extends RowData>(\n  options: TableOptions<TData>\n) {\n  // Compose in the generic options to the user options\n  const resolvedOptions: TableOptionsResolved<TData> = {\n    state: {}, // Dummy state\n    onStateChange: () => {}, // noop\n    renderFallbackValue: null,\n    ...options,\n  }\n\n  // Create a new table and store it in state\n  const [tableRef] = React.useState(() => ({\n    current: createTable<TData>(resolvedOptions),\n  }))\n\n  // By default, manage table state here using the table's initial state\n  const [state, setState] = React.useState(() => tableRef.current.initialState)\n\n  // Compose the default state above with any user state. This will allow the user\n  // to only control a subset of the state if desired.\n  tableRef.current.setOptions(prev => ({\n    ...prev,\n    ...options,\n    state: {\n      ...state,\n      ...options.state,\n    },\n    // Similarly, we'll maintain both our internal state and any user-provided\n    // state.\n    onStateChange: updater => {\n      setState(updater)\n      options.onStateChange?.(updater)\n    },\n  }))\n\n  return tableRef.current\n}\n", "export type NoInfer<A extends any> = [A][A extends any ? 0 : never]\n\nexport type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\n\nexport function memo<TDeps extends ReadonlyArray<any>, TResult>(\n  getDeps: () => [...TDeps],\n  fn: (...args: NoInfer<[...TDeps]>) => TResult,\n  opts: {\n    key: false | string\n    debug?: () => any\n    onChange?: (result: TResult) => void\n    initialDeps?: TDeps\n  },\n) {\n  let deps = opts.initialDeps ?? []\n  let result: TResult | undefined\n\n  return (): TResult => {\n    let depTime: number\n    if (opts.key && opts.debug?.()) depTime = Date.now()\n\n    const newDeps = getDeps()\n\n    const depsChanged =\n      newDeps.length !== deps.length ||\n      newDeps.some((dep: any, index: number) => deps[index] !== dep)\n\n    if (!depsChanged) {\n      return result!\n    }\n\n    deps = newDeps\n\n    let resultTime: number\n    if (opts.key && opts.debug?.()) resultTime = Date.now()\n\n    result = fn(...newDeps)\n\n    if (opts.key && opts.debug?.()) {\n      const depEndTime = Math.round((Date.now() - depTime!) * 100) / 100\n      const resultEndTime = Math.round((Date.now() - resultTime!) * 100) / 100\n      const resultFpsPercentage = resultEndTime / 16\n\n      const pad = (str: number | string, num: number) => {\n        str = String(str)\n        while (str.length < num) {\n          str = ' ' + str\n        }\n        return str\n      }\n\n      console.info(\n        `%c ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n              0,\n              Math.min(120 - 120 * resultFpsPercentage, 120),\n            )}deg 100% 31%);`,\n        opts?.key,\n      )\n    }\n\n    opts?.onChange?.(result)\n\n    return result\n  }\n}\n\nexport function notUndefined<T>(value: T | undefined, msg?: string): T {\n  if (value === undefined) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : ''}`)\n  } else {\n    return value\n  }\n}\n\nexport const approxEqual = (a: number, b: number) => Math.abs(a - b) < 1\n\nexport const debounce = (\n  targetWindow: Window & typeof globalThis,\n  fn: Function,\n  ms: number,\n) => {\n  let timeoutId: number\n  return function (this: any, ...args: Array<any>) {\n    targetWindow.clearTimeout(timeoutId)\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms)\n  }\n}\n", "import { approxEqual, debounce, memo, notUndefined } from './utils'\n\nexport * from './utils'\n\n//\n\ntype ScrollDirection = 'forward' | 'backward'\n\ntype ScrollAlignment = 'start' | 'center' | 'end' | 'auto'\n\ntype ScrollBehavior = 'auto' | 'smooth'\n\nexport interface ScrollToOptions {\n  align?: ScrollAlignment\n  behavior?: ScrollBehavior\n}\n\ntype ScrollToOffsetOptions = ScrollToOptions\n\ntype ScrollToIndexOptions = ScrollToOptions\n\nexport interface Range {\n  startIndex: number\n  endIndex: number\n  overscan: number\n  count: number\n}\n\ntype Key = number | string\n\nexport interface VirtualItem<TItemElement extends Element> {\n  key: Key\n  index: number\n  start: number\n  end: number\n  size: number\n  lane: number\n  measureElement: (node: TItemElement | null | undefined) => void\n}\n\nexport interface Rect {\n  width: number\n  height: number\n}\n\n//\n\nexport const defaultKeyExtractor = (index: number) => index\n\nexport const defaultRangeExtractor = (range: Range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0)\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\nexport const observeElementRect = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  const handler = (rect: Rect) => {\n    const { width, height } = rect\n    cb({ width: Math.round(width), height: Math.round(height) })\n  }\n\n  handler(element.getBoundingClientRect())\n\n  if (!targetWindow.ResizeObserver) {\n    return () => {}\n  }\n\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const entry = entries[0]\n    if (entry?.borderBoxSize) {\n      const box = entry.borderBoxSize[0]\n      if (box) {\n        handler({ width: box.inlineSize, height: box.blockSize })\n        return\n      }\n    }\n    handler(element.getBoundingClientRect())\n  })\n\n  observer.observe(element, { box: 'border-box' })\n\n  return () => {\n    observer.unobserve(element)\n  }\n}\n\nconst addEventListenerOptions = {\n  passive: true,\n}\n\nexport const observeWindowRect = (\n  instance: Virtualizer<Window, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight })\n  }\n  handler()\n\n  element.addEventListener('resize', handler, addEventListenerOptions)\n\n  return () => {\n    element.removeEventListener('resize', handler)\n  }\n}\n\nconst supportsScrollend =\n  typeof window == 'undefined' ? true : 'onscrollend' in window\n\nexport const observeElementOffset = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: (offset: number, isScrolling: boolean) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  let offset = 0\n  const fallback = supportsScrollend\n    ? () => undefined\n    : debounce(\n        targetWindow,\n        () => {\n          cb(offset, false)\n        },\n        instance.options.isScrollingResetDelay,\n      )\n\n  const createHandler = (isScrolling: boolean) => () => {\n    offset = element[instance.options.horizontal ? 'scrollLeft' : 'scrollTop']\n    fallback()\n    cb(offset, isScrolling)\n  }\n  const handler = createHandler(true)\n  const endHandler = createHandler(false)\n  endHandler()\n\n  element.addEventListener('scroll', handler, addEventListenerOptions)\n  element.addEventListener('scrollend', endHandler, addEventListenerOptions)\n\n  return () => {\n    element.removeEventListener('scroll', handler)\n    element.removeEventListener('scrollend', endHandler)\n  }\n}\n\nexport const observeWindowOffset = (\n  instance: Virtualizer<Window, any>,\n  cb: (offset: number, isScrolling: boolean) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  let offset = 0\n  const fallback = supportsScrollend\n    ? () => undefined\n    : debounce(\n        targetWindow,\n        () => {\n          cb(offset, false)\n        },\n        instance.options.isScrollingResetDelay,\n      )\n\n  const createHandler = (isScrolling: boolean) => () => {\n    offset = element[instance.options.horizontal ? 'scrollX' : 'scrollY']\n    fallback()\n    cb(offset, isScrolling)\n  }\n  const handler = createHandler(true)\n  const endHandler = createHandler(false)\n  endHandler()\n\n  element.addEventListener('scroll', handler, addEventListenerOptions)\n  element.addEventListener('scrollend', endHandler, addEventListenerOptions)\n\n  return () => {\n    element.removeEventListener('scroll', handler)\n    element.removeEventListener('scrollend', endHandler)\n  }\n}\n\nexport const measureElement = <TItemElement extends Element>(\n  element: TItemElement,\n  entry: ResizeObserverEntry | undefined,\n  instance: Virtualizer<any, TItemElement>,\n) => {\n  if (entry?.borderBoxSize) {\n    const box = entry.borderBoxSize[0]\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? 'inlineSize' : 'blockSize'],\n      )\n      return size\n    }\n  }\n  return Math.round(\n    element.getBoundingClientRect()[\n      instance.options.horizontal ? 'width' : 'height'\n    ],\n  )\n}\n\nexport const windowScroll = <T extends Window>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport const elementScroll = <T extends Element>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport interface VirtualizerOptions<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  // Required from the user\n  count: number\n  getScrollElement: () => TScrollElement | null\n  estimateSize: (index: number) => number\n\n  // Required from the framework adapter (but can be overridden)\n  scrollToFn: (\n    offset: number,\n    options: { adjustments?: number; behavior?: ScrollBehavior },\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => void\n  observeElementRect: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: (rect: Rect) => void,\n  ) => void | (() => void)\n  observeElementOffset: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: (offset: number, isScrolling: boolean) => void,\n  ) => void | (() => void)\n\n  // Optional\n  debug?: any\n  initialRect?: Rect\n  onChange?: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    sync: boolean,\n  ) => void\n  measureElement?: (\n    element: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => number\n  overscan?: number\n  horizontal?: boolean\n  paddingStart?: number\n  paddingEnd?: number\n  scrollPaddingStart?: number\n  scrollPaddingEnd?: number\n  initialOffset?: number | (() => number)\n  getItemKey?: (index: number) => Key\n  rangeExtractor?: (range: Range) => Array<number>\n  scrollMargin?: number\n  gap?: number\n  indexAttribute?: string\n  initialMeasurementsCache?: Array<VirtualItem<TItemElement>>\n  lanes?: number\n  isScrollingResetDelay?: number\n  enabled?: boolean\n}\n\nexport class Virtualizer<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  private unsubs: Array<void | (() => void)> = []\n  options!: Required<VirtualizerOptions<TScrollElement, TItemElement>>\n  scrollElement: TScrollElement | null = null\n  targetWindow: (Window & typeof globalThis) | null = null\n  isScrolling = false\n  private scrollToIndexTimeoutId: number | null = null\n  measurementsCache: Array<VirtualItem<TItemElement>> = []\n  private itemSizeCache = new Map<Key, number>()\n  private pendingMeasuredCacheIndexes: Array<number> = []\n  scrollRect: Rect | null = null\n  scrollOffset: number | null = null\n  scrollDirection: ScrollDirection | null = null\n  private scrollAdjustments = 0\n  shouldAdjustScrollPositionOnItemSizeChange:\n    | undefined\n    | ((\n        item: VirtualItem<TItemElement>,\n        delta: number,\n        instance: Virtualizer<TScrollElement, TItemElement>,\n      ) => boolean)\n  elementsCache = new Map<Key, TItemElement>()\n  private observer = (() => {\n    let _ro: ResizeObserver | null = null\n\n    const get = () => {\n      if (_ro) {\n        return _ro\n      }\n\n      if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n        return null\n      }\n\n      return (_ro = new this.targetWindow.ResizeObserver((entries) => {\n        entries.forEach((entry) => {\n          this._measureElement(entry.target as TItemElement, entry)\n        })\n      }))\n    }\n\n    return {\n      disconnect: () => get()?.disconnect(),\n      observe: (target: Element) =>\n        get()?.observe(target, { box: 'border-box' }),\n      unobserve: (target: Element) => get()?.unobserve(target),\n    }\n  })()\n  range: { startIndex: number; endIndex: number } | null = null\n\n  constructor(opts: VirtualizerOptions<TScrollElement, TItemElement>) {\n    this.setOptions(opts)\n  }\n\n  setOptions = (opts: VirtualizerOptions<TScrollElement, TItemElement>) => {\n    Object.entries(opts).forEach(([key, value]) => {\n      if (typeof value === 'undefined') delete (opts as any)[key]\n    })\n\n    this.options = {\n      debug: false,\n      initialOffset: 0,\n      overscan: 1,\n      paddingStart: 0,\n      paddingEnd: 0,\n      scrollPaddingStart: 0,\n      scrollPaddingEnd: 0,\n      horizontal: false,\n      getItemKey: defaultKeyExtractor,\n      rangeExtractor: defaultRangeExtractor,\n      onChange: () => {},\n      measureElement,\n      initialRect: { width: 0, height: 0 },\n      scrollMargin: 0,\n      gap: 0,\n      indexAttribute: 'data-index',\n      initialMeasurementsCache: [],\n      lanes: 1,\n      isScrollingResetDelay: 150,\n      enabled: true,\n      ...opts,\n    }\n  }\n\n  private notify = (force: boolean, sync: boolean) => {\n    const { startIndex, endIndex } = this.range ?? {\n      startIndex: undefined,\n      endIndex: undefined,\n    }\n    const range = this.calculateRange()\n\n    if (\n      force ||\n      startIndex !== range?.startIndex ||\n      endIndex !== range?.endIndex\n    ) {\n      this.options.onChange?.(this, sync)\n    }\n  }\n\n  private cleanup = () => {\n    this.unsubs.filter(Boolean).forEach((d) => d!())\n    this.unsubs = []\n    this.scrollElement = null\n    this.targetWindow = null\n    this.observer.disconnect()\n    this.elementsCache.clear()\n  }\n\n  _didMount = () => {\n    return () => {\n      this.cleanup()\n    }\n  }\n\n  _willUpdate = () => {\n    const scrollElement = this.options.enabled\n      ? this.options.getScrollElement()\n      : null\n\n    if (this.scrollElement !== scrollElement) {\n      this.cleanup()\n\n      if (!scrollElement) {\n        this.notify(false, false)\n        return\n      }\n\n      this.scrollElement = scrollElement\n\n      if (this.scrollElement && 'ownerDocument' in this.scrollElement) {\n        this.targetWindow = this.scrollElement.ownerDocument.defaultView\n      } else {\n        this.targetWindow = this.scrollElement?.window ?? null\n      }\n\n      this._scrollToOffset(this.getScrollOffset(), {\n        adjustments: undefined,\n        behavior: undefined,\n      })\n\n      this.unsubs.push(\n        this.options.observeElementRect(this, (rect) => {\n          this.scrollRect = rect\n          this.notify(false, false)\n        }),\n      )\n\n      this.unsubs.push(\n        this.options.observeElementOffset(this, (offset, isScrolling) => {\n          this.scrollAdjustments = 0\n          this.scrollDirection = isScrolling\n            ? this.getScrollOffset() < offset\n              ? 'forward'\n              : 'backward'\n            : null\n          this.scrollOffset = offset\n\n          const prevIsScrolling = this.isScrolling\n          this.isScrolling = isScrolling\n\n          this.notify(prevIsScrolling !== isScrolling, isScrolling)\n        }),\n      )\n    }\n  }\n\n  private getSize = () => {\n    if (!this.options.enabled) {\n      this.scrollRect = null\n      return 0\n    }\n\n    this.scrollRect = this.scrollRect ?? this.options.initialRect\n\n    return this.scrollRect[this.options.horizontal ? 'width' : 'height']\n  }\n\n  private getScrollOffset = () => {\n    if (!this.options.enabled) {\n      this.scrollOffset = null\n      return 0\n    }\n\n    this.scrollOffset =\n      this.scrollOffset ??\n      (typeof this.options.initialOffset === 'function'\n        ? this.options.initialOffset()\n        : this.options.initialOffset)\n\n    return this.scrollOffset\n  }\n\n  private getFurthestMeasurement = (\n    measurements: Array<VirtualItem<TItemElement>>,\n    index: number,\n  ) => {\n    const furthestMeasurementsFound = new Map<number, true>()\n    const furthestMeasurements = new Map<number, VirtualItem<TItemElement>>()\n    for (let m = index - 1; m >= 0; m--) {\n      const measurement = measurements[m]!\n\n      if (furthestMeasurementsFound.has(measurement.lane)) {\n        continue\n      }\n\n      const previousFurthestMeasurement = furthestMeasurements.get(\n        measurement.lane,\n      )\n      if (\n        previousFurthestMeasurement == null ||\n        measurement.end > previousFurthestMeasurement.end\n      ) {\n        furthestMeasurements.set(measurement.lane, measurement)\n      } else if (measurement.end < previousFurthestMeasurement.end) {\n        furthestMeasurementsFound.set(measurement.lane, true)\n      }\n\n      if (furthestMeasurementsFound.size === this.options.lanes) {\n        break\n      }\n    }\n\n    return furthestMeasurements.size === this.options.lanes\n      ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n          if (a.end === b.end) {\n            return a.index - b.index\n          }\n\n          return a.end - b.end\n        })[0]\n      : undefined\n  }\n\n  private getMeasurementOptions = memo(\n    () => [\n      this.options.count,\n      this.options.paddingStart,\n      this.options.scrollMargin,\n      this.options.getItemKey,\n      this.options.enabled,\n    ],\n    (count, paddingStart, scrollMargin, getItemKey, enabled) => {\n      this.pendingMeasuredCacheIndexes = []\n      return {\n        count,\n        paddingStart,\n        scrollMargin,\n        getItemKey,\n        enabled,\n      }\n    },\n    {\n      key: false,\n    },\n  )\n\n  private getMeasurements = memo(\n    () => [this.getMeasurementOptions(), this.itemSizeCache],\n    (\n      { count, paddingStart, scrollMargin, getItemKey, enabled },\n      itemSizeCache,\n    ) => {\n      if (!enabled) {\n        this.measurementsCache = []\n        this.itemSizeCache.clear()\n        return []\n      }\n\n      if (this.measurementsCache.length === 0) {\n        this.measurementsCache = this.options.initialMeasurementsCache\n        this.measurementsCache.forEach((item) => {\n          this.itemSizeCache.set(item.key, item.size)\n        })\n      }\n\n      const min =\n        this.pendingMeasuredCacheIndexes.length > 0\n          ? Math.min(...this.pendingMeasuredCacheIndexes)\n          : 0\n      this.pendingMeasuredCacheIndexes = []\n\n      const measurements = this.measurementsCache.slice(0, min)\n\n      for (let i = min; i < count; i++) {\n        let measureElement = this.measurementsCache[i]?.measureElement\n\n        if (!measureElement) {\n          measureElement = (node: TItemElement | null | undefined) => {\n            const key = getItemKey(i)\n            const prevNode = this.elementsCache.get(key)\n\n            if (!node) {\n              if (prevNode) {\n                this.observer.unobserve(prevNode)\n                this.elementsCache.delete(key)\n              }\n              return\n            }\n\n            if (prevNode !== node) {\n              if (prevNode) {\n                this.observer.unobserve(prevNode)\n              }\n              this.observer.observe(node)\n              this.elementsCache.set(key, node)\n            }\n\n            if (node.isConnected) {\n              this.resizeItem(\n                i,\n                this.options.measureElement(node, undefined, this),\n              )\n            }\n          }\n        }\n\n        const key = getItemKey(i)\n\n        const furthestMeasurement =\n          this.options.lanes === 1\n            ? measurements[i - 1]\n            : this.getFurthestMeasurement(measurements, i)\n\n        const start = furthestMeasurement\n          ? furthestMeasurement.end + this.options.gap\n          : paddingStart + scrollMargin\n\n        const measuredSize = itemSizeCache.get(key)\n        const size =\n          typeof measuredSize === 'number'\n            ? measuredSize\n            : this.options.estimateSize(i)\n\n        const end = start + size\n\n        const lane = furthestMeasurement\n          ? furthestMeasurement.lane\n          : i % this.options.lanes\n\n        measurements[i] = {\n          index: i,\n          start,\n          size,\n          end,\n          key,\n          lane,\n          measureElement,\n        }\n      }\n\n      this.measurementsCache = measurements\n\n      return measurements\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getMeasurements',\n      debug: () => this.options.debug,\n    },\n  )\n\n  calculateRange = memo(\n    () => [this.getMeasurements(), this.getSize(), this.getScrollOffset()],\n    (measurements, outerSize, scrollOffset) => {\n      return (this.range =\n        measurements.length > 0 && outerSize > 0\n          ? calculateRange({\n              measurements,\n              outerSize,\n              scrollOffset,\n            })\n          : null)\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'calculateRange',\n      debug: () => this.options.debug,\n    },\n  )\n\n  private getIndexes = memo(\n    () => [\n      this.options.rangeExtractor,\n      this.calculateRange(),\n      this.options.overscan,\n      this.options.count,\n    ],\n    (rangeExtractor, range, overscan, count) => {\n      return range === null\n        ? []\n        : rangeExtractor({\n            startIndex: range.startIndex,\n            endIndex: range.endIndex,\n            overscan,\n            count,\n          })\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug,\n    },\n  )\n\n  indexFromElement = (node: TItemElement) => {\n    const attributeName = this.options.indexAttribute\n    const indexStr = node.getAttribute(attributeName)\n\n    if (!indexStr) {\n      console.warn(\n        `Missing attribute name '${attributeName}={index}' on measured element.`,\n      )\n      return -1\n    }\n\n    return parseInt(indexStr, 10)\n  }\n\n  private _measureElement = (\n    node: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n  ) => {\n    const i = this.indexFromElement(node)\n    const item = this.getMeasurements()[i]\n\n    if (!item || !node.isConnected) {\n      this.elementsCache.forEach((cached, key) => {\n        if (cached === node) {\n          this.observer.unobserve(node)\n          this.elementsCache.delete(key)\n        }\n      })\n      return\n    }\n\n    const prevNode = this.elementsCache.get(item.key)\n\n    if (prevNode !== node) {\n      if (prevNode) {\n        this.observer.unobserve(prevNode)\n      }\n      this.observer.observe(node)\n      this.elementsCache.set(item.key, node)\n    }\n\n    this.resizeItem(i, this.options.measureElement(node, entry, this))\n  }\n\n  resizeItem = (index: number, size: number) => {\n    const item = this.getMeasurements()[index]\n    if (!item) {\n      return\n    }\n    const itemSize = this.itemSizeCache.get(item.key) ?? item.size\n    const delta = size - itemSize\n\n    if (delta !== 0) {\n      if (\n        this.shouldAdjustScrollPositionOnItemSizeChange !== undefined\n          ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this)\n          : item.start < this.getScrollOffset() + this.scrollAdjustments\n      ) {\n        if (process.env.NODE_ENV !== 'production' && this.options.debug) {\n          console.info('correction', delta)\n        }\n\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: (this.scrollAdjustments += delta),\n          behavior: undefined,\n        })\n      }\n\n      this.pendingMeasuredCacheIndexes.push(item.index)\n      this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size))\n\n      this.notify(true, false)\n    }\n  }\n\n  measureElement = (node: TItemElement | null | undefined) => {\n    if (!node) {\n      return\n    }\n\n    this._measureElement(node, undefined)\n  }\n\n  getVirtualItems = memo(\n    () => [this.getIndexes(), this.getMeasurements()],\n    (indexes, measurements) => {\n      const virtualItems: Array<VirtualItem<TItemElement>> = []\n\n      for (let k = 0, len = indexes.length; k < len; k++) {\n        const i = indexes[k]!\n        const measurement = measurements[i]!\n\n        virtualItems.push(measurement)\n      }\n\n      return virtualItems\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug,\n    },\n  )\n\n  getVirtualItemForOffset = (offset: number) => {\n    const measurements = this.getMeasurements()\n    if (measurements.length === 0) {\n      return undefined\n    }\n    return notUndefined(\n      measurements[\n        findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index: number) => notUndefined(measurements[index]).start,\n          offset,\n        )\n      ],\n    )\n  }\n\n  getOffsetForAlignment = (toOffset: number, align: ScrollAlignment) => {\n    const size = this.getSize()\n    const scrollOffset = this.getScrollOffset()\n\n    if (align === 'auto') {\n      if (toOffset <= scrollOffset) {\n        align = 'start'\n      } else if (toOffset >= scrollOffset + size) {\n        align = 'end'\n      } else {\n        align = 'start'\n      }\n    }\n\n    if (align === 'start') {\n      toOffset = toOffset\n    } else if (align === 'end') {\n      toOffset = toOffset - size\n    } else if (align === 'center') {\n      toOffset = toOffset - size / 2\n    }\n\n    const scrollSizeProp = this.options.horizontal\n      ? 'scrollWidth'\n      : 'scrollHeight'\n    const scrollSize = this.scrollElement\n      ? 'document' in this.scrollElement\n        ? this.scrollElement.document.documentElement[scrollSizeProp]\n        : this.scrollElement[scrollSizeProp]\n      : 0\n\n    const maxOffset = scrollSize - size\n\n    return Math.max(Math.min(maxOffset, toOffset), 0)\n  }\n\n  getOffsetForIndex = (index: number, align: ScrollAlignment = 'auto') => {\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n\n    const item = this.getMeasurements()[index]\n    if (!item) {\n      return undefined\n    }\n\n    const size = this.getSize()\n    const scrollOffset = this.getScrollOffset()\n\n    if (align === 'auto') {\n      if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n        align = 'end'\n      } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n        align = 'start'\n      } else {\n        return [scrollOffset, align] as const\n      }\n    }\n\n    const toOffset =\n      align === 'end'\n        ? item.end + this.options.scrollPaddingEnd\n        : item.start - this.options.scrollPaddingStart\n\n    return [this.getOffsetForAlignment(toOffset, align), align] as const\n  }\n\n  private isDynamicMode = () => this.elementsCache.size > 0\n\n  private cancelScrollToIndex = () => {\n    if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {\n      this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId)\n      this.scrollToIndexTimeoutId = null\n    }\n  }\n\n  scrollToOffset = (\n    toOffset: number,\n    { align = 'start', behavior }: ScrollToOffsetOptions = {},\n  ) => {\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  scrollToIndex = (\n    index: number,\n    { align: initialAlign = 'auto', behavior }: ScrollToIndexOptions = {},\n  ) => {\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    const offsetAndAlign = this.getOffsetForIndex(index, initialAlign)\n    if (!offsetAndAlign) return\n\n    const [offset, align] = offsetAndAlign\n\n    this._scrollToOffset(offset, { adjustments: undefined, behavior })\n\n    if (behavior !== 'smooth' && this.isDynamicMode() && this.targetWindow) {\n      this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {\n        this.scrollToIndexTimeoutId = null\n\n        const elementInDOM = this.elementsCache.has(\n          this.options.getItemKey(index),\n        )\n\n        if (elementInDOM) {\n          const [latestOffset] = notUndefined(\n            this.getOffsetForIndex(index, align),\n          )\n\n          if (!approxEqual(latestOffset, this.getScrollOffset())) {\n            this.scrollToIndex(index, { align, behavior })\n          }\n        } else {\n          this.scrollToIndex(index, { align, behavior })\n        }\n      })\n    }\n  }\n\n  scrollBy = (delta: number, { behavior }: ScrollToOffsetOptions = {}) => {\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.getScrollOffset() + delta, {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  getTotalSize = () => {\n    const measurements = this.getMeasurements()\n\n    let end: number\n    // If there are no measurements, set the end to paddingStart\n    if (measurements.length === 0) {\n      end = this.options.paddingStart\n    } else {\n      // If lanes is 1, use the last measurement's end, otherwise find the maximum end value among all measurements\n      end =\n        this.options.lanes === 1\n          ? measurements[measurements.length - 1]?.end ?? 0\n          : Math.max(\n              ...measurements.slice(-this.options.lanes).map((m) => m.end),\n            )\n    }\n\n    return end - this.options.scrollMargin + this.options.paddingEnd\n  }\n\n  private _scrollToOffset = (\n    offset: number,\n    {\n      adjustments,\n      behavior,\n    }: {\n      adjustments: number | undefined\n      behavior: ScrollBehavior | undefined\n    },\n  ) => {\n    this.options.scrollToFn(offset, { behavior, adjustments }, this)\n  }\n\n  measure = () => {\n    this.itemSizeCache = new Map()\n    this.options.onChange?.(this, false)\n  }\n}\n\nconst findNearestBinarySearch = (\n  low: number,\n  high: number,\n  getCurrentValue: (i: number) => number,\n  value: number,\n) => {\n  while (low <= high) {\n    const middle = ((low + high) / 2) | 0\n    const currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange<TItemElement extends Element>({\n  measurements,\n  outerSize,\n  scrollOffset,\n}: {\n  measurements: Array<VirtualItem<TItemElement>>\n  outerSize: number\n  scrollOffset: number\n}) {\n  const count = measurements.length - 1\n  const getOffset = (index: number) => measurements[index]!.start\n\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset)\n  let endIndex = startIndex\n\n  while (\n    endIndex < count &&\n    measurements[endIndex]!.end < scrollOffset + outerSize\n  ) {\n    endIndex++\n  }\n\n  return { startIndex, endIndex }\n}\n", "import * as React from 'react'\nimport { flushSync } from 'react-dom'\nimport {\n  Virtualizer,\n  elementScroll,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  windowScroll,\n} from '@tanstack/virtual-core'\nimport type { PartialKeys, VirtualizerOptions } from '@tanstack/virtual-core'\n\nexport * from '@tanstack/virtual-core'\n\nconst useIsomorphicLayoutEffect =\n  typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nfunction useVirtualizerBase<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n>(\n  options: VirtualizerOptions<TScrollElement, TItemElement>,\n): Virtualizer<TScrollElement, TItemElement> {\n  const rerender = React.useReducer(() => ({}), {})[1]\n\n  const resolvedOptions: VirtualizerOptions<TScrollElement, TItemElement> = {\n    ...options,\n    onChange: (instance, sync) => {\n      if (sync) {\n        flushSync(rerender)\n      } else {\n        rerender()\n      }\n      options.onChange?.(instance, sync)\n    },\n  }\n\n  const [instance] = React.useState(\n    () => new Virtualizer<TScrollElement, TItemElement>(resolvedOptions),\n  )\n\n  instance.setOptions(resolvedOptions)\n\n  React.useEffect(() => {\n    return instance._didMount()\n  }, [])\n\n  useIsomorphicLayoutEffect(() => {\n    return instance._willUpdate()\n  })\n\n  return instance\n}\n\nexport function useVirtualizer<\n  TScrollElement extends Element,\n  TItemElement extends Element,\n>(\n  options: PartialKeys<\n    VirtualizerOptions<TScrollElement, TItemElement>,\n    'observeElementRect' | 'observeElementOffset' | 'scrollToFn'\n  >,\n): Virtualizer<TScrollElement, TItemElement> {\n  return useVirtualizerBase<TScrollElement, TItemElement>({\n    observeElementRect: observeElementRect,\n    observeElementOffset: observeElementOffset,\n    scrollToFn: elementScroll,\n    ...options,\n  })\n}\n\nexport function useWindowVirtualizer<TItemElement extends Element>(\n  options: PartialKeys<\n    VirtualizerOptions<Window, TItemElement>,\n    | 'getScrollElement'\n    | 'observeElementRect'\n    | 'observeElementOffset'\n    | 'scrollToFn'\n  >,\n): Virtualizer<Window, TItemElement> {\n  return useVirtualizerBase<Window, TItemElement>({\n    getScrollElement: () => (typeof document !== 'undefined' ? window : null),\n    observeElementRect: observeWindowRect,\n    observeElementOffset: observeWindowOffset,\n    scrollToFn: windowScroll,\n    initialOffset: () => (typeof document !== 'undefined' ? window.scrollY : 0),\n    ...options,\n  })\n}\n", "import { render, hydrate, unmountComponentAtNode } from 'preact/compat';\n\nexport function createRoot(container) {\n\treturn {\n\t\t// eslint-disable-next-line\n\t\trender: function (children) {\n\t\t\trender(children, container);\n\t\t},\n\t\t// eslint-disable-next-line\n\t\tunmount: function () {\n\t\t\tunmountComponentAtNode(container);\n\t\t}\n\t};\n}\n\nexport function hydrateRoot(container, children) {\n\thydrate(children, container);\n\treturn createRoot(container);\n}\n\nexport default {\n\tcreateRoot,\n\thydrateRoot\n};\n", "// Should be no imports here!\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: unique symbol = Symbol.for(\"immer-nothing\")\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = Symbol.for(\"immer-draftable\")\n\nexport const DRAFT_STATE: unique symbol = Symbol.for(\"immer-state\")\n", "export const errors =\n\tprocess.env.NODE_ENV !== \"production\"\n\t\t? [\n\t\t\t\t// All error codes, starting by 0:\n\t\t\t\tfunction(plugin: string) {\n\t\t\t\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t\t\t\t},\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t\t\t\t},\n\t\t\t\t\"This object has been frozen and should not be mutated\",\n\t\t\t\tfunction(data: any) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\t\t\t\tdata\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t\t\t\t\"Immer forbids circular references\",\n\t\t\t\t\"The first or second argument to `produce` must be a function\",\n\t\t\t\t\"The third argument to `produce` must be a function or undefined\",\n\t\t\t\t\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t\t\t\t\"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'current' expects a draft, got: ${thing}`\n\t\t\t\t},\n\t\t\t\t\"Object.defineProperty() cannot be used on an Immer draft\",\n\t\t\t\t\"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t\t\t\t\"Immer only supports deleting array indices\",\n\t\t\t\t\"Immer only supports setting array indices and the 'length' property\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'original' expects a draft, got: ${thing}`\n\t\t\t\t}\n\t\t\t\t// Note: if more errors are added, the errorOffset in Patches.ts should be increased\n\t\t\t\t// See Patches.ts for additional errors\n\t\t  ]\n\t\t: []\n\nexport function die(error: number, ...args: any[]): never {\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\tconst e = errors[error]\n\t\tconst msg = typeof e === \"function\" ? e.apply(null, args as any) : e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n", "import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\tArchType,\n\tdie\n} from \"../internal\"\n\nexport const getPrototypeOf = Object.getPrototypeOf\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor?.[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(15, value)\n\treturn value[DRAFT_STATE].base_\n}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any) {\n\tif (getArchtype(obj) === ArchType.Object) {\n\t\tObject.entries(obj).forEach(([key, value]) => {\n\t\t\titer(key, value, obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): ArchType {\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_\n\t\t: Array.isArray(thing)\n\t\t? ArchType.Array\n\t\t: isMap(thing)\n\t\t? ArchType.Map\n\t\t: isSet(thing)\n\t\t? ArchType.Set\n\t\t: ArchType.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === ArchType.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === ArchType.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === ArchType.Map) thing.set(propOrOldValue, value)\n\telse if (t === ArchType.Set) {\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any, strict: boolean) {\n\tif (isMap(base)) {\n\t\treturn new Map(base)\n\t}\n\tif (isSet(base)) {\n\t\treturn new Set(base)\n\t}\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\n\tif (!strict && isPlainObject(base)) {\n\t\tif (!getPrototypeOf(base)) {\n\t\t\tconst obj = Object.create(null)\n\t\t\treturn Object.assign(obj, base)\n\t\t}\n\t\treturn {...base}\n\t}\n\n\tconst descriptors = Object.getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = Reflect.ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (_key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\treturn Object.isFrozen(obj)\n}\n", "import {\n\tImmerState,\n\tPatch,\n\tDrafted,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tArchType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(0, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ArchType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ArchType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n", "import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tArchType,\n\tgetPlugin\n} from \"../internal\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (state.type_ === ArchType.Object || state.type_ === ArchType.Array)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n", "import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tArchType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result = state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// To preserve insertion order in all cases we then clear the set\n\t\t// And we let finalizeProperty know it needs to re-add non-draft children back to the target\n\t\tlet resultEach = result\n\t\tlet isSet = false\n\t\tif (state.type_ === ArchType.Set) {\n\t\t\tresultEach = new Set(result)\n\t\t\tresult.clear()\n\t\t\tisSet = true\n\t\t}\n\t\teach(resultEach, (key, childValue) =>\n\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path, isSet)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath,\n\ttargetIsSet?: boolean\n) {\n\tif (process.env.NODE_ENV !== \"production\" && childValue === targetObject)\n\t\tdie(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ArchType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t} else if (targetIsSet) {\n\t\ttargetObject.add(childValue)\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\t// we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects\n\tif (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n", "import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tgetPrototypeOf,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tArchType,\n\tImmerScope\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ArchType.Object\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ArchType.Array\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ArchType.Array : (ArchType.Object as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(value, state))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\t(state.copy_![prop] === value &&\n\t\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t\t(value !== undefined || prop in state.copy_)) ||\n\t\t\t// special case: NaN\n\t\t\t(Number.isNaN(value) && Number.isNaN(state.copy_![prop]))\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\tif (state.copy_) {\n\t\t\tdelete state.copy_[prop]\n\t\t}\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ArchType.Array || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop as any)))\n\t\tdie(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (\n\t\tprocess.env.NODE_ENV !== \"production\" &&\n\t\tprop !== \"length\" &&\n\t\tisNaN(parseInt(prop as any))\n\t)\n\t\tdie(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {\n\tbase_: any\n\tcopy_: any\n\tscope_: ImmerScope\n}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(\n\t\t\tstate.base_,\n\t\t\tstate.scope_.immer_.useStrictShallowCopy_\n\t\t)\n\t}\n}\n", "import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tautoFreeze_: boolean = true\n\tuseStrictShallowCopy_: boolean = false\n\n\tconstructor(config?: {autoFreeze?: boolean; useStrictShallowCopy?: boolean}) {\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t\tif (typeof config?.useStrictShallowCopy === \"boolean\")\n\t\t\tthis.setUseStrictShallowCopy(config!.useStrictShallowCopy)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(1, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => base(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (!state || !state.isManual_) die(9)\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to enable strict shallow copy.\n\t *\n\t * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n\t */\n\tsetUseStrictShallowCopy(value: boolean) {\n\t\tthis.useStrictShallowCopy_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: createProxyProxy(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n", "import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tisFrozen\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(10, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value) || isFrozen(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tif (state) {\n\t\tif (!state.modified_) return state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_)\n\t} else {\n\t\tcopy = shallowCopy(value, true)\n\t}\n\t// recurse\n\teach(copy, (key, childValue) => {\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\tif (state) {\n\t\tstate.finalized_ = false\n\t}\n\treturn copy\n}\n", "import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tProxyArrayState,\n\tMapState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tgetPrototypeOf,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tArchType,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING,\n\terrors\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst errorOffset = 16\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\terrors.push(\n\t\t\t'Sets cannot have \"replace\" patches.',\n\t\t\tfunction(op: string) {\n\t\t\t\treturn \"Unsupported patch operation: \" + op\n\t\t\t},\n\t\t\tfunction(path: string) {\n\t\t\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t\t\t},\n\t\t\t\"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t\t)\n\t}\n\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ArchType.Object:\n\t\t\tcase ArchType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ArchType.Array:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ArchType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tfor (let i = copy_.length - 1; base_.length <= i; --i) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tinversePatches.push({\n\t\t\t\top: REMOVE,\n\t\t\t\tpath\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tlet p = path[i]\n\t\t\t\tif (typeof p !== \"string\" && typeof p !== \"number\") {\n\t\t\t\t\tp = \"\" + p\n\t\t\t\t}\n\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === ArchType.Object || parentType === ArchType.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(errorOffset + 3)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\")\n\t\t\t\t\tdie(errorOffset + 3)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(errorOffset + 2, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\tdie(errorOffset)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(errorOffset + 1, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n", "// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tdie,\n\tArchType,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\tclass DraftMap extends Map {\n\t\t[DRAFT_STATE]: MapState\n\n\t\tconstructor(target: AnyMap, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tset(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tforEach(cb: (value: any, key: any, self: any) => void, thisArg?: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tget(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(value, state)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.entries()\n\t\t}\n\t}\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tclass DraftSet extends Set {\n\t\t[DRAFT_STATE]: SetState\n\t\tconstructor(target: AnySet, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tadd(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tforEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\t}\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n", "import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze,\n\tObjectish\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to enable strict shallow copy.\n *\n * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n */\nexport const setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\n", "import { produce, Draft, nothing, freeze } from \"immer\";\nimport { useState, useReducer, useCallback, useMemo, Dispatch } from \"react\";\n\nexport type DraftFunction<S> = (draft: Draft<S>) => void;\nexport type Updater<S> = (arg: S | DraftFunction<S>) => void;\nexport type ImmerHook<S> = [S, Updater<S>];\n\nexport function useImmer<S = any>(initialValue: S | (() => S)): ImmerHook<S>;\n\nexport function useImmer(initialValue: any) {\n  const [val, updateValue] = useState(() =>\n    freeze(\n      typeof initialValue === \"function\" ? initialValue() : initialValue,\n      true\n    )\n  );\n  return [\n    val,\n    useCallback((updater) => {\n      if (typeof updater === \"function\") updateValue(produce(updater));\n      else updateValue(freeze(updater));\n    }, []),\n  ];\n}\n\n// Provides different overloads of `useImmerReducer` similar to `useReducer` from `@types/react`.\n\nexport type ImmerReducer<S, A> = (\n  draftState: Draft<S>,\n  action: A\n) => void | (S extends undefined ? typeof nothing : S);\n\n/**\n * @deprecated Use `ImmerReducer` instead since there is already a `Reducer` type in `@types/react`.\n */\nexport type Reducer<S = any, A = any> = ImmerReducer<S, A>;\n\nexport function useImmerReducer<S, A, I>(\n  reducer: ImmerReducer<S, A>,\n  initializerArg: S & I,\n  initializer: (arg: S & I) => S\n): [S, Dispatch<A>];\n\nexport function useImmerReducer<S, A, I>(\n  reducer: ImmerReducer<S, A>,\n  initializerArg: I,\n  initializer: (arg: I) => S\n): [S, Dispatch<A>];\n\nexport function useImmerReducer<S, A>(\n  reducer: ImmerReducer<S, A>,\n  initialState: S,\n  initializer?: undefined\n): [S, Dispatch<A>];\n\nexport function useImmerReducer<S, A, I>(\n  reducer: ImmerReducer<S, A>,\n  initializerArg: S & I,\n  initializer?: (arg: S & I) => S\n) {\n  const cachedReducer = useMemo(() => produce(reducer), [reducer]);\n  return useReducer(cachedReducer, initializerArg as any, initializer as any);\n}\n", "// type JobId = string;\n// type UploadUrl = string;\n// type UploadInitValue = { jobId: JobId; uploadUrl: UploadUrl };\n// type UploadEndValue = never;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ResponseValue = any;\n\nexport type OnSuccessRequest = (value: ResponseValue) => void;\nexport type OnErrorRequest = (err: string) => void;\n\n// Websocket messages are normally one-way--i.e. the client passes a\n// message to the server but there is no way for the server to provide\n// a response to that specific message. makeRequest provides a way to\n// do asynchronous RPC over websocket. Each request has a method name\n// and arguments, plus optionally one or more binary blobs can be\n// included as well. The request is tagged with a unique number that\n// the server will use to label the corresponding response.\n//\n// @param method A string that tells the server what logic to run.\n// @param args An array of objects that should also be passed to the\n//   server in JSON-ified form.\n// @param onSuccess A function that will be called back if the server\n//   responds with success. If the server provides a value in the\n//   response, the function will be called with it as the only argument.\n// @param onError A function that will be called back if the server\n//   responds with error, or if the request fails for any other reason.\n//   The parameter to onError will be a string describing the error.\n// @param blobs Optionally, an array of Blob, ArrayBuffer, or string\n//   objects that will be made available to the server as part of the\n//   request. Strings will be encoded using UTF-8.\nexport function makeRequest(\n  method: string,\n  args: unknown[],\n  onSuccess: OnSuccessRequest,\n  onError: OnErrorRequest,\n  blobs: Array<ArrayBuffer | Blob | string> | undefined\n) {\n  window.Shiny.shinyapp!.makeRequest(method, args, onSuccess, onError, blobs);\n}\n\nexport function makeRequestPromise({\n  method,\n  args,\n  blobs,\n}: {\n  method: string;\n  args: unknown[];\n  blobs?: Array<ArrayBuffer | Blob | string> | undefined;\n}) {\n  return new Promise((resolve, reject) => {\n    makeRequest(\n      method,\n      args,\n      (value: ResponseValue) => {\n        resolve(value);\n      },\n      (err: string) => {\n        reject(err);\n      },\n      blobs\n    );\n  });\n}\n", "import { ResponseValue, makeRequestPromise } from \"./request\";\n\nimport { CellStateEnum } from \"./cell\";\nimport { SetCellEditMapAtLoc } from \"./cell-edit-map\";\nimport type { PatchInfo } from \"./types\";\n\nexport type CellPatch = {\n  rowIndex: number;\n  columnIndex: number;\n  value: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n  // prev: unknown;\n};\nexport type CellPatchPy = {\n  row_index: number;\n  column_index: number;\n  value: unknown;\n  // prev: unknown;\n};\n\ntype SetDataFn = (fn: (draft: unknown[][]) => void) => void;\n\nexport function addPatchToData({\n  setData,\n  newPatches,\n  setCellEditMapAtLoc,\n}: {\n  setData: SetDataFn;\n  newPatches: CellPatch[];\n  setCellEditMapAtLoc: SetCellEditMapAtLoc;\n}): void {\n  // Update data\n  setData((draft) => {\n    newPatches.forEach(({ rowIndex, columnIndex, value }) => {\n      draft[rowIndex]![columnIndex] = value;\n    });\n  });\n  // Set the new patches in cell edit map info\n  newPatches.forEach(({ rowIndex, columnIndex, value }) => {\n    setCellEditMapAtLoc(rowIndex, columnIndex, (obj_draft) => {\n      obj_draft.value = value;\n      obj_draft.state = CellStateEnum.EditSuccess;\n      // Remove save_error if it exists\n      obj_draft.errorTitle = undefined;\n    });\n  });\n}\n\nexport function cellPatchPyArrToCellPatchArr(\n  patchesPy: CellPatchPy[]\n): CellPatch[] {\n  const patches: CellPatch[] = patchesPy.map(\n    (patch: CellPatchPy): CellPatch => {\n      return {\n        rowIndex: patch.row_index,\n        columnIndex: patch.column_index,\n        value: patch.value,\n      };\n    }\n  );\n  return patches;\n}\n\nexport function cellPatchArrToCellPatchPyArr(\n  patches: CellPatch[]\n): CellPatchPy[] {\n  const patchesPy: CellPatchPy[] = patches.map((patch) => {\n    return {\n      row_index: patch.rowIndex,\n      column_index: patch.columnIndex,\n      value: patch.value,\n    };\n  });\n  return patchesPy;\n}\n\nexport function updateCellsData({\n  patchInfo,\n  patches,\n  onSuccess,\n  onError,\n  columns,\n  setData,\n  setCellEditMapAtLoc,\n}: {\n  patchInfo: PatchInfo;\n  patches: CellPatch[];\n  onSuccess: (values: CellPatch[]) => void;\n  onError: (err: string) => void;\n  columns: readonly string[];\n  setData: SetDataFn;\n  setCellEditMapAtLoc: SetCellEditMapAtLoc;\n}) {\n  // // Skip page index reset until after next rerender\n  // skipAutoResetPageIndex();\n\n  const patchesPy = cellPatchArrToCellPatchPyArr(patches);\n\n  makeRequestPromise({\n    method: patchInfo.key,\n    args: [\n      // list[CellPatch]\n      patchesPy,\n    ],\n  })\n    .then((newPatchesPy: ResponseValue) => {\n      // Assert type of values is list\n      if (!Array.isArray(newPatchesPy)) {\n        throw new Error(\"Expected a response of a list of patches\");\n      }\n\n      for (const patch of newPatchesPy) {\n        if (\n          !(\"row_index\" in patch && \"column_index\" in patch && \"value\" in patch)\n        ) {\n          throw new Error(\n            \"Expected list of patches containing `row_index`, `column_index`, and `value`\"\n          );\n        }\n      }\n      newPatchesPy = newPatchesPy as CellPatchPy[];\n\n      const newPatches = cellPatchPyArrToCellPatchArr(newPatchesPy);\n\n      // Set the old patches locations back to success state\n      // This may be overkill, but it guarantees that the incoming patches exit the saving state\n      patches.forEach(({ rowIndex, columnIndex, value }) => {\n        setCellEditMapAtLoc(rowIndex, columnIndex, (obj_draft) => {\n          // If the cell is still saving, then set it back to ready.\n          // If not, then something else has changed the cell state, so don't change it.\n          if (obj_draft.state !== CellStateEnum.EditSaving) return;\n\n          obj_draft.state = CellStateEnum.Ready;\n          obj_draft.value = value;\n          obj_draft.errorTitle = undefined;\n        });\n      });\n\n      // Update data and cell edit map with new patches\n      addPatchToData({ setData, newPatches, setCellEditMapAtLoc });\n\n      onSuccess(newPatches);\n    })\n    .catch((err: string) => {\n      patches.forEach(({ rowIndex, columnIndex, value }) => {\n        setCellEditMapAtLoc(rowIndex, columnIndex, (obj_draft) => {\n          obj_draft.value = String(value);\n\n          obj_draft.state = CellStateEnum.EditFailure;\n          obj_draft.errorTitle = String(err);\n        });\n      });\n      onError(err);\n    });\n}\n", "import { ColumnDef, RowModel, flexRender } from \"@tanstack/react-table\";\nimport { Cell } from \"@tanstack/table-core\";\nimport React, {\n  FC,\n  ChangeEvent as ReactChangeEvent,\n  ReactElement,\n  FocusEvent as ReactFocusEvent,\n  KeyboardEvent as ReactKeyboardEvent,\n  MouseEvent as ReactMouseEvent,\n  useCallback,\n  useEffect,\n  useRef,\n} from \"react\";\nimport { CellEdit, SetCellEditMapAtLoc } from \"./cell-edit-map\";\nimport { updateCellsData } from \"./data-update\";\nimport { SelectionSet } from \"./selection\";\nimport { CellStyle } from \"./style-info\";\nimport type { PatchInfo } from \"./types\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype HtmlDep = any;\n\n// States\n// # \u221A Ready\n// # \u221A Editing\n// # \u221A Saving / Disabled\n// # \u221A Error\n// # \u221A Saved\n// # Cancelled (is Ready state?)\n// # New\n// # Added\n// # Removed\nexport const CellStateEnum = {\n  EditSaving: \"EditSaving\",\n  EditSuccess: \"EditSuccess\",\n  EditFailure: \"EditFailure\",\n  Editing: \"Editing\",\n  Ready: \"Ready\",\n} as const;\nexport const CellStateClassEnum = {\n  EditSaving: \"cell-edit-saving\",\n  EditSuccess: \"cell-edit-success\",\n  EditFailure: \"cell-edit-failure\",\n  Editing: \"cell-edit-editing\",\n  Ready: undefined,\n} as const;\nexport type CellState = keyof typeof CellStateEnum;\n\ntype CellHtmlValue = {\n  isShinyHtml: true;\n  obj: { deps?: HtmlDep[]; html: string };\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isShinyHtml = (x: any): x is CellHtmlValue => {\n  return (\n    x !== null && // Note: x === null has `typeof x === \"object\"`\n    typeof x === \"object\" &&\n    Object.prototype.hasOwnProperty.call(x, \"isShinyHtml\") &&\n    x.isShinyHtml === true\n  );\n};\ntype CellValue = string | CellHtmlValue | null;\nconst getCellValueText = (cellValue: CellValue) => {\n  if (cellValue === null) return \"\";\n  if (isShinyHtml(cellValue)) return cellValue.obj.html;\n  return cellValue;\n};\n\ninterface TableBodyCellProps {\n  key: string;\n  rowId: string;\n  containerRef: React.RefObject<HTMLDivElement>;\n  cell: Cell<unknown[], unknown>;\n  patchInfo: PatchInfo;\n  columns: readonly string[];\n  coldefs: readonly ColumnDef<unknown[], unknown>[];\n  rowIndex: number;\n  columnIndex: number;\n  editCellsIsAllowed: boolean;\n  getSortedRowModel: () => RowModel<unknown[]>;\n  setData: (fn: (draft: unknown[][]) => void) => void;\n  cellEditInfo: CellEdit | undefined;\n  cellStyle: CellStyle | undefined;\n  cellClassName: string | undefined;\n  setCellEditMapAtLoc: SetCellEditMapAtLoc;\n  selection: SelectionSet<string, HTMLTableRowElement>;\n}\n\nexport const TableBodyCell: FC<TableBodyCellProps> = ({\n  containerRef,\n  rowId,\n  cell,\n  patchInfo,\n  columns,\n  coldefs,\n  rowIndex,\n  columnIndex,\n  editCellsIsAllowed,\n  getSortedRowModel,\n  cellEditInfo,\n  cellStyle,\n  cellClassName,\n  setData,\n  setCellEditMapAtLoc,\n  selection,\n}) => {\n  const initialValue = cell.getValue() as\n    | string\n    | { isShinyHtml: true; obj: { deps?: HtmlDep[]; html: string } }\n    | null;\n\n  const isHtmlColumn = cell.column.columnDef.meta!.isHtmlColumn;\n\n  const cellValue = cellEditInfo?.value ?? initialValue;\n\n  const cellState = cellEditInfo?.state ?? CellStateEnum.Ready;\n  const errorTitle = cellEditInfo?.errorTitle;\n  // Listen to boolean value of cellEditInfo. This allows for the cell state to be restored if esc is hit\n  const isEditing = cellEditInfo?.isEditing ?? false;\n  const editValue = cellEditInfo?.editValue ?? getCellValueText(cellValue);\n\n  const tdRef = useRef<HTMLTableCellElement | null>(null);\n  const inputRef = useRef<HTMLTextAreaElement | null>(null);\n\n  // Keyboard navigation:\n  // * When editing a cell:\n  //   * On esc key:\n  //     * \u221A Restore prior value / state / error\n  //     * \u221A Move focus from input to td\n  //   * On enter key:\n  //     * \u221A Save value\n  //     * \u221A Move to the cell below (or above w/ shift) and edit the new cell\n  //     * X Should shift+enter add a newline in a cell?\n  //   * On tab key:\n  //     * \u221A Save value\n  //     * \u221A Move to the cell to the right (or left w/ shift) and edit the new cell\n  //   * Scrolls out of view:\n  //     * Intercept keyboard events and execute the above actions\n  //     * (Currently, there literally is no input DOM element to accept keyboard events)\n  // TODO-barret-future; More keyboard navigation!\n  //   * https://www.npmjs.com/package/@table-nav/react ?\n  // * When focused on a td:\n  //   * Allow for arrow key navigation\n  //   * Have enter key enter edit mode for a cell\n  //   * \u221A When a td is focused, Have esc key move focus to the table\n  //   * X When table is focused, Have esc key blur the focus\n  // TODO-barret-future; Combat edit mode being independent of selection mode\n  // * In row / column selection mode, allow for arrow key navigation by focusing on a single cell, not a TR\n  // * If a cell is focused,\n  //   * `enter key` allows you to go into edit mode; If editing is turned off, the selection is toggled\n  //   * `space key` allows you toggle the selection of the cell\n  // * Arrow key navigation is required\n\n  const resetEditing = useCallback(\n    (\n      {\n        resetIsEditing = false,\n        resetEditValue = false,\n      }: { resetIsEditing?: boolean; resetEditValue?: boolean } = {\n        resetIsEditing: true,\n        resetEditValue: true,\n      }\n    ) => {\n      setCellEditMapAtLoc(rowIndex, columnIndex, (obj_draft) => {\n        if (resetIsEditing) obj_draft.isEditing = false;\n        if (resetEditValue) obj_draft.editValue = undefined;\n      });\n    },\n    [rowIndex, columnIndex, setCellEditMapAtLoc]\n  );\n\n  const handleEsc = (e: ReactKeyboardEvent<HTMLTextAreaElement>) => {\n    if (e.key !== \"Escape\") return;\n    // Prevent default behavior\n    e.preventDefault();\n    e.stopPropagation();\n\n    // Turn off editing and the _temp_ edit value\n    resetEditing();\n    selection.focusOffset(rowId, 0);\n  };\n  const handleTab = (e: ReactKeyboardEvent<HTMLTextAreaElement>) => {\n    if (e.key !== \"Tab\") return;\n    // Prevent default behavior\n    e.preventDefault();\n    e.stopPropagation();\n\n    const hasShift = e.shiftKey;\n\n    let nextColumnIndex = columnIndex;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const newColumnIndex = nextColumnIndex + (hasShift ? -1 : 1);\n\n      if (newColumnIndex < 0 || newColumnIndex >= coldefs.length) {\n        // If the new column index is out of bounds, quit\n        return;\n      }\n\n      nextColumnIndex = newColumnIndex;\n      // Repeat until the loop if the next column is not an HTML column\n      if (coldefs[newColumnIndex]!.meta!.isHtmlColumn !== true) {\n        break;\n      }\n    }\n\n    // Submit changes to the current cell\n    attemptUpdate();\n\n    // Turn on editing in next cell!\n    setCellEditMapAtLoc(rowIndex, nextColumnIndex, (obj_draft) => {\n      obj_draft.isEditing = true;\n    });\n  };\n  // TODO future: Make Cmd-Enter add a newline in a cell.\n  const handleEnter = (e: ReactKeyboardEvent<HTMLTextAreaElement>) => {\n    if (e.key !== \"Enter\") return;\n    // Prevent default behavior\n    e.preventDefault();\n    e.stopPropagation();\n\n    const hasShift = e.shiftKey;\n\n    const rowModel = getSortedRowModel();\n    const sortedRowIndex = rowModel.rows.findIndex((row) => row.id === rowId);\n    // Couldn't find row... silently quit\n    if (sortedRowIndex < 0) {\n      return;\n    }\n    const nextSortedRowIndex = sortedRowIndex! + (hasShift ? -1 : 1);\n\n    if (nextSortedRowIndex < 0 || nextSortedRowIndex >= rowModel.rows.length) {\n      // If the new row index is out of bounds, quit\n      return;\n    }\n\n    // Submit changes to the current cell\n    attemptUpdate();\n\n    // Turn on editing in the next cell!\n    // Get the original row index\n    const targetRowIndex = rowModel.rows[nextSortedRowIndex]!.index;\n    setCellEditMapAtLoc(targetRowIndex, columnIndex, (obj_draft) => {\n      obj_draft.isEditing = true;\n    });\n  };\n\n  const onInputKeyDown = (e: ReactKeyboardEvent<HTMLTextAreaElement>) => {\n    [handleEsc, handleEnter, handleTab].forEach((fn) => fn(e));\n  };\n\n  const attemptUpdate = useCallback(() => {\n    // Reset error title\n    setCellEditMapAtLoc(rowIndex, columnIndex, (obj_draft) => {\n      obj_draft.errorTitle = undefined;\n    });\n\n    // Only update if the string form of the value has changed\n    if (`${getCellValueText(cellValue)}` === `${editValue}`) {\n      // Reset all edit info\n      resetEditing();\n      // Set state to prior cell state\n      setCellEditMapAtLoc(rowIndex, columnIndex, (obj_draft) => {\n        obj_draft.state = cellState;\n      });\n      return;\n    }\n\n    // Only turn off editing for cell; Maintain all other edit info\n    resetEditing({ resetIsEditing: true });\n\n    // Set state to saving\n    setCellEditMapAtLoc(rowIndex, columnIndex, (obj_draft) => {\n      obj_draft.state = CellStateEnum.EditSaving;\n    });\n\n    // Update the data!\n    // updateCellsData updates the underlying data via `setData` and `setCellEditMapAtLoc`\n    updateCellsData({\n      patchInfo: patchInfo,\n      patches: [{ rowIndex, columnIndex, value: editValue }],\n      onSuccess: (_patches) => {\n        // Reset `editValue`\n        resetEditing({ resetEditValue: true });\n\n        // console.log(\"Success!!\");\n      },\n      onError: (_err) => {\n        // console.log(\"Error!!\", _err);\n        // // Do not reset edit value here so that users can \"restore\" their prior edit value\n        // resetEditing({ resetEditValue: true });\n      },\n      columns,\n      setData,\n      setCellEditMapAtLoc,\n    });\n  }, [\n    setCellEditMapAtLoc,\n    rowIndex,\n    columnIndex,\n    cellValue,\n    editValue,\n    resetEditing,\n    patchInfo,\n    columns,\n    setData,\n    cellState,\n  ]);\n\n  // Select the input when it becomes editable\n  useEffect(() => {\n    if (!isEditing) return;\n    if (!inputRef.current) return;\n\n    inputRef.current.focus();\n    inputRef.current.select();\n  }, [isEditing]);\n\n  // When editing a cell, set up a global click listener to reset edit info when\n  // clicking outside of the cell\n  // Use MouseDown event to match how selection is performed to prevent the click from bubbling up\n  useEffect(() => {\n    if (!isEditing) return;\n    if (!tdRef.current) return;\n    if (!inputRef.current) return;\n\n    // TODO-barret; Restore cursor position and text selection here\n\n    const onEdtingCellMouseDown = (e: MouseEvent) => {\n      if (!tdRef.current?.contains(e.target as Node)) return;\n      // Prevent the click from bubbling up to the body click listener\n      e.stopPropagation();\n\n      // Do not stop the event from preventing default as we need the click to work for the text area!\n      // e.preventDefault();\n    };\n    const curRef = tdRef.current; // Capture the current ref\n    curRef.addEventListener(\"mousedown\", onEdtingCellMouseDown);\n\n    // Set up global click listener to reset edit info\n    const onBodyMouseDown = (e: MouseEvent) => {\n      if (e.target === inputRef.current) return;\n\n      attemptUpdate();\n      // Turn off editing for this cell\n      resetEditing();\n    };\n    document.body.addEventListener(\"mousedown\", onBodyMouseDown);\n\n    // Tear down global click listener when we're done\n    return () => {\n      curRef.removeEventListener(\"mousedown\", onEdtingCellMouseDown);\n      document.body.removeEventListener(\"mousedown\", onBodyMouseDown);\n    };\n  }, [\n    cellState,\n    attemptUpdate,\n    rowIndex,\n    columnIndex,\n    isEditing,\n    resetEditing,\n  ]);\n\n  // Reselect the input when it comes into view!\n  // (It could be scrolled out of view and then back into view)\n  function onFocus(e: ReactFocusEvent<HTMLTextAreaElement>) {\n    if (isEditing) {\n      e.target.select();\n    }\n  }\n\n  function onChange(e: ReactChangeEvent<HTMLTextAreaElement>) {\n    // Update edit value to cell map\n    setCellEditMapAtLoc(rowIndex, columnIndex, (obj_draft) => {\n      obj_draft.editValue = e.target.value;\n    });\n  }\n\n  // // https://medium.com/@oherterich/creating-a-textarea-with-dynamic-height-using-react-and-typescript-5ed2d78d9848\n  // // Updates the height of a <textarea> when the value changes.\n  // const useAutosizeTextArea = (\n  //   textAreaRef: HTMLTextAreaElement | null,\n  //   value: string\n  // ) => {\n  //   useEffect(() => {\n  //     if (textAreaRef) {\n  //       // We need to reset the height momentarily to get the correct scrollHeight for the textarea\n  //       textAreaRef.style.height = \"0px\";\n  //       const scrollHeight = textAreaRef.scrollHeight;\n\n  //       // We then set the height directly, outside of the render loop\n  //       // Trying to set this with state or a ref will product an incorrect value.\n  //       textAreaRef.style.height = scrollHeight + \"px\";\n  //     }\n  //   }, [textAreaRef, value]);\n  // };\n  // useAutosizeTextArea(inputRef.current, value as string);\n\n  let onCellDoubleClick:\n    | ((e: ReactMouseEvent<HTMLTableCellElement>) => void)\n    | undefined = undefined;\n  let content: ReactElement | ReturnType<typeof flexRender> | undefined =\n    undefined;\n  const cellTitle = errorTitle;\n  let tableCellClass: string | undefined = cellClassName;\n  const addToTableCellClass = (x: string | undefined) => {\n    if (!x) return;\n    if (tableCellClass) {\n      tableCellClass += \" \";\n      tableCellClass += x;\n    } else {\n      tableCellClass = x;\n    }\n  };\n  addToTableCellClass(\n    CellStateClassEnum[isEditing ? CellStateEnum.Editing : cellState]\n  );\n  let attemptRenderAsync = false;\n\n  let editContent: ReactElement | null = null;\n  if (cellState === CellStateEnum.EditSaving) {\n    // If saving, do not allow any clicks or edits\n    content = editValue as string;\n  } else {\n    if (isEditing) {\n      editContent = (\n        <textarea\n          value={String(editValue)}\n          onChange={onChange}\n          // onBlur={onBlur}\n          onFocus={onFocus}\n          onKeyDown={onInputKeyDown}\n          ref={inputRef}\n          // style={{ width: \"100%\", height: \"100%\" }}\n        />\n      );\n    } else if (isHtmlColumn) {\n      addToTableCellClass(\"cell-html\");\n    } else {\n      // `isEditing` is `false` and not an HTML column, so we can allow for double clicks to go into edit mode\n\n      // Only allow transition to edit mode if the cell can be edited\n      if (editCellsIsAllowed) {\n        addToTableCellClass(\"cell-editable\");\n        onCellDoubleClick = (e: ReactMouseEvent<HTMLTableCellElement>) => {\n          // Do not prevent default or stop propagation here!\n          // Other methods need to be able to handle the event as well. e.g. `onBodyClick` above.\n          // e.preventDefault();\n          // e.stopPropagation();\n\n          // Set this cell to editing mode\n          setCellEditMapAtLoc(rowIndex, columnIndex, (obj_draft) => {\n            obj_draft.isEditing = true;\n            obj_draft.editValue = getCellValueText(cellValue) as string;\n          });\n        };\n      }\n    }\n    if (isShinyHtml(cellValue)) {\n      attemptRenderAsync = true;\n    } else {\n      // Render cell contents like normal\n      content = flexRender(cell.column.columnDef.cell, cell.getContext());\n    }\n  }\n\n  useEffect(() => {\n    if (!tdRef.current) return;\n    if (!attemptRenderAsync) return;\n    if (!isShinyHtml(cellValue)) return;\n\n    // TODO-future; Use faster way to make a deep copy\n    const cellValueObjDeepCopy = JSON.parse(JSON.stringify(cellValue.obj));\n    // Render the Shiny content asynchronously to the table's cell\n    window.Shiny.renderContentAsync(tdRef.current, cellValueObjDeepCopy);\n\n    const curTdRef = tdRef.current;\n\n    return () => {\n      // Unbind all Shiny inputs and outputs within the cell\n      window.Shiny.unbindAll!(curTdRef);\n      // Remove DOM elements from cell inserted by `window.Shiny.renderContentAsync`\n      curTdRef.replaceChildren(\"\");\n    };\n  }, [tdRef, cellValue, rowIndex, columnIndex, attemptRenderAsync]);\n\n  return (\n    <td\n      ref={tdRef}\n      onDoubleClick={onCellDoubleClick}\n      title={cellTitle}\n      className={tableCellClass}\n      style={{ ...cellStyle }}\n    >\n      {editContent}\n      {content}\n    </td>\n  );\n};\n\n// // TODO-barret; Consider using https://www.npmjs.com/package/react-contenteditable !\n// const cellValue = cell.getValue();\n// const cellValueType = typeof cellValue;\n// const cellContentIsEditable =\n//   cellValueType === \"string\" ||\n//   cellValueType === \"number\" ||\n//   cellValueType === \"boolean\" ||\n//   cellValueType === \"undefined\" ||\n//   cellValue === null;\n// if (cellContentIsEditable) {\n//   // cellContentEditable = \"\"plaintext-only\";\n//   cellContentEditable = true;\n// }\n// const onInput = (e: ReactChangeEvent<HTMLTableCellElement>) => {\n//   console.log(\"on input!\", e, rowIndex, columnIndex, e.target.textContent);\n// };\n// td attrs for below\n// contentEditable={cellContentEditable}\n// onInput={onInput}\n", "import { enableMapSet } from \"immer\";\nimport { DraftFunction, Updater, useImmer } from \"use-immer\";\nimport type { CellState } from \"./cell\";\n\n// const [cellEditMap, setCellEditMap] = useImmer<\n//   Map<string, { value: string; state: CellState; save_error?: string }>\n// >(new Map<string, { value: string; state: CellState }>());\n// enableMapSet();\n\nexport type CellEdit = {\n  // rowIndex: number;\n  // columnIndex: number;\n  value?: string;\n  state?: CellState;\n  errorTitle?: string;\n  isEditing?: boolean;\n  editValue?: string;\n  // selection location info\n  // cursor position info\n};\nexport type CellEditMap = Map<string, CellEdit>;\nexport type SetCellEditMap = Updater<CellEditMap>;\nexport type SetCellEditMapAtLoc = (\n  rowIndex: number,\n  columnIndex: number,\n  obj_fn: DraftFunction<CellEdit>\n) => void;\nexport const useCellEditMap = () => {\n  const [cellEditMap, setCellEditMap] = useImmer<CellEditMap>(\n    new Map<string, CellEdit>()\n  );\n  enableMapSet();\n  const setCellEditMapAtLoc: SetCellEditMapAtLoc = (\n    rowIndex: number,\n    columnIndex: number,\n    obj_fn: DraftFunction<CellEdit>\n  ) => {\n    setCellEditMap((draft) => {\n      const key = makeCellEditMapKey(rowIndex, columnIndex);\n      const obj = draft.get(key) ?? ({} as CellEdit);\n      obj_fn(obj);\n      // obj.rowIndex = rowIndex;\n      // obj.columnIndex = columnIndex;\n      draft.set(key, obj);\n    });\n  };\n  return {\n    cellEditMap,\n    // setCellEditMap,\n    setCellEditMapAtLoc,\n    resetCellEditMap: () => {\n      setCellEditMap(new Map<string, CellEdit>());\n    },\n  } as const;\n};\n\nexport const makeCellEditMapKey = (rowIndex: number, columnIndex: number) => {\n  return `[${rowIndex}, ${columnIndex}]`;\n};\n\nexport const cellEditMapHasKey = (\n  x: CellEditMap,\n  rowIndex: number,\n  columnIndex: number\n) => {\n  return x.has(makeCellEditMapKey(rowIndex, columnIndex));\n};\nexport const getCellEditMapObj = (\n  x: CellEditMap,\n  rowIndex: number,\n  columnIndex: number\n): [CellEdit, string] => {\n  const key = makeCellEditMapKey(rowIndex, columnIndex);\n  return [x.get(key) ?? ({} as CellEdit), key];\n};\n", "// Find the first item whose top-left corner is fully inside the visible portion of the\n// scroll container\nexport function findFirstItemInView(\n  scrollContainer: HTMLElement,\n  items: NodeList | ChildNode[] | Element[] | HTMLElement[],\n  extraPadding?: {\n    top?: number;\n    right?: number;\n    bottom?: number;\n    left?: number;\n  }\n) {\n  const pad = Object.assign(\n    { top: 0, right: 0, bottom: 0, left: 0 },\n    extraPadding\n  );\n  const container = scrollContainer;\n  const top = container.scrollTop + pad.top;\n  const left = container.scrollLeft + pad.left;\n  const bottom = top + container.clientHeight - pad.top - pad.bottom;\n  const right = left + container.clientWidth - pad.left - pad.right;\n\n  for (let i = 0; i < items.length; i++) {\n    const el = items[i] as HTMLElement;\n    const y = el.offsetTop,\n      x = el.offsetLeft;\n    if (y >= top && y <= bottom && x >= left && x <= right) {\n      return el;\n    }\n  }\n  return null;\n}\n\nexport function getStyle(el: Element, styleProp: string): string | undefined {\n  // getComputedStyle can return null when we're inside a hidden iframe on\n  // Firefox; don't attempt to retrieve style props in this case.\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n  return document?.defaultView\n    ?.getComputedStyle(el, null)\n    ?.getPropertyValue(styleProp);\n}\n", "import React, { FC, useEffect, useRef, useState } from \"react\";\n\nexport interface FilterNumericProps\n  extends React.InputHTMLAttributes<HTMLInputElement> {\n  // The absolute min/max possible values\n  range: () => [number | undefined, number | undefined];\n\n  // The currently selected min/max values\n  from: number | undefined;\n  to: number | undefined;\n\n  onRangeChange: (from?: number, to?: number) => void;\n}\n\nexport const FilterNumeric: FC<FilterNumericProps> = (props) => {\n  const [editing, setEditing] = useState(false);\n  const { range, from, to, onRangeChange } = props;\n\n  return (\n    <FilterNumericImpl\n      range={range}\n      value={[from, to]}\n      editing={editing}\n      onValueChange={(x) => onRangeChange(...x)}\n      onFocus={() => setEditing(true)}\n      onBlur={() => setEditing(false)}\n    />\n  );\n};\n\nfunction generateLabel(from?: number, to?: number) {\n  if (typeof from === \"undefined\" && typeof to === \"undefined\") {\n    return \"\";\n  } else if (typeof from === \"undefined\") {\n    return `\u2264 ${to}`;\n  } else if (typeof to === \"undefined\") {\n    return `\u2265 ${from}`;\n  } else {\n    return `\u2265${from}, \u2264${to}`;\n  }\n}\n\ninterface FilterNumericImplProps {\n  range: () => [number | undefined, number | undefined];\n  value: [number | undefined, number | undefined];\n  editing: boolean;\n  onValueChange: (range: [number | undefined, number | undefined]) => void;\n  onFocus: () => void;\n  onBlur: () => void;\n}\n\nconst FilterNumericImpl: React.FC<FilterNumericImplProps> = (props) => {\n  const [min, max] = props.value;\n  const { editing, onFocus } = props;\n  const [rangeMin, rangeMax] = props.range();\n\n  const minInputRef = useRef<HTMLInputElement>(null);\n  const maxInputRef = useRef<HTMLInputElement>(null);\n\n  return (\n    <div\n      onBlur={(e) => {\n        if (e.currentTarget.contains(e.relatedTarget)) {\n          return;\n        }\n        return props.onBlur();\n      }}\n      onFocus={() => onFocus()}\n      style={{\n        display: \"flex\",\n        gap: \"0.5rem\",\n      }}\n    >\n      <input\n        ref={minInputRef}\n        className={`form-control form-control-sm ${\n          minInputRef.current?.checkValidity() ? \"\" : \"is-invalid\"\n        }`}\n        style={{ flex: \"1 1 0\", width: \"0\" }}\n        type=\"number\"\n        placeholder={createPlaceholder(editing, \"Min\", rangeMin)}\n        defaultValue={min}\n        // min={rangeMin}\n        // max={rangeMax}\n        step=\"any\"\n        onChange={(e) => {\n          const value = coerceToNum(e.target.value);\n          if (!minInputRef.current) return;\n          minInputRef.current.classList.toggle(\n            \"is-invalid\",\n            !e.target.checkValidity()\n          );\n          props.onValueChange([value, max]);\n        }}\n      />\n      <input\n        ref={maxInputRef}\n        className={`form-control form-control-sm ${\n          maxInputRef.current?.checkValidity() ? \"\" : \"is-invalid\"\n        }`}\n        style={{ flex: \"1 1 0\", width: \"0\" }}\n        type=\"number\"\n        placeholder={createPlaceholder(editing, \"Max\", rangeMax)}\n        defaultValue={max}\n        // min={rangeMin}\n        // max={rangeMax}\n        step=\"any\"\n        onChange={(e) => {\n          const value = coerceToNum(e.target.value);\n          if (!maxInputRef.current) return;\n          maxInputRef.current.classList.toggle(\n            \"is-invalid\",\n            !e.target.checkValidity()\n          );\n          props.onValueChange([min, value]);\n        }}\n      />\n    </div>\n  );\n};\n\nfunction createPlaceholder(\n  editing: boolean,\n  label: string,\n  value: number | undefined\n) {\n  if (!editing) {\n    return undefined;\n  } else if (typeof value === \"undefined\") {\n    return label;\n  } else {\n    return `${label} (${value})`;\n  }\n}\n\nfunction coerceToNum(value: string): number | undefined {\n  if (value === \"\") {\n    return undefined;\n  }\n  return +value;\n}\n", "import {\n  ColumnFiltersOptions,\n  ColumnFiltersState,\n  FilterMeta,\n  Header,\n  Row,\n  getFacetedMinMaxValues,\n  getFacetedRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n} from \"@tanstack/react-table\";\nimport React, { FC, useState } from \"react\";\nimport { FilterNumeric } from \"./filter-numeric\";\n\ntype FilterValueString = string;\ntype FilterValueNumeric =\n  | [number, number]\n  | [number | undefined, number]\n  | [number, number | undefined];\ntype FilterValue = FilterValueString | FilterValueNumeric;\n\nexport type { ColumnFiltersState, FilterValue };\n\nexport function useFilters<TData>(enabled: boolean | undefined): {\n  columnFilters: ColumnFiltersState;\n  setColumnFilters: React.Dispatch<React.SetStateAction<ColumnFiltersState>>;\n  columnFiltersState: { columnFilters: ColumnFiltersState };\n  filtersTableOptions: ColumnFiltersOptions<TData>;\n} {\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]); // can set initial column filter state here\n\n  const filtersTableOptions = enabled\n    ? {\n        getFilteredRowModel: getFilteredRowModel<TData>(),\n        getFacetedRowModel: getFacetedRowModel<TData>(),\n        getFacetedUniqueValues: getFacetedUniqueValues<TData>(),\n        getFacetedMinMaxValues: getFacetedMinMaxValues<TData>(),\n        filterFns: {\n          substring: (\n            row: Row<TData>,\n            columnId: string,\n            value: string,\n            addMeta: (meta: FilterMeta) => void\n          ): boolean => {\n            return row.getValue(columnId)?.toString().includes(value) ?? false;\n          },\n        },\n        onColumnFiltersChange: setColumnFilters,\n      }\n    : {};\n\n  return {\n    columnFilters,\n    columnFiltersState: {\n      columnFilters,\n    },\n    filtersTableOptions,\n    setColumnFilters,\n  };\n}\n\nexport interface FilterProps\n  extends React.InputHTMLAttributes<HTMLInputElement> {\n  header: Header<unknown[], unknown>;\n}\n\nexport const Filter: FC<FilterProps> = ({ header, className, ...props }) => {\n  const typeHint = header.column.columnDef.meta?.typeHint;\n\n  // Do not filter on unknown types\n  if (!typeHint) return null;\n\n  // Do not filter on html types\n  if (typeHint.type === \"html\") return null;\n\n  if (typeHint.type === \"numeric\") {\n    const [from, to] = (header.column.getFilterValue() as\n      | FilterValueNumeric\n      | [undefined, undefined]\n      | undefined) ?? [undefined, undefined];\n\n    const range = () => {\n      return header.column.getFacetedMinMaxValues() ?? [undefined, undefined];\n    };\n\n    return FilterNumeric({\n      from,\n      to,\n      range,\n      onRangeChange: (from, to) => header.column.setFilterValue([from, to]),\n    });\n  }\n\n  return (\n    <input\n      {...props}\n      // If there was a value and now there isn't,\n      // set the filter value to `\"\"` and not `undefined`.\n      // `undefined` will not clear the displayed value.\n      value={(header.column.getFilterValue() as string) || \"\"}\n      className={`form-control form-control-sm ${className}`}\n      type=\"text\"\n      onChange={(e) => header.column.setFilterValue(e.target.value)}\n    />\n  );\n};\n", "export class ImmutableSet<T> {\n  private _set: Set<T>;\n  private static _empty: ImmutableSet<unknown> = new ImmutableSet(new Set());\n\n  private constructor(set: Set<T>) {\n    this._set = set;\n  }\n\n  static empty<T>(): ImmutableSet<T> {\n    return this._empty as ImmutableSet<T>;\n  }\n\n  static just<T>(...values: T[]): ImmutableSet<T> {\n    return this.empty<T>().add(...values);\n  }\n\n  has(value: T): boolean {\n    return this._set.has(value);\n  }\n\n  add(...values: T[]): ImmutableSet<T> {\n    const newSet = new Set(this._set.keys());\n    for (const value of values) {\n      newSet.add(value);\n    }\n    return new ImmutableSet(newSet);\n  }\n\n  toggle(value: T): ImmutableSet<T> {\n    if (this.has(value)) {\n      return this.delete(value);\n    } else {\n      return this.add(value);\n    }\n  }\n\n  delete(value: T): ImmutableSet<T> {\n    const newSet = new Set(this._set.keys());\n    newSet.delete(value);\n    return new ImmutableSet(newSet);\n  }\n\n  clear(): ImmutableSet<T> {\n    return ImmutableSet.empty();\n  }\n\n  [Symbol.iterator]() {\n    return this._set[Symbol.iterator]();\n  }\n\n  toList(): T[] {\n    return [...this._set.keys()];\n  }\n}\n", "import * as React from \"react\";\nimport { useState } from \"react\";\nimport { ImmutableSet } from \"./immutable-set\";\n\nimport { CellStateClassEnum, CellStateEnum } from \"./cell\";\nimport type { ValueOf } from \"./types\";\n\ntype CellSelectionNone = { type: \"none\" };\ntype CellSelectionRow = { type: \"row\"; rows: readonly number[] };\ntype CellSelectionCol = { type: \"col\"; cols: readonly number[] };\ntype CellSelectionRect = {\n  type: \"rect\";\n  rows: readonly [number, number];\n  cols: readonly [number, number];\n};\n\n// For sending and receiving selection info to python\nexport type CellSelection =\n  | CellSelectionNone\n  | CellSelectionRow\n  | CellSelectionCol\n  | CellSelectionRect;\n\nexport interface SelectionSet<TKey, TElement extends HTMLElement> {\n  has(key: TKey): boolean;\n  set(key: TKey, selected: boolean): void;\n  setMultiple(key_arr: TKey[]): void;\n  clear(): void;\n  keys(): ImmutableSet<TKey>;\n  itemHandlers(): {\n    onMouseDown: (event: React.MouseEvent<TElement, MouseEvent>) => void;\n    onKeyDown: (event: React.KeyboardEvent<TElement>) => void;\n  };\n  focusOffset: (start: TKey, offset: number) => TKey | null;\n}\n\n// Keep as strings (and not pointer types) as this is a shape defined by the python side\nexport type SelectionModesProp = {\n  row: \"none\" | \"single\" | \"multiple\";\n  col: \"none\" | \"single\" | \"multiple\";\n  rect: \"none\" | \"cell\" | \"region\";\n};\nexport class SelectionModes {\n  static readonly _NONE = \"none\";\n  static readonly _ROW_SINGLE = \"single\";\n  static readonly _ROW_MULTIPLE = \"multiple\";\n  static readonly _COL_SINGLE = \"single\";\n  static readonly _col_multiple = \"multiple\";\n  static readonly _RECT_CELL = \"cell\";\n  static readonly _RECT_REGION = \"region\";\n\n  static readonly _rowEnum = {\n    NONE: SelectionModes._NONE,\n    SINGLE: SelectionModes._ROW_SINGLE,\n    MULTIPLE: SelectionModes._ROW_MULTIPLE,\n  } as const;\n  static readonly _colEnum = {\n    NONE: SelectionModes._NONE,\n    SINGLE: SelectionModes._COL_SINGLE,\n    MULTIPLE: SelectionModes._col_multiple,\n  } as const;\n  static readonly _rectEnum = {\n    NONE: SelectionModes._NONE,\n    REGION: SelectionModes._RECT_REGION,\n    CELL: SelectionModes._RECT_CELL,\n  } as const;\n\n  row: ValueOf<typeof SelectionModes._rowEnum>;\n  col: ValueOf<typeof SelectionModes._colEnum>;\n  rect: ValueOf<typeof SelectionModes._rectEnum>;\n\n  constructor({\n    row,\n    col,\n    rect,\n  }: {\n    row: SelectionModesProp[\"row\"];\n    col: SelectionModesProp[\"col\"];\n    rect: SelectionModesProp[\"rect\"];\n  }) {\n    if (!Object.values(SelectionModes._rowEnum).includes(row)) {\n      throw new Error(`Invalid row selection mode: ${row}`);\n    }\n    if (!Object.values(SelectionModes._colEnum).includes(col)) {\n      throw new Error(`Invalid col selection mode: ${col}`);\n    }\n    if (!Object.values(SelectionModes._rectEnum).includes(rect)) {\n      throw new Error(`Invalid rect selection mode: ${rect}`);\n    }\n    this.row = row;\n    this.col = col;\n    this.rect = rect;\n  }\n\n  isNone(): boolean {\n    return (\n      this.row === SelectionModes._rowEnum.NONE &&\n      this.col === SelectionModes._colEnum.NONE &&\n      this.rect === SelectionModes._rectEnum.NONE\n    );\n  }\n}\n\nexport function initSelectionModes(\n  selectionModesOption: SelectionModesProp | undefined\n): SelectionModes {\n  // If no option was provided, default to multinative mode\n  if (!selectionModesOption) {\n    selectionModesOption = { row: \"multiple\", col: \"none\", rect: \"none\" };\n  }\n  return new SelectionModes({\n    row: selectionModesOption.row,\n    col: selectionModesOption.col,\n    rect: selectionModesOption.rect,\n  });\n}\n\nexport function useSelection<TKey, TElement extends HTMLElement>({\n  isEditingCell,\n  editCellsIsAllowed,\n  selectionModes,\n  keyAccessor,\n  focusOffset,\n  focusEscape,\n  onKeyDownEnter,\n  between,\n}: {\n  // cellBeingEdited: { rowIndex: number; columnIndex: number } | null;\n  isEditingCell: boolean;\n  editCellsIsAllowed: boolean;\n  selectionModes: SelectionModes;\n  keyAccessor: (el: TElement) => TKey;\n  focusOffset: (start: TKey, offset: number) => TKey | null;\n  focusEscape: (el: TElement) => void;\n  onKeyDownEnter: (el: TElement) => void;\n  between: (from: TKey, to: TKey) => ReadonlyArray<TKey>;\n}): SelectionSet<TKey, TElement> {\n  const [selectedKeys, setSelectedKeys] = useState<ImmutableSet<TKey>>(\n    ImmutableSet.empty()\n  );\n\n  // The anchor is the item that was most recently selected with a click or ctrl-click,\n  // and is used to determine the \"other end\" of a shift-click selection operation.\n  const [anchor, setAnchor] = useState<TKey | null>(null);\n\n  const onMouseDown = (event: React.MouseEvent<TElement, MouseEvent>): void => {\n    if (selectionModes.isNone()) {\n      return;\n    }\n\n    const el = event.currentTarget as TElement;\n    const key = keyAccessor(el);\n    if (isEditingCell) {\n      // Only quit early if that cell is in edit mode\n      if (el.classList.contains(CellStateClassEnum[CellStateEnum.Editing])) {\n        return;\n      }\n    }\n\n    const result = performMouseDownAction<TKey, TElement>(\n      selectionModes,\n      between,\n      selectedKeys,\n      event,\n      key,\n      anchor\n    );\n    if (result) {\n      setSelectedKeys(result.selection);\n      if (result.anchor) {\n        setAnchor(key);\n        el.focus();\n      }\n      event.preventDefault();\n    }\n  };\n\n  const onKeyDown = (event: React.KeyboardEvent<TElement>): void => {\n    if (isEditingCell) {\n      return;\n    }\n    if (selectionModes.isNone()) {\n      return;\n    }\n\n    const el = event.currentTarget as TElement;\n    const key = keyAccessor(el);\n    const selected = selectedKeys.has(key);\n\n    if (event.key === \"Escape\") {\n      focusEscape(el);\n      event.preventDefault();\n      return;\n    }\n\n    // For both row and rows, do not allow for alphanumeric keys to trigger edit mode.\n    // Only allow for this once the anchor is a single cell, such as region selection.\n    // For region selection, allow for alphanumeric keys to trigger edit mode of current cell.\n    // For region selection, allow for enter key to trigger edit mode of current cell.\n\n    if (selectionModes.row === SelectionModes._rowEnum.SINGLE) {\n      if (event.key === \" \" || event.key === \"Enter\") {\n        event.preventDefault();\n        if (editCellsIsAllowed && event.key === \"Enter\") {\n          onKeyDownEnter(el);\n        } else {\n          if (selectedKeys.has(key)) {\n            setSelectedKeys(ImmutableSet.empty());\n          } else {\n            setSelectedKeys(ImmutableSet.just(key));\n          }\n        }\n      } else if (event.key === \"ArrowUp\" || event.key === \"ArrowDown\") {\n        const targetKey = focusOffset(key, event.key === \"ArrowUp\" ? -1 : 1);\n        if (targetKey) {\n          event.preventDefault();\n          if (selected) {\n            setSelectedKeys(ImmutableSet.just(targetKey));\n          }\n        }\n      }\n    } else if (selectionModes.row === SelectionModes._rowEnum.MULTIPLE) {\n      if (event.key === \" \" || event.key === \"Enter\") {\n        event.preventDefault();\n        if (editCellsIsAllowed && event.key === \"Enter\") {\n          onKeyDownEnter(el);\n        } else {\n          setSelectedKeys(selectedKeys.toggle(key));\n        }\n      } else if (event.key === \"ArrowUp\" || event.key === \"ArrowDown\") {\n        if (focusOffset(key, event.key === \"ArrowUp\" ? -1 : 1)) {\n          event.preventDefault();\n        }\n      }\n    }\n  };\n\n  const selection = {\n    has(key: TKey): boolean {\n      return selectedKeys.has(key);\n    },\n\n    set(key: TKey, selected: boolean) {\n      if (selected) {\n        setSelectedKeys(selectedKeys.add(key));\n      } else {\n        setSelectedKeys(selectedKeys.delete(key));\n      }\n    },\n\n    setMultiple(keyArr: TKey[]) {\n      setSelectedKeys(ImmutableSet.just(...keyArr));\n    },\n\n    clear() {\n      setSelectedKeys(selectedKeys.clear());\n    },\n\n    keys() {\n      return selectedKeys;\n    },\n\n    itemHandlers() {\n      return { onMouseDown, onKeyDown };\n    },\n\n    focusOffset,\n  };\n\n  return selection;\n}\n\ndeclare global {\n  interface Navigator {\n    readonly userAgentData?: NavigatorUAData;\n  }\n  interface NavigatorUAData {\n    readonly brands?: { brand: string; version: string }[];\n    readonly mobile?: boolean;\n    readonly platform?: string;\n  }\n}\n\nconst isMac = /^mac/i.test(\n  window.navigator.userAgentData?.platform ?? window.navigator.platform\n);\n\nfunction performMouseDownAction<TKey, TElement>(\n  selectionModes: SelectionModes,\n  between: ((from: TKey, to: TKey) => readonly TKey[]) | undefined,\n  selectedKeys: ImmutableSet<TKey>,\n  event: React.MouseEvent<TElement, MouseEvent>,\n  key: TKey,\n  anchor: TKey | null\n): { selection: ImmutableSet<TKey>; anchor?: true } | null {\n  const { shiftKey, altKey } = event;\n  const ctrlKey = isMac ? event.metaKey : event.ctrlKey;\n  const metaKey = isMac ? event.ctrlKey : event.metaKey;\n\n  if (metaKey || altKey) {\n    return null;\n  }\n\n  if (selectionModes.row === SelectionModes._rowEnum.NONE) {\n    return null;\n  } else if (selectionModes.row === SelectionModes._rowEnum.SINGLE) {\n    if (ctrlKey && !shiftKey) {\n      // Ctrl-click is like simple click, except it removes selection if an item is\n      // already selected\n      if (selectedKeys.has(key)) {\n        return { selection: ImmutableSet.empty(), anchor: true };\n      } else {\n        return { selection: ImmutableSet.just(key), anchor: true };\n      }\n    } else {\n      // Simple click sets selection, always\n      return { selection: ImmutableSet.just(key), anchor: true };\n    }\n    // TODO-barret; multinative should be the new definition of `rows`!\n  } else if (selectionModes.row === SelectionModes._rowEnum.MULTIPLE) {\n    if (shiftKey && ctrlKey) {\n      // Ctrl-Shift-click: Add anchor row through current row to selection\n      if (anchor !== null && between) {\n        const toSelect = between(anchor, key);\n        return { selection: selectedKeys.add(...toSelect) };\n      }\n    } else if (ctrlKey) {\n      // Ctrl-click: toggle the current row and make it anchor\n      return { selection: selectedKeys.toggle(key), anchor: true };\n    } else if (shiftKey) {\n      // Shift-click: replace selection with anchor row through current row\n      if (anchor !== null && between) {\n        const toSelect = between(anchor, key);\n        return { selection: ImmutableSet.just(...toSelect) };\n      }\n    } else {\n      // Regular click: Select the current row and make it anchor\n      return { selection: ImmutableSet.just(key), anchor: true };\n    }\n  } else {\n    throw new Error(`Unsupported row selection mode: ${selectionModes.row}`);\n  }\n  return null;\n}\n", "import {\n  SortingOptions,\n  SortingState,\n  getSortedRowModel,\n} from \"@tanstack/react-table\";\nimport React, { useState } from \"react\";\n\nimport type { ColumnDef, ColumnSort, Updater } from \"@tanstack/react-table\";\n\nexport type { ColumnSort, SortingState };\n\nexport function useSort<TData>({\n  getColDefs,\n}: {\n  getColDefs: () => ColumnDef<unknown[], unknown>[];\n}): {\n  sorting: SortingState;\n  setSorting: React.Dispatch<React.SetStateAction<SortingState>>;\n  sortTableStateOptions: { sorting: SortingState };\n  sortTableOptions: SortingOptions<TData>;\n} {\n  const [sorting, setSorting] = useState<SortingState>([]);\n\n  return {\n    sorting,\n    sortTableStateOptions: {\n      sorting,\n    },\n    sortTableOptions: {\n      onSortingChange: (sortUpdater: Updater<SortingState>) => {\n        const newSorting: SortingState =\n          typeof sortUpdater === \"function\"\n            ? sortUpdater(sorting)\n            : sortUpdater;\n        const coldefs = getColDefs();\n        const htmlColumnsSet = new Set(\n          coldefs\n            .filter((col) => col.meta!.isHtmlColumn)\n            .map((col) => col.header!)\n        );\n\n        const filteredSort =\n          htmlColumnsSet.size == 0\n            ? newSorting\n            : newSorting.filter((sort) => {\n                return !htmlColumnsSet.has(sort.id);\n              });\n\n        setSorting(filteredSort);\n      },\n      getSortedRowModel: getSortedRowModel(),\n    },\n    setSorting,\n  };\n}\n", "import { SortDirection } from \"@tanstack/react-table\";\nimport React, { FC } from \"react\";\n\nconst sortClassName = \"sort-arrow\";\nconst sortCommonProps = {\n  viewBox: [-1, -1, 2, 2].map((x) => x * 1.4).join(\" \"),\n  width: \"100%\",\n  height: \"100%\",\n  style: { paddingLeft: \"3px\" },\n};\n\nconst sortPathCommonProps = {\n  stroke: \"#333333\",\n  strokeWidth: \"0.6\",\n  fill: \"transparent\",\n};\n\nconst sortArrowUp = (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    {...{ ...sortCommonProps, className: `${sortClassName} sort-arrow-up` }}\n  >\n    <path\n      d=\"M -1 0.5 L 0 -0.5 L 1 0.5\"\n      {...sortPathCommonProps}\n      strokeLinecap=\"round\"\n    />\n  </svg>\n);\n\nconst sortArrowDown = (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    {...{ ...sortCommonProps, className: `${sortClassName} sort-arrow-down` }}\n  >\n    <path\n      d=\"M -1 -0.5 L 0 0.5 L 1 -0.5\"\n      {...sortPathCommonProps}\n      strokeLinecap=\"round\"\n    />\n  </svg>\n);\n\ninterface SortArrowProps {\n  direction: SortDirection | false;\n}\n\nexport const SortArrow: FC<SortArrowProps> = ({ direction }) => {\n  if (!direction) {\n    return null;\n  }\n  if (direction === \"asc\") {\n    return sortArrowUp;\n  }\n  if (direction === \"desc\") {\n    return sortArrowDown;\n  }\n  throw new Error(`Unexpected sort direction: '${direction}'`);\n};\n\n//const sortArrowUp = <span className=\"sort-arrow sort-arrow-up\"> \u25B2</span>;\n//const sortArrowDown = <span className=\"sort-arrow sort-arrow-down\"> \u25BC</span>;\n", "// This file is oddly close to `useCellEditMap.tsx`\n\nimport { enableMapSet } from \"immer\";\nimport { useCallback, useEffect } from \"react\";\nimport { Updater, useImmer } from \"use-immer\";\n\nenableMapSet();\n\nexport type CellStyle = { [key: string]: string | null };\n\ntype StyleInfoBody = {\n  location: \"body\";\n  rows: number[] | null;\n  cols: number[] | null;\n  style?: CellStyle;\n  class?: string;\n};\nexport type StyleInfo = StyleInfoBody;\n// export type Styles = StyleInfo[];\n\ntype StyleInfoStoredBody = {\n  location: \"body\";\n  rowIndex: number;\n  columnIndex: number;\n  style?: CellStyle;\n  class?: string;\n};\nexport type StyleInfoStored = StyleInfoStoredBody;\n\ntype StyleLocation = StyleInfo[\"location\"];\n\nexport type StyleInfoMap = Map<string, StyleInfoStored>;\n\nexport const makeStyleInfoMapKey = ({\n  location,\n  rowIndex,\n  columnIndex,\n}: {\n  location: StyleLocation;\n  rowIndex: number;\n  columnIndex: number;\n}) => {\n  return `[${location}, ${rowIndex}, ${columnIndex}]`;\n};\n\nexport type SetStyleInfoStoredMap = Updater<StyleInfoMap>;\nexport type SetStyleInfo = (style: StyleInfo) => void;\nexport type SetStyleInfos = (style: StyleInfo[]) => void;\nexport type ResetStyleInfos = () => void;\n/**\n *\n * @param initStyleInfos Array of initial style information\n * @returns {{styleInfoMap: StyleInfoMap, setStyleInfo: SetStyleInfo}} where `styleInfoMap` is a map of style information and `setStyleInfo` is a function to update the map\n */\nexport const useStyleInfoMap = ({\n  initStyleInfos,\n  nrow,\n  ncol,\n}: {\n  initStyleInfos: StyleInfo[];\n  nrow: number;\n  ncol: number;\n}): {\n  styleInfoMap: StyleInfoMap;\n  setStyleInfo: SetStyleInfo;\n  setStyleInfos: SetStyleInfos;\n  resetStyleInfos: ResetStyleInfos;\n} => {\n  const [styleInfoMap, setStyleInfoMap] = useImmer<StyleInfoMap>(\n    new Map<string, StyleInfoStored>()\n  );\n  const setStyleInfo: SetStyleInfo = useCallback(\n    (styleInfo: StyleInfo) => {\n      const { location, rows, cols } = styleInfo;\n\n      setStyleInfoMap((draft) => {\n        const rowArr = rows ?? Array.from({ length: nrow }, (_, i) => i);\n        const colArr = cols ?? Array.from({ length: ncol }, (_, j) => j);\n        for (const rowIndex of rowArr) {\n          for (const columnIndex of colArr) {\n            const key = makeStyleInfoMapKey({\n              location,\n              rowIndex,\n              columnIndex,\n            });\n            const prevObj = draft.get(key) ?? { style: {}, class: undefined };\n            let newClass: string | undefined = undefined;\n            if (prevObj.class) {\n              if (styleInfo.class) {\n                newClass = `${prevObj.class} ${styleInfo.class}`;\n              } else {\n                newClass = prevObj.class;\n              }\n            } else {\n              if (styleInfo.class) {\n                newClass = styleInfo.class;\n              } else {\n                newClass = undefined;\n              }\n            }\n            draft.set(key, {\n              location,\n              rowIndex,\n              columnIndex,\n              style: {\n                ...prevObj.style,\n                ...styleInfo.style,\n              },\n              class: newClass,\n            });\n          }\n        }\n      });\n    },\n    [ncol, nrow, setStyleInfoMap]\n  );\n\n  const resetStyleInfos = useCallback(() => {\n    setStyleInfoMap((draft) => {\n      draft.clear();\n    });\n  }, [setStyleInfoMap]);\n\n  const setStyleInfos = useCallback(\n    (styleInfos: StyleInfo[]) => {\n      // When settings styleInfos, reset all style infos\n      resetStyleInfos();\n      for (const styleInfo of styleInfos) {\n        setStyleInfo(styleInfo);\n      }\n    },\n    [setStyleInfo, resetStyleInfos]\n  );\n\n  // Init all style infos\n  useEffect(() => {\n    setStyleInfos(initStyleInfos);\n  }, [initStyleInfos, setStyleInfos]);\n\n  return {\n    styleInfoMap,\n    setStyleInfo,\n    setStyleInfos,\n    resetStyleInfos,\n  } as const;\n};\n\nexport const styleInfoMapHasKey = (\n  x: StyleInfoMap,\n  location: StyleLocation,\n  rowIndex: number,\n  columnIndex: number\n) => {\n  return x.has(makeStyleInfoMapKey({ location, rowIndex, columnIndex }));\n};\nexport const getCellStyle = (\n  x: StyleInfoMap,\n  location: StyleLocation,\n  rowIndex: number,\n  columnIndex: number\n): { cellStyle: CellStyle | undefined; cellClassName: string | undefined } => {\n  const key = makeStyleInfoMapKey({ location, rowIndex, columnIndex });\n  const obj = x.get(key);\n  return {\n    cellStyle: obj?.style,\n    cellClassName: obj?.class,\n  };\n};\n\n// Use a DOM element to convert CSS string to object\nconst cssStringToObjDomElement = document.createElement(\"cssStringToObj\");\nfunction cssStringToObj(strVal: string): { [key: string]: string } {\n  cssStringToObjDomElement.style.cssText = strVal;\n  const style = cssStringToObjDomElement.style;\n\n  const ret: { [key: string]: string } = {};\n  Array.from(style).forEach((key) => {\n    ret[key] = style.getPropertyValue(key);\n  });\n\n  return ret;\n}\n", "export default `\n/*\n *\n * # Variables\n *\n */\nshiny-data-frame {\n  --shiny-datagrid-font-size: 0.9em;\n  --shiny-datagrid-padding-x: 0.5em;\n  --shiny-datagrid-padding-y: 0.3em;\n  --shiny-datagrid-padding: var(--shiny-datagrid-padding-y) var(--shiny-datagrid-padding-x);\n  --shiny-datagrid-grid-header-bgcolor: var(--bs-light, #eee);\n  --shiny-datagrid-grid-header-gridlines-color: var(--bs-border-color, #ccc);\n  --shiny-datagrid-grid-header-gridlines-style: solid;\n  --shiny-datagrid-grid-gridlines-color: var(--bs-border-color, #ccc);\n  --shiny-datagrid-grid-gridlines-style: solid;\n  --shiny-datagrid-table-header-bottom-border: 1px solid;\n  --shiny-datagrid-table-top-border: 1px solid;\n  --shiny-datagrid-table-bottom-border: 1px solid;\n  --shiny-datagrid-grid-body-hover-bgcolor: var(--shiny-datagrid-grid-header-bgcolor);\n  --shiny-datagrid-grid-body-selected-bgcolor: #b4d5fe;\n  --shiny-datagrid-grid-body-selected-color: var(--bs-dark);\n  --shiny-datagrid-grid-header-selected-bgcolor: color-mix(\n    in srgb,\n    var(--shiny-datagrid-grid-header-bgcolor) 30%,\n    var(--shiny-datagrid-grid-body-selected-bgcolor)\n  );\n  --shiny-datagrid-table-cell-edit-background-color: var(--bs-body-bg);\n  --shiny-datagrid-table-cell-edit-success-border-color: color-mix(in srgb, var(--bs-success) 20%, transparent);\n  --shiny-datagrid-table-cell-edit-success-border-style: var(--shiny-datagrid-grid-gridlines-style);\n  --shiny-datagrid-table-cell-edit-success-bgcolor: color-mix(in srgb, var(--bs-success) 10%, transparent);\n  --shiny-datagrid-table-cell-edit-failure-border-color: color-mix(in srgb, var(--bs-danger) 40%, transparent);\n  --shiny-datagrid-table-cell-edit-failure-border-style: var(--shiny-datagrid-grid-gridlines-style);\n  --shiny-datagrid-table-cell-edit-failure-bgcolor: color-mix(in srgb, var(--bs-danger) 10%, transparent);\n  --shiny-datagrid-table-cell-edit-saving-color: var(--bs-gray-500);\n}\n\n/*\n *\n * # BASE STYLES\n *\n */\nshiny-data-frame *,\nshiny-data-frame *::before,\nshiny-data-frame *::after {\n  box-sizing: border-box;\n}\n\nshiny-data-frame .shiny-data-grid svg.sort-arrow {\n  display: inline-block;\n  width: 0.85em;\n  height: 0.85em;\n  margin-bottom: 0.15em;\n}\n\nshiny-data-frame .shiny-data-grid {\n  max-width: 100%;\n  height: auto;\n}\nshiny-data-frame .shiny-data-grid.scrolling {\n  height: 500px;\n}\nshiny-data-frame .shiny-data-grid > table {\n  border-collapse: separate;\n  border-spacing: 0;\n}\nshiny-data-frame .shiny-data-grid > table > thead {\n  position: sticky;\n  top: 0;\n}\nshiny-data-frame .shiny-data-grid > table > thead > tr > th {\n  text-align: left;\n  white-space: nowrap;\n}\nshiny-data-frame .shiny-data-grid > table > thead > tr > th:focus-visible {\n  outline: 5px auto Highlight;\n  outline: 5px auto -webkit-focus-ring-color;\n}\nshiny-data-frame .shiny-data-grid > table.filtering > thead > tr:nth-last-child(2) > th {\n  border-bottom: none;\n}\nshiny-data-frame .shiny-data-grid > table.filtering > thead > tr.filters > th {\n  font-weight: unset;\n  padding-top: 0;\n  /* Slight boost to bottom padding */\n  padding-bottom: var(--shiny-datagrid-padding-x);\n}\nshiny-data-frame .shiny-data-grid > table.filtering > thead > tr.filters > th > input {\n  width: 100%;\n}\n\nshiny-data-frame .shiny-data-grid > .shiny-data-grid-summary {\n  font-size: var(--shiny-datagrid-font-size);\n  padding-top: 0.3em;\n}\n\n/*\n *\n * # DATATABLE STYLES\n *\n */\nshiny-data-frame .shiny-data-grid.shiny-data-grid-table {\n  border-top: var(--shiny-datagrid-table-top-border);\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-table.scrolling {\n  border-bottom: var(--shiny-datagrid-table-bottom-border);\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-table > table > thead > tr:last-child > th {\n  border-bottom: var(--shiny-datagrid-table-header-bottom-border);\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-table > table > tbody > tr[aria-selected=true] {\n  --shiny-datagrid-grid-gridlines-color: var(--shiny-datagrid-grid-body-selected-bgcolor);\n  background-color: var(--shiny-datagrid-grid-body-selected-bgcolor);\n  color: var(--shiny-datagrid-grid-body-selected-color);\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-table > table > tbody > tr[aria-selected=true] td {\n  background-color: var(--shiny-datagrid-grid-body-selected-bgcolor);\n  color: var(--shiny-datagrid-grid-body-selected-color);\n}\n\n/*\n *\n * # GRID STYLES\n *\n */\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid > table {\n  font-size: var(--shiny-datagrid-font-size);\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid > table > thead > tr > th,\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid > table > thead > tr > td {\n  background-color: var(--shiny-datagrid-grid-header-bgcolor);\n  padding: var(--shiny-datagrid-padding);\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid > table > tbody > tr:focus-visible {\n  outline: 5px auto Highlight;\n  outline: 5px auto -webkit-focus-ring-color;\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid > table > tbody > tr:hover {\n  --shiny-datagrid-grid-gridlines-color: inherit;\n  background-color: var(--shiny-datagrid-grid-body-hover-bgcolor);\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid > table > tbody > tr[aria-selected=true] {\n  background-color: var(--shiny-datagrid-grid-body-selected-bgcolor);\n  color: var(--shiny-datagrid-grid-body-selected-color);\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid > table > tbody > tr > td {\n  padding: var(--shiny-datagrid-padding);\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid > table > tbody > tr:not([aria-selected=true]) > td.row-number {\n  background-color: var(--shiny-datagrid-grid-header-bgcolor);\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid > table > tbody > tr[aria-selected=true] > td.row-number {\n  background-color: var(--shiny-datagrid-grid-header-selected-bgcolor);\n}\n\n/* ## Grid borders */\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid > table {\n  border-collapse: separate;\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid > table > thead > tr:first-child > th {\n  border-top-style: var(--shiny-datagrid-grid-gridlines-style);\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid > table > thead > tr > th {\n  border: 1px var(--shiny-datagrid-grid-gridlines-style) var(--shiny-datagrid-grid-header-gridlines-color);\n  border-top-style: none;\n  border-left-style: none;\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid > table > thead > tr > th:first-child {\n  border-left-style: var(--shiny-datagrid-grid-gridlines-style);\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid > table > tbody > tr > td {\n  border: 1px var(--shiny-datagrid-grid-gridlines-style) var(--shiny-datagrid-grid-gridlines-color);\n  border-top-style: none;\n  border-left-style: none;\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid > table > tbody > tr > td:first-child {\n  border-left-style: var(--shiny-datagrid-grid-gridlines-style);\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid.scrolling {\n  border: var(--shiny-datagrid-grid-gridlines-style) 1px var(--shiny-datagrid-grid-header-gridlines-color);\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid.scrolling > table > thead > tr:first-child > th {\n  border-top-style: none;\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid.scrolling > table > tbody > tr:last-child > td {\n  border-bottom-style: none;\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid.scrolling > table > thead > tr > th:first-child,\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid.scrolling > table > tbody > tr > td:first-child {\n  border-left-style: none;\n}\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid.scrolling > table > thead > tr > th:last-child,\nshiny-data-frame .shiny-data-grid.shiny-data-grid-grid.scrolling > table > tbody > tr > td:last-child {\n  border-right-style: none;\n}\n\n/*\n *\n * # FILLING LAYOUT STYLES\n *\n */\n/* Center the table when inside of a card */\n.card-body shiny-data-frame .shiny-data-grid {\n  margin-left: auto;\n  margin-right: auto;\n}\n\n/* When .shiny-data-grid is not scrolling, the containers shouldn't flex */\nshiny-data-frame:has(> div > .shiny-data-grid:not(.scrolling)) {\n  flex: 0 0 auto;\n}\nshiny-data-frame > div:has(> .shiny-data-grid:not(.scrolling)) {\n  flex: 0 0 auto;\n}\n\nshiny-data-frame .table-corner {\n  width: 0;\n  min-width: 25px;\n}\n\n/*\n *\n * # CELL EDITING STYLES\n *\n */\nshiny-data-frame .shiny-data-grid > table > tbody > tr > td.cell-edit-editing {\n  color: transparent;\n  position: relative;\n}\nshiny-data-frame .shiny-data-grid > table > tbody > tr > td.cell-edit-editing :not(textarea) {\n  visibility: hidden;\n}\nshiny-data-frame .shiny-data-grid > table > tbody > tr > td.cell-edit-editing > textarea {\n  position: absolute;\n  padding: var(--shiny-datagrid-padding);\n  background-color: var(--shiny-datagrid-table-cell-edit-background-color);\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  border: none;\n  resize: none;\n}\n\nshiny-data-frame .shiny-data-grid > table > tbody > tr > td.cell-html {\n  cursor: default;\n}\nshiny-data-frame .shiny-data-grid > table > tbody > tr > td.cell-editable {\n  cursor: text;\n}\nshiny-data-frame .shiny-data-grid > table > tbody > tr > td.cell-edit-saving {\n  color: var(--shiny-datagrid-table-cell-edit-saving-color);\n  font-style: var(--shiny-datagrid-table-cell-edit-saving-font-style);\n}\nshiny-data-frame .shiny-data-grid > table > tbody > tr > td.cell-edit-failure {\n  outline: 2px var(--shiny-datagrid-table-cell-edit-failure-border-style) var(--shiny-datagrid-table-cell-edit-failure-border-color);\n  background-color: var(--shiny-datagrid-table-cell-edit-failure-bgcolor);\n}`;\n", "import React, { useState } from \"react\";\nimport { findFirstItemInView } from \"./dom-utils\";\n\nexport interface TabindexGroup<TElement extends HTMLElement> {\n  containerTabIndex: number;\n  containerHandlers: {\n    onFocus: (event: React.FocusEvent<TElement>) => void;\n    onBlur: (event: React.FocusEvent<TElement>) => void;\n  };\n}\n\nexport function useTabindexGroup<TContainerElement extends HTMLElement>(\n  container: TContainerElement | null,\n  focusableItems: () => NodeList,\n  extraPadding?: {\n    top?: number;\n    right?: number;\n    bottom?: number;\n    left?: number;\n  }\n): TabindexGroup<TContainerElement> {\n  const [tabIndex, setTabIndex] = useState(0);\n\n  const onFocus = React.useCallback(\n    (event: React.FocusEvent<TContainerElement>) => {\n      // When focus is within (or on, but we only really care about within) the\n      // container, remove it from the tab order. If we don't set the tab stop to -1,\n      // then the logic below (that, on container focus, moves focus to the first item)\n      // causes Shift-Tab from a focused item to break, as focus moves to the container\n      // and then (back) to the first item.\n      setTabIndex(-1);\n\n      if (event.target !== event.currentTarget) {\n        // Not interested in capturing, only care about focus on the container itself\n        return;\n      }\n\n      findFirstItemInView(container!, focusableItems(), extraPadding)?.focus();\n    },\n    [container, focusableItems, extraPadding]\n  );\n\n  const onBlur = React.useCallback(\n    (event: React.FocusEvent<TContainerElement>) => {\n      setTabIndex(0);\n    },\n    []\n  );\n\n  return {\n    containerTabIndex: tabIndex,\n    containerHandlers: {\n      onFocus,\n      onBlur,\n    },\n  };\n}\n", "import { VirtualItem } from \"@tanstack/react-virtual\";\nimport React, { useMemo } from \"react\";\n\n/**\n * Create a summary\n *\n * @param summaryTemplate A string with \"{start}\", \"{end}\", and \"{total}\"\n * @param scrollContainer Scrolling container of the table/grid\n * @param virtualRows VirtualItem objects that might currently be visible\n * @param thead The thead tag of the table\n * @param nrows Number of total rows of data that exist\n */\nexport function useSummary(\n  summaryTemplate: string | boolean | undefined,\n  scrollContainer: HTMLElement | null,\n  virtualRows: VirtualItem<Element>[],\n  thead: HTMLTableSectionElement | null,\n  nrows: number\n): JSX.Element | null {\n  return useMemo(() => {\n    const summaryOption = summaryTemplate ?? true;\n    if (!summaryOption) {\n      return null;\n    }\n\n    const template =\n      typeof summaryOption === \"string\"\n        ? summaryOption\n        : \"Viewing rows {start} through {end} of {total}\";\n\n    if (!scrollContainer) {\n      return null;\n    }\n    if (virtualRows.length === 0) {\n      return null;\n    }\n\n    if (!thead) return null;\n\n    const top = scrollContainer.scrollTop + thead.clientHeight;\n    const bot = scrollContainer.scrollTop + scrollContainer.clientHeight;\n\n    const [firstIndex, lastIndex] = findRangeIndex(\n      top,\n      bot,\n      virtualRows,\n      (vrow, start) => vrow.start + vrow.size / 2\n    );\n\n    if (firstIndex === null || lastIndex === null) {\n      // Something must've gone wrong if there are rows but none of them are within the\n      // visible scroll area... shrug\n      return null;\n    }\n\n    const firstRow = virtualRows[firstIndex];\n    const lastRow = virtualRows[lastIndex];\n\n    if (firstRow === undefined || lastRow === undefined) {\n      // This should never happen, but just in case...\n      return null;\n    }\n\n    if (firstRow.index === 0 && lastRow.index === nrows - 1) {\n      // Viewing all rows; no need for a summary\n      return null;\n    }\n\n    const summaryMessage = formatSummary(\n      template,\n      firstRow.index + 1,\n      lastRow.index + 1,\n      nrows\n    );\n\n    return <div className=\"shiny-data-grid-summary\">{summaryMessage}</div>;\n  }, [summaryTemplate, scrollContainer, virtualRows, thead, nrows]);\n}\n\n/**\n * Find the subset of (sorted) items that are between start and end (inclusive), where\n * each item's value to compare is calculated by a mapping function. The mapping\n * function may behave differently when comparing to start vs. end.\n *\n * @param start The smallest value to include.\n * @param end The largest value to include.\n * @param items A set of items to be evaluated, in sorted order.\n * @param map A function for converting from an item to a comparison value; for example,\n *   if 'start' and 'end' are vertical pixel coordinates, then the function might\n *   return the item's vertical top (for start) or bottom (for end) coordinate.\n * @returns The start and end indexes into the 'items' array indicating the first and\n *   last item that is included.\n */\nfunction findRangeIndex<TItem>(\n  start: number,\n  end: number,\n  items: TItem[],\n  map: (x: TItem, start: boolean) => number\n): [first: number | null, last: number | null] {\n  let first: number | null = null;\n  let last: number | null = null;\n\n  for (let i = 0; i < items.length; i++) {\n    const item: TItem = items[i]!;\n    if (first === null) {\n      if (map(item, true) >= start) {\n        first = i;\n        last = i;\n      }\n    } else {\n      if (map(item, false) <= end) {\n        last = i;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return [first, last];\n}\n\nfunction formatSummary(\n  template: string,\n  start: number,\n  end: number,\n  total: number\n) {\n  return template.replace(/\\{(start|end|total)\\}/g, (substr, token) => {\n    if (token === \"start\") {\n      return start + \"\";\n    } else if (token === \"end\") {\n      return end + \"\";\n    } else if (token === \"total\") {\n      return total + \"\";\n    } else {\n      return substr;\n    }\n  });\n}\n", "/* eslint-disable react-hooks/rules-of-hooks */\n\n// TODO-barret-future; Try to group all related code into a file and make index.tsx as small as possible. Try to move all logic into files and keep the main full of `useFOO` functions.\n\n// TODO-barret-future; Instead of deconstructinng all of the use state objects, keep it as a dictionary and shorten the method names. The docs can live on the _useFoo` function return type. Ex: CellEditMapReturnObject 's setCellEditMapAtLoc should contain JSDoc on it's objects. Then we'd have a `cellEditMap.setAtLoc` method.\n\nimport {\n  Column,\n  ColumnDef,\n  RowData,\n  RowModel,\n  TableOptions,\n  flexRender,\n  getCoreRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { Virtualizer, useVirtualizer } from \"@tanstack/react-virtual\";\nimport React, {\n  FC,\n  StrictMode,\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n} from \"react\";\nimport { Root, createRoot } from \"react-dom/client\";\nimport { ErrorsMessageValue } from \"rstudio-shiny/srcts/types/src/shiny/shinyapp\";\nimport { useImmer } from \"use-immer\";\nimport { TableBodyCell } from \"./cell\";\nimport { getCellEditMapObj, useCellEditMap } from \"./cell-edit-map\";\nimport {\n  addPatchToData,\n  cellPatchPyArrToCellPatchArr,\n  type CellPatchPy,\n} from \"./data-update\";\nimport { findFirstItemInView, getStyle } from \"./dom-utils\";\nimport { ColumnFiltersState, Filter, FilterValue, useFilters } from \"./filter\";\nimport type { CellSelection, SelectionModesProp } from \"./selection\";\nimport { SelectionModes, initSelectionModes, useSelection } from \"./selection\";\nimport { SortingState, useSort } from \"./sort\";\nimport { SortArrow } from \"./sort-arrows\";\nimport { StyleInfo, getCellStyle, useStyleInfoMap } from \"./style-info\";\nimport css from \"./styles.scss\";\nimport { useTabindexGroup } from \"./tabindex-group\";\nimport { useSummary } from \"./table-summary\";\nimport { PandasData, PatchInfo, TypeHint } from \"./types\";\n\n// TODO-barret-future set selected cell as input! (Might be a followup?)\n\n// TODO-barret; Type support\n// export interface PandasData<TIndex> {\n//   columns: ReadonlyArray<string>;\n//   // index: ReadonlyArray<TIndex>;\n//   data: unknown[][];\n//   typeHints?: ReadonlyArray<TypeHint>;\n//   options: DataGridOptions;\n// }\n\ndeclare module \"@tanstack/table-core\" {\n  interface ColumnMeta<TData extends RowData, TValue> {\n    colIndex: number;\n    typeHint: TypeHint | undefined;\n    isHtmlColumn: boolean;\n  }\n  // interface TableMeta<TData extends RowData> {\n  //   updateCellsData: (cellInfos: UpdateCellData[]) => void;\n  // }\n}\n\n// // TODO-barret-future; Use window.setSelectionRange() and this method to reselect text when scrolling out of view\n// const useSelectedText = () => {\n//   const [text, setText] = useState(\"\");\n//   const select = () => {\n//     const selected = window.getSelection() as Selection;\n//     setText(selected.toString());\n//   };\n//   return [select, text] as const;\n// };\n\n//\n\n// TODO: Right-align numeric columns, maybe change font\n// TODO: Explicit column widths\n// TODO: Filtering\n// TODO: Editing\n// TODO: Pagination\n// TODO: Range selection + copying\n// TODO: Find\n// TODO: Server-side mode (don't pull all data to client at once)\n// TODO: Localization of summary\n// TODO: Accessibility review\n// TODO: Drag to resize columns\n// TODO: Drag to resize table/grid\n// TODO: Row numbers\n\ntype ShinyDataGridServerInfo<TIndex> = {\n  payload: PandasData<TIndex>;\n  patchInfo: PatchInfo;\n  selectionModes: SelectionModesProp;\n};\n\ninterface ShinyDataGridProps<TIndex> {\n  id: string | null;\n  gridInfo: ShinyDataGridServerInfo<TIndex>;\n  bgcolor?: string;\n}\n\nconst ShinyDataGrid: FC<ShinyDataGridProps<unknown>> = ({\n  id,\n  gridInfo: { payload, patchInfo, selectionModes: selectionModesProp },\n  bgcolor,\n}) => {\n  const {\n    columns: columnsProp,\n    typeHints: typeHintsProp,\n    data: tableDataProp,\n    options: payloadOptions = {\n      width: undefined,\n      height: undefined,\n      fill: false,\n      styles: [],\n    },\n    htmlDeps,\n  } = payload;\n  const {\n    width,\n    height,\n    fill,\n    filters: withFilters,\n    styles: initStyleInfos,\n  } = payloadOptions;\n\n  const containerRef = useRef<HTMLDivElement>(null);\n  const theadRef = useRef<HTMLTableSectionElement>(null);\n  const tbodyRef = useRef<HTMLTableSectionElement>(null);\n\n  const [columns, setColumns] = useImmer(columnsProp);\n  const [typeHints, setTypeHints] = useImmer(typeHintsProp);\n\n  const _useStyleInfo = useStyleInfoMap({\n    initStyleInfos: initStyleInfos ?? [],\n    nrow: tableDataProp.length,\n    ncol: columns.length,\n  });\n  /**\n   * Contains all style information for the full table.\n   *\n   * Currently only the \"data\" location is supported.\n   */\n  const styleInfoMap = _useStyleInfo.styleInfoMap;\n  const { setStyleInfos } = _useStyleInfo;\n\n  const _cellEditMap = useCellEditMap();\n  /**\n   * Contains all cell state and edit information\n   *\n   * If a cell's state is not in this map, it is assumed to be in the default display state.\n   */\n  const cellEditMap = _cellEditMap.cellEditMap;\n  /**\n   * Set a cell's state or edit value in the `cellEditMap`\n   */\n  const setCellEditMapAtLoc = _cellEditMap.setCellEditMapAtLoc;\n  /**\n   * Reset the `cellEditMap` to an empty state\n   */\n  const resetCellEditMap = _cellEditMap.resetCellEditMap;\n\n  /**\n   * Determines if the user is allowed to edit cells in the table.\n   */\n  const editCellsIsAllowed = payloadOptions[\"editable\"] === true;\n\n  /**\n   * Determines if any cell is currently being edited\n   *\n   * This is currently being used to prevent row selection when a cell is being edited.\n   */\n  const isEditingCell = useMemo<boolean>(() => {\n    for (const cellEdit of cellEditMap.values()) {\n      if (cellEdit.isEditing) {\n        return true;\n      }\n    }\n    return false;\n  }, [cellEditMap]);\n\n  /**\n   * Column definitions for the table\n   */\n  const coldefs = useMemo<ColumnDef<unknown[], unknown>[]>(\n    () =>\n      columns.map((colname, colIndex) => {\n        const typeHint = typeHints?.[colIndex];\n\n        const isHtmlColumn = typeHint?.type === \"html\";\n        const enableSorting = isHtmlColumn ? false : undefined;\n\n        return {\n          accessorFn: (row, index) => {\n            return row[colIndex];\n          },\n          // TODO: delegate this decision to something in filter.tsx\n          filterFn:\n            typeHint?.type === \"numeric\" ? \"inNumberRange\" : \"includesString\",\n          header: colname,\n          meta: {\n            colIndex,\n            isHtmlColumn,\n            typeHint,\n          },\n          cell: ({ getValue }) => {\n            const ret = getValue();\n\n            // Regardless of type, if the value is null or undefined,\n            // return an empty string\n            if (ret === null || ret === undefined) {\n              return \"\";\n            }\n            switch (typeHint?.type) {\n              // Return the value as is\n              case \"numeric\":\n              case \"date\":\n              case \"datetime\":\n              case \"duration\":\n              case \"categorical\":\n              case \"html\":\n                return ret;\n              // Convert the value to a string\n              case \"string\":\n              case \"boolean\":\n                return String(ret);\n              // Convert the value to a JSON string if it isn't a string already\n              case \"unknown\":\n              case \"object\":\n                if (typeof ret === \"string\") {\n                  return ret;\n                }\n                return JSON.stringify(ret);\n              default:\n                return ret;\n            }\n          },\n          enableSorting,\n        };\n      }),\n    [columns, typeHints]\n  );\n\n  // TODO-barret-future; Possible pagination helper\n  // function useSkipper() {\n  //   const shouldSkipRef = React.useRef(true);\n  //   const shouldSkip = shouldSkipRef.current;\n\n  //   // Wrap a function with this to skip a pagination reset temporarily\n  //   const skip = React.useCallback(() => {\n  //     shouldSkipRef.current = false;\n  //   }, []);\n\n  //   React.useEffect(() => {\n  //     shouldSkipRef.current = true;\n  //   });\n\n  //   return [shouldSkip, skip] as const;\n  // }\n  // const [autoResetPageIndex, skipAutoResetPageIndex] = useSkipper();\n\n  /**\n   * Copy of the original data\n   */\n  const dataOriginal = useMemo(() => tableDataProp, [tableDataProp]);\n\n  const _tableData = useImmer(tableDataProp);\n  /** Up-to-date data for the table */\n  const tableData = _tableData[0];\n  /** Function to update the data in the table */\n  const setTableData = _tableData[1];\n\n  const getColDefs = (): ColumnDef<unknown[], unknown>[] => {\n    return coldefs;\n  };\n\n  const _sort = useSort({ getColDefs });\n  /** Sorting state of the table */\n  const sorting = _sort.sorting;\n  /** Table options specific for sorting */\n  const sortTableStateOptions = _sort.sortTableStateOptions;\n  /** Sorting state of the table */\n  const sortTableOptions = _sort.sortTableOptions;\n  /** Set the sorting state of the table */\n  const setSorting = _sort.setSorting;\n\n  const {\n    columnFilters,\n    columnFiltersState,\n    filtersTableOptions,\n    setColumnFilters,\n  } = useFilters<unknown[]>(withFilters);\n\n  const updateData = useCallback(\n    ({\n      data,\n      columns,\n      typeHints,\n    }: {\n      data: PandasData<unknown>[\"data\"];\n      columns: readonly string[];\n      typeHints: readonly TypeHint[] | undefined;\n    }) => {\n      setColumns(columns);\n      setTableData(data);\n      setTypeHints(typeHints);\n      resetCellEditMap();\n\n      // Make map for quick lookup of type hints\n      const newTypeHintMap = new Map<string, TypeHint>();\n      typeHints?.forEach((hint, i) => {\n        newTypeHintMap.set(columns[i]!, hint);\n      });\n      // Filter out sorting and column filters that are no longer valid\n      const newSort = sorting.filter((sort) => newTypeHintMap.has(sort.id));\n      const newColumnFilter = columnFilters.filter((filter) => {\n        const typeHint = newTypeHintMap.get(filter.id);\n        if (!typeHint) return false;\n        // Maintain the filter if it's a numeric filter\n        // Drop if it's a string filter\n        if (typeHint.type === \"numeric\") {\n          return (\n            filter.value === null ||\n            (Array.isArray(filter.value) &&\n              filter.value.every((v) => v !== null))\n          );\n        }\n        // Maintain string filters\n        return typeof filter.value === \"string\";\n      });\n\n      setColumnFilters(newColumnFilter);\n      setSorting(newSort);\n    },\n    [\n      columnFilters,\n      resetCellEditMap,\n      setColumnFilters,\n      setColumns,\n      setSorting,\n      setTableData,\n      setTypeHints,\n      sorting,\n    ]\n  );\n\n  const options: TableOptions<unknown[]> = {\n    data: tableData,\n    columns: coldefs,\n    state: {\n      ...sortTableStateOptions,\n      ...columnFiltersState,\n    },\n    getCoreRowModel: getCoreRowModel(),\n    ...sortTableOptions,\n    ...filtersTableOptions,\n    // debugAll: true,\n    // Provide our updateCellsData function to our table meta\n    // autoResetPageIndex,\n    // meta: {\n    //   updateCellsData: (cellInfos: UpdateCellData[]) => {},\n    // },\n  };\n  const table = useReactTable(options);\n\n  const rowVirtualizer = useVirtualizer({\n    count: table.getFilteredRowModel().rows.length,\n    getScrollElement: () => containerRef.current,\n    estimateSize: () => 31,\n    overscan: 15,\n    paddingStart: theadRef.current?.clientHeight ?? 0,\n    // In response to https://github.com/posit-dev/py-shiny/pull/538/files#r1228352446\n    // (the default scrollingDelay is 150)\n    isScrollingResetDelay: 10,\n  });\n\n  // Reset scroll when dataset changes\n  useLayoutEffect(() => {\n    rowVirtualizer.scrollToOffset(0);\n  }, [payload, rowVirtualizer]);\n\n  const totalSize = rowVirtualizer.getTotalSize();\n  const virtualRows = rowVirtualizer.getVirtualItems();\n\n  // paddingTop and paddingBottom are to force the <tbody> to add up to the correct\n  // virtual height.\n  // paddingTop must subtract out the thead height, since thead is inside the scroll\n  // container but not virtualized.\n  const paddingTop =\n    (virtualRows.length > 0 ? virtualRows?.[0]?.start || 0 : 0) -\n      (theadRef.current?.clientHeight ?? 0) ?? 0;\n  const paddingBottom =\n    virtualRows.length > 0\n      ? totalSize - (virtualRows?.[virtualRows.length - 1]?.end || 0)\n      : 0;\n\n  const summary = useSummary(\n    payloadOptions[\"summary\"],\n    containerRef?.current,\n    virtualRows,\n    theadRef.current,\n    rowVirtualizer.options.count\n  );\n\n  const tableStyle = payloadOptions[\"style\"] ?? \"grid\";\n  const containerClass =\n    tableStyle === \"grid\" ? \"shiny-data-grid-grid\" : \"shiny-data-grid-table\";\n  const tableClass = tableStyle === \"table\" ? \"table table-sm\" : null;\n\n  // ### Row selection ###############################################################\n\n  const selectionModes = initSelectionModes(selectionModesProp);\n\n  const canSelect = !selectionModes.isNone();\n  const canMultiRowSelect = selectionModes.row !== SelectionModes._rowEnum.NONE;\n\n  const selection = useSelection<string, HTMLTableRowElement>({\n    isEditingCell,\n    editCellsIsAllowed,\n    selectionModes,\n    keyAccessor: (el) => {\n      return el.dataset.key!;\n    },\n    focusEscape: (el) => {\n      setTimeout(() => {\n        el?.blur();\n        containerRef.current?.focus();\n      }, 0);\n    },\n    focusOffset: (key, offset = 0) => {\n      const rowModel = table.getSortedRowModel();\n      let index = rowModel.rows.findIndex((row) => row.id === key);\n      if (index < 0) {\n        return null;\n      }\n      index += offset;\n      if (index < 0 || index >= rowModel.rows.length) {\n        return null;\n      }\n      const targetKey = rowModel.rows[index]!.id;\n      rowVirtualizer.scrollToIndex(index);\n      setTimeout(() => {\n        const targetEl = containerRef.current?.querySelector(\n          `[data-key='${targetKey}']`\n        ) as HTMLElement | null;\n        targetEl?.focus();\n      }, 0);\n      return targetKey;\n    },\n    between: (fromKey, toKey) =>\n      findKeysBetween(table.getSortedRowModel(), fromKey, toKey),\n    onKeyDownEnter: (el) => {\n      // Retrieve all editable cells in the row\n      const childrenNodes = Array(...el.childNodes.values()).filter((node) => {\n        return (\n          node instanceof HTMLElement &&\n          node.classList.contains(\"cell-editable\")\n        );\n      });\n      if (childrenNodes.length === 0) return; // Quit early\n\n      // Find the first editable cell in the row\n      const firstItem = findFirstItemInView(\n        containerRef.current!,\n        childrenNodes\n      );\n      if (!firstItem) return; // Quit early\n\n      // Submit the double click event to the cell to trigger edit mode for the cell\n      const doubleClickEvent = new MouseEvent(\"dblclick\", {\n        bubbles: true,\n        cancelable: true,\n      });\n      firstItem.dispatchEvent(doubleClickEvent);\n    },\n  });\n\n  useEffect(() => {\n    const handleCellSelection = (\n      event: CustomEvent<{ cellSelection: CellSelection }>\n    ) => {\n      // We convert \"None\" to an empty tuple on the python side\n      // so an empty array indicates that selection should be cleared.\n\n      const cellSelection = event.detail.cellSelection;\n\n      if (cellSelection.type === \"none\") {\n        selection.clear();\n        return;\n        // } else if (cellSelection.type === \"all\") {\n        //   rowSelection.setMultiple(rowData.map((_, i) => String(i)));\n        //   return;\n      } else if (cellSelection.type === \"row\") {\n        selection.setMultiple(cellSelection.rows.map(String));\n        return;\n      } else {\n        console.error(\"Unhandled cell selection update:\", cellSelection);\n      }\n    };\n\n    if (!id) return;\n\n    const element = document.getElementById(id);\n    if (!element) return;\n\n    element.addEventListener(\n      \"updateCellSelection\",\n      handleCellSelection as EventListener\n    );\n\n    return () => {\n      element.removeEventListener(\n        \"updateCellSelection\",\n        handleCellSelection as EventListener\n      );\n    };\n  }, [id, selection, tableData]);\n\n  useEffect(() => {\n    if (!htmlDeps) return;\n    // Register the Shiny HtmlDependencies\n    window.Shiny.renderDependenciesAsync([...htmlDeps]);\n  }, [htmlDeps]);\n\n  useEffect(() => {\n    const handleAddPatches = (\n      event: CustomEvent<{\n        patches: CellPatchPy[];\n      }>\n    ) => {\n      const evtPatches = event.detail.patches;\n      const newPatches = cellPatchPyArrToCellPatchArr(evtPatches);\n\n      // Update data with extra patches\n      addPatchToData({\n        setData: setTableData,\n        newPatches,\n        setCellEditMapAtLoc,\n      });\n    };\n\n    if (!id) return;\n\n    const element = document.getElementById(id);\n    if (!element) return;\n\n    element.addEventListener(\"addPatches\", handleAddPatches as EventListener);\n\n    return () => {\n      element.removeEventListener(\n        \"addPatches\",\n        handleAddPatches as EventListener\n      );\n    };\n  }, [columns, id, setCellEditMapAtLoc, setSorting, setTableData]);\n\n  useEffect(() => {\n    const handleUpdateData = (\n      event: CustomEvent<{\n        data: PandasData<unknown>[\"data\"];\n        columns: PandasData<unknown>[\"columns\"];\n        typeHints: PandasData<unknown>[\"typeHints\"];\n      }>\n    ) => {\n      const evtData = event.detail;\n\n      updateData(evtData);\n    };\n\n    if (!id) return;\n\n    const element = document.getElementById(id);\n    if (!element) return;\n\n    element.addEventListener(\"updateData\", handleUpdateData as EventListener);\n\n    return () => {\n      element.removeEventListener(\n        \"updateData\",\n        handleUpdateData as EventListener\n      );\n    };\n  }, [columns, id, resetCellEditMap, setTableData, updateData]);\n\n  useEffect(() => {\n    const handleColumnSort = (\n      event: CustomEvent<{ sort: { col: number; desc: boolean }[] }>\n    ) => {\n      const shinySorting = event.detail.sort;\n      const columnSorting: SortingState = [];\n\n      shinySorting.map((sort) => {\n        columnSorting.push({\n          id: columns[sort.col]!,\n          desc: sort.desc,\n        });\n      });\n      setSorting(columnSorting);\n    };\n\n    if (!id) return;\n\n    const element = document.getElementById(id);\n    if (!element) return;\n\n    element.addEventListener(\n      \"updateColumnSort\",\n      handleColumnSort as EventListener\n    );\n\n    return () => {\n      element.removeEventListener(\n        \"updateColumnSort\",\n        handleColumnSort as EventListener\n      );\n    };\n  }, [columns, id, setSorting]);\n\n  useEffect(() => {\n    const handleColumnFilter = (\n      event: CustomEvent<{ filter: { col: number; value: FilterValue }[] }>\n    ) => {\n      const shinyFilters = event.detail.filter;\n\n      const columnFilters: ColumnFiltersState = [];\n      shinyFilters.map((filter) => {\n        columnFilters.push({\n          id: columns[filter.col]!,\n          value: filter.value,\n        });\n      });\n      setColumnFilters(columnFilters);\n    };\n\n    if (!id) return;\n\n    const element = document.getElementById(id);\n    if (!element) return;\n\n    element.addEventListener(\n      \"updateColumnFilter\",\n      handleColumnFilter as EventListener\n    );\n\n    return () => {\n      element.removeEventListener(\n        \"updateColumnFilter\",\n        handleColumnFilter as EventListener\n      );\n    };\n  }, [columns, id, setColumnFilters]);\n\n  useEffect(() => {\n    const handleStyles = (event: CustomEvent<{ styles: StyleInfo[] }>) => {\n      const styles = event.detail.styles;\n      setStyleInfos(styles);\n    };\n\n    if (!id) return;\n\n    const element = document.getElementById(id);\n    if (!element) return;\n\n    element.addEventListener(\"updateStyles\", handleStyles as EventListener);\n\n    return () => {\n      element.removeEventListener(\n        \"updateStyles\",\n        handleStyles as EventListener\n      );\n    };\n  }, [id, setStyleInfos]);\n\n  useEffect(() => {\n    if (!id) return;\n    let shinyValue: CellSelection | null = null;\n    if (selectionModes.isNone()) {\n      shinyValue = null;\n    } else if (selectionModes.row !== SelectionModes._rowEnum.NONE) {\n      const rowSelectionKeys = selection.keys().toList();\n      const rowsById = table.getSortedRowModel().rowsById;\n      shinyValue = {\n        type: \"row\",\n        rows: rowSelectionKeys\n          .map((key) => {\n            if (!(key in rowsById)) {\n              return null;\n            }\n            return rowsById[key]!.index;\n          })\n          .filter((x): x is number => x !== null),\n      };\n    } else {\n      console.error(\"Unhandled row selection mode:\", selectionModes);\n    }\n    window.Shiny.setInputValue!(`${id}_cell_selection`, shinyValue);\n  }, [id, selection, selectionModes, table, table.getSortedRowModel]);\n\n  useEffect(() => {\n    if (!id) return;\n    const shinySort: { col: number; desc: boolean }[] = [];\n    sorting.map((sortObj) => {\n      const columnNum = columns.indexOf(sortObj.id);\n      shinySort.push({\n        col: columnNum,\n        desc: sortObj.desc,\n      });\n    });\n    window.Shiny.setInputValue!(`${id}_sort`, shinySort);\n\n    // Deprecated as of 2024-05-21\n    window.Shiny.setInputValue!(`${id}_column_sort`, shinySort);\n  }, [columns, id, sorting]);\n  useEffect(() => {\n    if (!id) return;\n    const shinyFilter: {\n      col: number;\n      value: FilterValue;\n    }[] = [];\n    columnFilters.map((filterObj) => {\n      const columnNum = columns.indexOf(filterObj.id);\n      shinyFilter.push({\n        col: columnNum,\n        value: filterObj.value as FilterValue,\n      });\n    });\n    window.Shiny.setInputValue!(`${id}_filter`, shinyFilter);\n\n    // Deprecated as of 2024-05-21\n    window.Shiny.setInputValue!(`${id}_column_filter`, shinyFilter);\n  }, [id, columnFilters, columns]);\n  useEffect(() => {\n    if (!id) return;\n\n    const shinyRows: number[] = table\n      // Already prefiltered rows!\n      .getSortedRowModel()\n      .rows.map((row) => row.index);\n    window.Shiny.setInputValue!(`${id}_data_view_rows`, shinyRows);\n\n    // Legacy value as of 2024-05-13\n    window.Shiny.setInputValue!(`${id}_data_view_indices`, shinyRows);\n  }, [\n    id,\n    table,\n    // Update with either sorting or columnFilters update!\n    sorting,\n    columnFilters,\n  ]);\n\n  // Restored for legacy purposes. Only send selected rows to Shiny when row selection is performed.\n  useEffect(() => {\n    if (!id) return;\n    let shinyValue: number[] | null = null;\n    if (selectionModes.row !== SelectionModes._rowEnum.NONE) {\n      const rowSelectionKeys = selection.keys().toList();\n      const rowsById = table.getSortedRowModel().rowsById;\n      shinyValue = rowSelectionKeys\n        .map((key) => {\n          if (!(key in rowsById)) {\n            return null;\n          }\n          return rowsById[key]!.index;\n        })\n        .filter((x): x is number => x !== null)\n        .sort();\n    }\n    window.Shiny.setInputValue!(`${id}_selected_rows`, shinyValue);\n  }, [id, selection, selectionModes, table]);\n\n  // ### End row selection ############################################################\n\n  // ### Editable cells ###############################################################\n  // type TKey = DOMStringMap[string]: string\n  type TKey = typeof HTMLTableRowElement.prototype.dataset.key;\n  type TElement = HTMLTableRowElement;\n\n  // ### End editable cells ###########################################################\n\n  //\n\n  //\n\n  //\n  const tbodyTabItems = React.useCallback(\n    () => tbodyRef.current!.querySelectorAll(\"[tabindex='-1']\"),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [tbodyRef.current]\n  );\n  const tbodyTabGroup = useTabindexGroup(containerRef.current, tbodyTabItems, {\n    top: theadRef.current?.clientHeight ?? 0,\n  });\n\n  // Reset sorting and selection whenever dataset changes. (Should we do this?)\n  // NOTE-2024-02-21-barret; Maybe only reset sorting if the column information changes?\n  useEffect(() => {\n    return () => {\n      table.resetSorting();\n      selection.clear();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [payload]);\n\n  const headerRowCount = table.getHeaderGroups().length;\n\n  // Maintain the .scrolling class: present if the amount of data in the table causes\n  // vertical overflow, absent if not.\n  useLayoutEffect(() => {\n    // If no data, we're definitely not scrolling. Otherwise, we need to test.\n    let scrolling = tableData.length > 0;\n    if (scrolling) {\n      // We need to add .scrolling before comparing scrollHeight/clientHeight. If not,\n      // then if there's already a scrollworthy amount of data, we might get stuck in\n      // non-scrolling state because the clientHeight is expanding within a fixed\n      // container. (See https://github.com/posit-dev/py-shiny/issues/1549)\n      containerRef.current?.classList.add(\"scrolling\");\n      const scrollHeight = containerRef.current?.scrollHeight;\n      const clientHeight = containerRef.current?.clientHeight;\n      if (scrollHeight && clientHeight && scrollHeight <= clientHeight) {\n        scrolling = false;\n      }\n    }\n    containerRef.current?.classList.toggle(\"scrolling\", scrolling);\n  }, [\n    tableData.length,\n    containerRef.current?.scrollHeight,\n    containerRef.current?.clientHeight,\n  ]);\n\n  const makeHeaderKeyDown =\n    (column: Column<unknown[], unknown>) => (event: React.KeyboardEvent) => {\n      if (event.key === \" \" || event.key === \"Enter\") {\n        column.toggleSorting(undefined, event.shiftKey);\n      }\n    };\n\n  const measureEl = useVirtualizerMeasureWorkaround(rowVirtualizer);\n\n  let className = `shiny-data-grid ${containerClass}`;\n  if (fill) {\n    className += \" html-fill-item\";\n  }\n\n  const includeRowNumbers =\n    false && selectionModes.row !== SelectionModes._rowEnum.NONE;\n\n  return (\n    <>\n      <div\n        className={className}\n        ref={containerRef}\n        style={{ width, height, overflow: \"auto\" }}\n      >\n        <table\n          className={tableClass + (withFilters ? \" filtering\" : \"\")}\n          aria-rowcount={table.getRowCount()}\n          aria-multiselectable={canMultiRowSelect}\n          style={{\n            width: width === null || width === \"auto\" ? undefined : \"100%\",\n          }}\n        >\n          <thead ref={theadRef} style={{ backgroundColor: bgcolor }}>\n            {table.getHeaderGroups().map((headerGroup, i) => (\n              <tr\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore:next-line\n                key={headerGroup.id}\n                aria-rowindex={i + 1}\n              >\n                {includeRowNumbers && <th className=\"table-corner\"></th>}\n\n                {headerGroup.headers.map((header) => {\n                  const headerContent = header.isPlaceholder ? undefined : (\n                    <div\n                      style={{\n                        cursor: header.column.getCanSort()\n                          ? \"pointer\"\n                          : undefined,\n                        userSelect: header.column.getCanSort()\n                          ? \"none\"\n                          : undefined,\n                      }}\n                    >\n                      {flexRender(\n                        header.column.columnDef.header,\n                        header.getContext()\n                      )}\n                      <SortArrow direction={header.column.getIsSorted()} />\n                    </div>\n                  );\n\n                  return (\n                    <th\n                      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                      // @ts-ignore:next-line\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      style={{\n                        width: header.getSize(),\n                        // When row numbers are displayed, this value is helpful instead of `width`\n                        // minWidth: header.getSize()\n                      }}\n                      scope=\"col\"\n                      tabIndex={0}\n                      onClick={header.column.getToggleSortingHandler()}\n                      onKeyDown={makeHeaderKeyDown(header.column)}\n                      className={\n                        header.column.getCanSort() ? undefined : \"header-html\"\n                      }\n                    >\n                      {headerContent}\n                    </th>\n                  );\n                })}\n              </tr>\n            ))}\n            {withFilters && (\n              <tr className=\"filters\">\n                {includeRowNumbers && <th className=\"table-corner\"></th>}\n                {table.getFlatHeaders().map((header) => {\n                  const thKey = `filter-${header.id}`;\n                  return (\n                    <th\n                      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                      // @ts-ignore:next-line\n                      key={thKey}\n                    >\n                      <Filter header={header} />\n                    </th>\n                  );\n                })}\n              </tr>\n            )}\n          </thead>\n          <tbody\n            ref={tbodyRef}\n            tabIndex={tbodyTabGroup.containerTabIndex}\n            {...tbodyTabGroup.containerHandlers}\n          >\n            {paddingTop > 0 && <tr style={{ height: `${paddingTop}px` }}></tr>}\n            {virtualRows.map((virtualRow) => {\n              const row = table.getRowModel().rows[virtualRow.index];\n              return (\n                row && (\n                  <tr\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore:next-line\n                    key={virtualRow.key}\n                    data-index={virtualRow.index}\n                    aria-rowindex={virtualRow.index + headerRowCount}\n                    data-key={row.id}\n                    ref={measureEl}\n                    aria-selected={selection.has(row.id)}\n                    tabIndex={-1}\n                    {...selection.itemHandlers()}\n                  >\n                    {includeRowNumbers && (\n                      <td className=\"row-number\">{row.index + 1}</td>\n                    )}\n                    {row.getVisibleCells().map((cell) => {\n                      // TODO-barret; Only send in the cell data that is needed;\n                      const rowIndex = cell.row.index;\n                      const columnIndex = cell.column.columnDef.meta!.colIndex;\n                      const [cellEditInfo, _key] = getCellEditMapObj(\n                        cellEditMap,\n                        rowIndex,\n                        columnIndex\n                      );\n                      const { cellStyle, cellClassName } = getCellStyle(\n                        styleInfoMap,\n                        \"body\",\n                        rowIndex,\n                        columnIndex\n                      );\n\n                      return (\n                        <TableBodyCell\n                          key={cell.id}\n                          rowId={cell.row.id}\n                          containerRef={containerRef}\n                          cell={cell}\n                          patchInfo={patchInfo}\n                          editCellsIsAllowed={editCellsIsAllowed}\n                          columns={columns}\n                          coldefs={coldefs}\n                          rowIndex={rowIndex}\n                          columnIndex={columnIndex}\n                          getSortedRowModel={table.getSortedRowModel}\n                          cellEditInfo={cellEditInfo}\n                          cellStyle={cellStyle}\n                          cellClassName={cellClassName}\n                          setData={setTableData}\n                          setCellEditMapAtLoc={setCellEditMapAtLoc}\n                          selection={selection}\n                        ></TableBodyCell>\n                      );\n                    })}\n                  </tr>\n                )\n              );\n            })}\n            {paddingBottom > 0 && (\n              <tr style={{ height: `${paddingBottom}px` }}></tr>\n            )}\n          </tbody>\n        </table>\n      </div>\n      {summary}\n    </>\n  );\n};\n\nfunction findKeysBetween<TData>(\n  rowModel: RowModel<TData>,\n  fromKey: string,\n  toKey: string\n): readonly string[] {\n  let fromIdx = rowModel.rows.findIndex((row) => row.id === fromKey);\n  let toIdx = rowModel.rows.findIndex((row) => row.id === toKey);\n  if (fromIdx < 0 || toIdx < 0) {\n    return [];\n  }\n  if (fromIdx > toIdx) {\n    // Swap order to simplify things\n    [fromIdx, toIdx] = [toIdx, fromIdx];\n  }\n  const keys = [];\n  for (let i = fromIdx; i <= toIdx; i++) {\n    keys.push(rowModel.rows[i]!.id);\n  }\n  return keys;\n}\n\n/**\n * Works around a problem where the ref={...} callback is called before the element to\n * be measured is attached to the DOM, which will result in the virtualizer using its\n * estimated size instead of the actual size. This hook will detect when elements that\n * are not yet attached to the DOM are measured, and will retry measuring them in the\n * useEffect.\n * @returns A callback that can be used as a ref for an element that needs to be measured.\n */\nfunction useVirtualizerMeasureWorkaround(\n  rowVirtualizer: Virtualizer<HTMLDivElement, Element>\n) {\n  // Tracks elements that need to be measured, but are not yet attached to the DOM\n  const measureTodoQueue = useRef<HTMLElement[]>([]);\n\n  // This is the callback that will be passed back to the caller, intended to be used as\n  // a ref for each virtual item's element.\n  const measureElementWithRetry = useCallback(\n    (el: Element | null) => {\n      if (!el) {\n        return;\n      }\n\n      if (el.isConnected) {\n        rowVirtualizer.measureElement(el);\n      } else {\n        measureTodoQueue.current.push(el as HTMLElement);\n      }\n    },\n    [rowVirtualizer]\n  );\n\n  // Once the DOM is updated, try to measure any elements that were not yet attached\n  useLayoutEffect(() => {\n    if (measureTodoQueue.current.length > 0) {\n      const todo = measureTodoQueue.current.splice(0);\n      // The next line can mutate measureTodoQueue.current, hence the need to splice out\n      // all the items to work on before actually calling measureElement on any of them.\n      todo.forEach(rowVirtualizer.measureElement);\n    }\n  });\n\n  return measureElementWithRetry;\n}\n\nclass ShinyDataFrameOutputBinding extends window.Shiny.OutputBinding {\n  find(scope: HTMLElement | JQuery<HTMLElement>): JQuery<HTMLElement> {\n    return $(scope).find(\"shiny-data-frame\");\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  renderValue(el: ShinyDataFrameOutput, data: any): void {\n    el.renderValue(data);\n  }\n\n  renderError(el: ShinyDataFrameOutput, err: ErrorsMessageValue): void {\n    el.classList.add(\"shiny-output-error\");\n    el.renderError(err);\n  }\n\n  clearError(el: ShinyDataFrameOutput): void {\n    el.classList.remove(\"shiny-output-error\");\n    el.clearError();\n  }\n}\nwindow.Shiny.outputBindings.register(\n  new ShinyDataFrameOutputBinding(),\n  \"shinyDataFrame\"\n);\n\nfunction getComputedBgColor(el: HTMLElement | null): string | undefined {\n  if (!el) {\n    // Top of document, can't recurse further\n    return undefined;\n  }\n\n  const bgColor = getStyle(el, \"background-color\");\n\n  if (!bgColor) return bgColor;\n  const m = bgColor.match(\n    /^rgba\\(\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*\\)$/\n  );\n\n  if (bgColor === \"transparent\" || (m && parseFloat(m[4]!) === 0)) {\n    // No background color on this element. See if it has a background image.\n    const bgImage = getStyle(el, \"background-image\");\n\n    if (bgImage && bgImage !== \"none\") {\n      // Failed to detect background color, since it has a background image\n      return undefined;\n    } else {\n      // Recurse\n      return getComputedBgColor(el.parentElement);\n    }\n  }\n  return bgColor;\n}\n\nconst cssTemplate = document.createElement(\"template\");\ncssTemplate.innerHTML = `<style>${css}</style>`;\n\nexport class ShinyDataFrameOutput extends HTMLElement {\n  reactRoot?: Root;\n  errorRoot!: HTMLSpanElement;\n\n  connectedCallback() {\n    // Currently not using shadow DOM since Bootstrap's table styling is pretty nice and\n    // I don't have time to duplicate all that right now.\n    // this.attachShadow({ mode: \"open\" });\n    // const target = this.shadowRoot!;\n\n    const [target] = [this]; // brackets are to avoid linter\n\n    target.appendChild(cssTemplate.content.cloneNode(true));\n\n    // Need to put error messages in an inline element (<span>) instead of in the\n    // reactRoot div, because we want the error messages to appear on the same line as\n    // \"Error:\".\n    this.errorRoot = document.createElement(\"span\");\n    target.appendChild(this.errorRoot);\n\n    const myDiv = document.createElement(\"div\");\n    myDiv.classList.add(\"html-fill-container\", \"html-fill-item\");\n    target.appendChild(myDiv);\n\n    this.reactRoot = createRoot(myDiv);\n\n    // If there is a <script class=\"data\"> element it contains static data.\n    // Render it now.\n    const dataEl = this.querySelector(\n      \"script.data\"\n    ) as HTMLScriptElement | null;\n    if (dataEl) {\n      const data = JSON.parse(dataEl.innerText);\n      this.renderValue(data);\n    }\n  }\n\n  renderValue(value: ShinyDataGridServerInfo<unknown> | null) {\n    this.clearError();\n\n    if (!value) {\n      this.reactRoot!.render(null);\n      return;\n    }\n\n    this.reactRoot!.render(\n      <StrictMode>\n        <ShinyDataGrid\n          id={this.id}\n          gridInfo={value}\n          bgcolor={getComputedBgColor(this)}\n        ></ShinyDataGrid>\n      </StrictMode>\n    );\n  }\n\n  renderError(err: ErrorsMessageValue) {\n    this.reactRoot!.render(null);\n    this.errorRoot.innerText = err.message;\n  }\n\n  clearError() {\n    this.reactRoot!.render(null);\n    this.errorRoot.innerText = \"\";\n  }\n}\n\ncustomElements.define(\"shiny-data-frame\", ShinyDataFrameOutput);\n\n// This is the shim between Shiny's messaging passing behaviour and React.\n// The python code sends a custom message which includes an id, handler\n// and obbject and we use that information to dispatch it to the\n// react listener.\n// It would be better to have something similar to session.send_input_message\n// for updating outputs, but that requires changes to ShinyJS.\nwindow.Shiny.addCustomMessageHandler(\n  \"shinyDataFrameMessage\",\n  function (message) {\n    const evt = new CustomEvent(message.handler, {\n      detail: message.obj,\n    });\n    const el = document.getElementById(message.id);\n    el?.dispatchEvent(evt);\n  }\n);\n"],
  "mappings": "AACaA,IC2BAC,GCjBPC,ECRFC,GAgGSC,GC+ETC,GAWAC,GAEEC,GA0BAC,GC/LFC,GAmJEC,GACAC,GC5KKC,GNUEC,GAAgC,CAAA,EAChCC,GAAY,CAAA,EACZC,GACZ,oECbYC,GAAUC,MAAMD,QAStB,SAASE,GAAOC,EAAKC,EAAAA,CAE3B,QAASR,KAAKQ,EAAOD,EAAIP,CAAAA,EAAKQ,EAAMR,CAAAA,EACpC,OAA6BO,CAC7B,CAAA,SAQeE,GAAWC,EAAAA,CAC1B,IAAIC,EAAaD,EAAKC,WAClBA,GAAYA,EAAWC,YAAYF,CAAAA,CACvC,CEZM,SAASG,GAAcC,EAAMN,EAAOO,EAAAA,CAC1C,IACCC,EACAC,EACAjB,EAHGkB,EAAkB,CAAA,EAItB,IAAKlB,KAAKQ,EACLR,GAAK,MAAOgB,EAAMR,EAAMR,CAAAA,EACnBA,GAAK,MAAOiB,EAAMT,EAAMR,CAAAA,EAC5BkB,EAAgBlB,CAAAA,EAAKQ,EAAMR,CAAAA,EAUjC,GAPImB,UAAUC,OAAS,IACtBF,EAAgBH,SACfI,UAAUC,OAAS,EAAI/B,GAAMgC,KAAKF,UAAW,CAAA,EAAKJ,GAKjC,OAARD,GAAQ,YAAcA,EAAKQ,cAAgB,KACrD,IAAKtB,KAAKc,EAAKQ,aACVJ,EAAgBlB,CAAAA,IADNsB,SAEbJ,EAAgBlB,CAAAA,EAAKc,EAAKQ,aAAatB,CAAAA,GAK1C,OAAOuB,GAAYT,EAAMI,EAAiBF,EAAKC,EAAK,IAAA,CACpD,CAceM,SAAAA,GAAYT,EAAMN,EAAOQ,EAAKC,EAAKO,EAAAA,CAIlD,IAAMC,EAAQ,CACbX,KAAAA,EACAN,MAAAA,EACAQ,IAAAA,EACAC,IAAAA,EACAS,IAAW,KACXC,GAAS,KACTC,IAAQ,EACRC,IAAM,KAKNC,IAAAA,OACAC,IAAY,KACZC,YAAAA,OACAC,IAAWT,GAAAA,EAAqBjC,GAChC2C,IAAAA,GACAC,IAAQ,CAAA,EAMT,OAFIX,GAAY,MAAQlC,EAAQmC,OAAS,MAAMnC,EAAQmC,MAAMA,CAAAA,EAEtDA,CACP,CAAA,SAEeW,IAAAA,CACf,MAAO,CAAEC,QAAS,IAAA,CAClB,CAEeC,SAAAA,GAAS9B,EAAAA,CACxB,OAAOA,EAAMO,QACb,CC/EewB,SAAAA,GAAc/B,EAAOgC,EAAAA,CACpCC,KAAKjC,MAAQA,EACbiC,KAAKD,QAAUA,CACf,CA0EM,SAASE,GAAcjB,EAAOkB,EAAAA,CACpC,GAAIA,GAAc,KAEjB,OAAOlB,EAAAE,GACJe,GAAcjB,EAAeA,GAAAA,EAAAA,IAAe,CAAA,EAC5C,KAIJ,QADImB,EACGD,EAAalB,EAAAC,IAAgBN,OAAQuB,IAG3C,IAFAC,EAAUnB,EAAAC,IAAgBiB,CAAAA,IAEX,MAAQC,EAAAf,KAAgB,KAItC,OAAOe,EACPf,IAQF,OAA4B,OAAdJ,EAAMX,MAAQ,WAAa4B,GAAcjB,CAAAA,EAAS,IAChE,CA2CD,SAASoB,GAAwBpB,EAAAA,CAAjC,IAGWzB,EACJ8C,EAHN,IAAKrB,EAAQA,EAAHE,KAAqB,MAAQF,EAAKM,KAAe,KAAM,CAEhE,IADAN,EAAKI,IAAQJ,EAAKM,IAAYgB,KAAO,KAC5B/C,EAAI,EAAGA,EAAIyB,EAAKC,IAAWN,OAAQpB,IAE3C,IADI8C,EAAQrB,EAAAC,IAAgB1B,CAAAA,IACf,MAAQ8C,EAAAjB,KAAc,KAAM,CACxCJ,EAAKI,IAAQJ,EAAKM,IAAYgB,KAAOD,EAArCjB,IACA,KACA,CAGF,OAAOgB,GAAwBpB,CAAAA,CAC/B,CACD,CAAA,SA4BeuB,GAAcC,EAAAA,EAAAA,CAE1BA,EAADnB,MACCmB,EAAAnB,IAAAA,KACDrC,GAAcyD,KAAKD,CAAAA,GAAAA,CAClBE,GAAAA,OACFzD,KAAiBJ,EAAQ8D,sBAEzB1D,GAAeJ,EAAQ8D,oBACNzD,IAAOwD,EAAAA,CAEzB,CASD,SAASA,IAAAA,CAAT,IACKF,EAMEI,EAzGkBC,EAOjBC,EANHC,EACHC,EACAC,EACAC,EAmGD,IAHAlE,GAAcmE,KAAKhE,EAAAA,EAGXqD,EAAIxD,GAAcoE,MAAAA,GACrBZ,EAAAA,MACCI,EAAoB5D,GAAc2B,OAlGjCmC,EAAAA,OALNE,GADGD,GADoBF,EA0GNL,GAAAA,KAxGXpB,IACN6B,EAAc,CAAA,EACdC,EAAW,CAAA,EAERL,EAAAA,OACGC,EAAWjD,GAAO,CAAA,EAAIkD,CAAAA,GAC5BvB,IAAqBuB,EAAAvB,IAAqB,EACtC3C,EAAQmC,OAAOnC,EAAQmC,MAAM8B,CAAAA,EAEjCO,GACCR,EADGS,IAEHR,EACAC,EACAF,EACAA,IAAAA,EAAAA,IAAqBU,aJzII,GI0IzBR,EAAAA,IAAiC,CAACC,CAAAA,EAAU,KAC5CC,EACAD,GAAiBf,GAAcc,CAAAA,EAAYC,CAAAA,EJ5IlB,GI6ItBD,EAAArB,KACHwB,CAAAA,EAGDJ,EAAQtB,IAAauB,EAArBvB,IACAsB,EAAA5B,GAAAD,IAA2B6B,EAA3BrB,GAAAA,EAA8CqB,EAC9CU,GAAWP,EAAaH,EAAUI,CAAAA,EAE9BJ,EAAQ1B,KAAS4B,GACpBZ,GAAwBU,CAAAA,GA8EpB9D,GAAc2B,OAASiC,GAI1B5D,GAAcmE,KAAKhE,EAAAA,GAItBuD,GAAAA,IAAyB,CACzB,CAAA,SGlNee,GACfC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAf,EACAD,EACAiB,EACAf,EAAAA,CAAAA,IAEI3D,EAEHwD,EAEAmB,EAEAC,EAEAC,EAKGC,EAAeR,GAAkBA,EAAnB5C,KAAgDxB,GAE9D6E,EAAoBX,EAAahD,OAMrC,IAJAiD,EAAAvC,IAA0B2B,EAC1BuB,GAA0BX,EAAgBD,EAAcU,CAAAA,EACxDrB,EAASY,EAAAA,IAEJrE,EAAI,EAAGA,EAAI+E,EAAmB/E,KAClC2E,EAAaN,EAAc3C,IAAW1B,CAAAA,IAEvB,MACO,OAAd2E,GAAc,WACA,OAAdA,GAAc,aAQrBnB,EADGmB,EAAUzC,MACbsB,GAAWvD,GAEA6E,EAAYH,EAAZzC,GAAAA,GAAkCjC,GAI9C0E,EAAAzC,IAAoBlC,EAGpB8D,GACCK,EACAQ,EACAnB,EACAe,EACAC,EACAC,EACAf,EACAD,EACAiB,EACAf,CAAAA,EAIDiB,EAASD,EAAT9C,IACI8C,EAAW1D,KAAOuC,EAASvC,KAAO0D,EAAW1D,MAC5CuC,EAASvC,KACZgE,GAASzB,EAASvC,IAAK,KAAM0D,CAAAA,EAE9BhB,EAAST,KACRyB,EAAW1D,IACX0D,EAAAA,KAAyBC,EACzBD,CAAAA,GAIEE,GAAiB,MAAQD,GAAU,OACtCC,EAAgBD,GP1GS,MO8GzBD,EAAUxC,KACVqB,EAAQ9B,MAAeiD,EAAvBjD,KAGC+B,GAC0B,OAAnBkB,EAAW7D,MAAQ,UAARA,CAEjBqD,EAAUe,SAASzB,CAAAA,IAEpBA,EAASf,GAAcc,CAAAA,GAExBC,EAAS0B,GAAOR,EAAYlB,EAAQU,CAAAA,GAEV,OAAnBQ,EAAW7D,MAAQ,YAC1B6D,EAAAA,MADkB7D,OAMlB2C,EAASkB,EAAAA,IACCC,IACVnB,EAASmB,EAAOQ,aAQjBT,EAAA7C,IAAAA,OAGA6C,EAAAxC,KAAAA,SAaDkC,EAAcvC,IAAY2B,EAC1BY,EAAcxC,IAAQgD,CACtB,CAOD,SAASG,GAA0BX,EAAgBD,EAAcU,EAAAA,CAAjE,IAEK9E,EAEA2E,EAEAnB,EA8DG6B,EAmCAC,EA/FDP,EAAoBX,EAAahD,OACnCmE,EAAoBT,EAAY1D,OACnCoE,EAAuBD,EAEpBE,EAAO,EAGX,IADApB,EAAc3C,IAAa,CAAA,EACtB1B,EAAI,EAAGA,EAAI+E,EAAmB/E,IAqD5BqF,EAAcrF,EAAIyF,GA3CvBd,EAAaN,EAAc3C,IAAW1B,CAAAA,GAPvC2E,EAAaP,EAAapE,CAAAA,IAGX,MACO,OAAd2E,GAAc,WACA,OAAdA,GAAc,WAEsB,KAMtB,OAAdA,GAAc,UACA,OAAdA,GAAc,UAEA,OAAdA,GAAc,UACrBA,EAAW3C,aAAe0D,OAEiBnE,GAC1C,KACAoD,EACA,KACA,KACA,IAAA,EAESvE,GAAQuE,CAAAA,EACyBpD,GAC1Ce,GACA,CAAEvB,SAAU4D,CAAAA,EACZ,KACA,KACA,IAAA,EAESA,EAAW3C,cAFpB,QAEiD2C,EAAU/C,IAAU,EAK3BL,GAC1CoD,EAAW7D,KACX6D,EAAWnE,MACXmE,EAAW3D,IACX2D,EAAW1D,IAAM0D,EAAW1D,IAAM,KAClC0D,EAED1C,GAAAA,EAC2C0C,IAM1B,MA6BlBA,EAAUhD,GAAW0C,EACrBM,EAAA/C,IAAoByC,EAAczC,IAAU,EAEtC0D,EAAgBK,GACrBhB,EACAG,EACAO,EACAG,CAAAA,EAMDb,EAAAzC,IAAoBoD,EAEpB9B,EAAW,KACP8B,IADO,KAGVE,KADAhC,EAAWsB,EAAYQ,CAAAA,KAGtB9B,EAAAA,KP1RmB,SOiSFA,GAAY,MAAQA,EAAAvB,MAAuB,MAGzDqD,GAHkCrD,IAIrCwD,IAI6B,OAAnBd,EAAW7D,MAAQ,aAC7B6D,EAAAA,KP5SwB,QO8SfW,IAAkBD,IACxBC,GAAiBD,EAAc,EAClCI,EAAOH,EAAgBD,EACbC,GAAiBD,EAAc,EACzCI,IACUH,EAAgBD,EAOtBG,EAAuBT,EAAoBM,EAC9CI,GAAQH,EAAgBD,EAGxBI,IAESH,EAAgBD,GAE1BI,IAKGH,IAAkBtF,EAAIyF,IACzBd,EAAUxC,KPxUc,UO4OzBqB,EAAWsB,EAAYO,CAAAA,IAGtB7B,EAASxC,KAAO,MAChBwC,EAFA3B,KP5OmB,SO+OlB2B,EAAAA,OAEGA,EAAA3B,KAAiBwC,EAArBvC,MACCuC,EAAcvC,IAAYY,GAAcc,CAAAA,GAGzCoC,GAAQpC,EAAUA,EAAAA,EAAU,EAW5BsB,EAAYO,CAAAA,EAAe,KAC3BG,KA8EH,GAAIA,EACH,IAAKxF,EAAI,EAAGA,EAAIuF,EAAmBvF,KAClCwD,EAAWsB,EAAY9E,CAAAA,IACP,MPlVI,SOkVKwD,EAAQrB,OAC5BqB,EAAQ3B,KAASwC,EAAAA,MACpBA,EAAAvC,IAA0BY,GAAcc,CAAAA,GAGzCoC,GAAQpC,EAAUA,CAAAA,EAIrB,CAQD,SAAS2B,GAAOU,EAAapC,EAAQU,EAAAA,CAArC,IAIMpD,EACKf,EAFV,GAA+B,OAApB6F,EAAY/E,MAAQ,WAAY,CAE1C,IADIC,EAAW8E,EAAfnE,IACS1B,EAAI,EAAGe,GAAYf,EAAIe,EAASK,OAAQpB,IAC5Ce,EAASf,CAAAA,IAKZe,EAASf,CAAAA,EAAa6F,GAAAA,EACtBpC,EAAS0B,GAAOpE,EAASf,CAAAA,EAAIyD,EAAQU,CAAAA,GAIvC,OAAOV,CACP,CAAUoC,EAAWhE,KAAS4B,IAC9BU,EAAU2B,aAAaD,EAAkBpC,IAAAA,GAAU,IAAA,EACnDA,EAASoC,EAAHhE,KAGP,GACC4B,EAASA,GAAUA,EAAO2B,kBAClB3B,GAAU,MAAQA,EAAOsC,WAAa,GAE/C,OAAOtC,CACP,CAQeuC,SAAAA,GAAajF,EAAUkF,EAAAA,CAUtC,OATAA,EAAMA,GAAO,CAAA,EACTlF,GAAY,MAA2B,OAAZA,GAAY,YAChCX,GAAQW,CAAAA,EAClBA,EAASmF,KAAK,SAAApD,EAAAA,CACbkD,GAAalD,EAAOmD,CAAAA,CACpB,CAAA,EAEDA,EAAI/C,KAAKnC,CAAAA,GAEHkF,CACP,CASD,SAASN,GACRhB,EACAG,EACAO,EACAG,EAAAA,CAJD,IAMOxE,EAAM2D,EAAW3D,IACjBF,EAAO6D,EAAW7D,KACpBqF,EAAId,EAAc,EAClBe,EAAIf,EAAc,EAClB7B,EAAWsB,EAAYO,CAAAA,EAc3B,GACC7B,IAAa,MACZA,GACAxC,GAAOwC,EAASxC,KAChBF,IAAS0C,EAAS1C,MPtbE,SOubnB0C,EAAArB,KAEF,OAAOkD,EACD,GAXNG,GACChC,GAAY,MPhbQ,SOgbCA,EAAArB,KAAmC,EAAI,GAW7D,KAAOgE,GAAK,GAAKC,EAAItB,EAAY1D,QAAQ,CACxC,GAAI+E,GAAK,EAAG,CAEX,IADA3C,EAAWsB,EAAYqB,CAAAA,IP7bJ,SOgcjB3C,EAAArB,MACDnB,GAAOwC,EAASxC,KAChBF,IAAS0C,EAAS1C,KAElB,OAAOqF,EAERA,GACA,CAED,GAAIC,EAAItB,EAAY1D,OAAQ,CAE3B,IADAoC,EAAWsB,EAAYsB,CAAAA,IP1cJ,SO6cjB5C,EAAQrB,MACTnB,GAAOwC,EAASxC,KAChBF,IAAS0C,EAAS1C,KAElB,OAAOsF,EAERA,GACA,CACD,CAGF,MAAA,EACA,CF7dD,SAASC,GAASC,EAAOtF,EAAKuF,EAAAA,CACzBvF,EAAI,CAAA,IAAO,IACdsF,EAAME,YAAYxF,EAAKuF,GAAgB,EAAKA,EAE5CD,EAAMtF,CAAAA,EADIuF,GAAS,KACN,GACa,OAATA,GAAS,UAAYpG,GAAmBsG,KAAKzF,CAAAA,EACjDuF,EAEAA,EAAQ,IAEtB,CAAA,SAuBeC,GAAYE,EAAKC,EAAMJ,EAAOK,EAAUpC,EAAAA,CACvD,IAAIqC,EAEJC,EAAG,GAAIH,IAAS,QACf,GAAoB,OAATJ,GAAS,SACnBG,EAAIJ,MAAMS,QAAUR,MACd,CAKN,GAJuB,OAAZK,GAAY,WACtBF,EAAIJ,MAAMS,QAAUH,EAAW,IAG5BA,EACH,IAAKD,KAAQC,EACNL,GAASI,KAAQJ,GACtBF,GAASK,EAAIJ,MAAOK,EAAM,EAAA,EAK7B,GAAIJ,EACH,IAAKI,KAAQJ,EACPK,GAAYL,EAAMI,CAAAA,IAAUC,EAASD,CAAAA,GACzCN,GAASK,EAAIJ,MAAOK,EAAMJ,EAAMI,CAAAA,CAAAA,CAInC,SAGOA,EAAK,CAAA,IAAO,KAAOA,EAAK,CAAA,IAAO,IACvCE,EACCF,KAAUA,EAAOA,EAAKK,QAAQ,8BAA+B,IAAA,GAQ7DL,EAJAA,EAAKM,YAAAA,IAAiBP,GACtBC,IAAS,cACTA,IAAS,YAEFA,EAAKM,YAAAA,EAAc5H,MAAM,CAAA,EACrBsH,EAAKtH,MAAM,CAAA,EAElBqH,EAALQ,IAAqBR,EAAAQ,EAAiB,CAAA,GACtCR,EAAAQ,EAAeP,EAAOE,CAAAA,EAAcN,EAEhCA,EACEK,EAQJL,EAAMY,EAAYP,EAASO,GAP3BZ,EAAMY,EAAYtH,GAClB6G,EAAIU,iBACHT,EACAE,EAAa9G,GAAoBD,GACjC+G,CAAAA,GAMFH,EAAIW,oBACHV,EACAE,EAAa9G,GAAoBD,GACjC+G,CAAAA,MAGI,CACN,GAAIrC,GAAa,6BAIhBmC,EAAOA,EAAKK,QAAQ,cAAe,GAAA,EAAKA,QAAQ,SAAU,GAAA,UAE1DL,GAAQ,SACRA,GAAQ,UACRA,GAAQ,QACRA,GAAQ,QACRA,GAAQ,QAGRA,GAAQ,YACRA,GAAQ,YACRA,GAAQ,WACRA,GAAQ,WACRA,GAAQ,QACRA,GAAQ,WACRA,KAAQD,EAER,GAAA,CACCA,EAAIC,CAAAA,EAAQJ,GAAgB,GAE5B,MAAMO,CACK,MAAHQ,CAAG,CAUO,OAATf,GAAS,aAETA,GAAS,MAASA,IAAlBA,IAAqCI,EAAK,CAAA,IAAO,IAG3DD,EAAIa,gBAAgBZ,CAAAA,EAFpBD,EAAIc,aAAab,EAAMA,GAAQ,WAAaJ,GAAS,EAAO,GAAKA,CAAAA,EAIlE,CACD,CAOD,SAASkB,GAAiBZ,EAAAA,CAMzB,OAAiBS,SAAAA,EAAAA,CAChB,GAAI7E,KAAJyE,EAAqB,CACpB,IAAMQ,EAAejF,KAAAA,EAAgB6E,EAAExG,KAAO+F,CAAAA,EAC9C,GAAIS,EAAEK,GAAe,KACpBL,EAAEK,EAAc9H,aAKNyH,EAAEK,EAAcD,EAAaP,EACvC,OAED,OAAOO,EAAapI,EAAQsI,MAAQtI,EAAQsI,MAAMN,CAAAA,EAAKA,CAAAA,CACvD,CACD,CACD,CG5IexD,SAAAA,GACfK,EACAZ,EACAC,EACAe,EACAC,EACAC,EACAf,EACAD,EACAiB,EACAf,EAAAA,CAVeG,IAaX+D,EAkBE5E,EAAG6E,EAAOC,EAAUC,EAAUC,EAAUC,EACxCC,EACEC,EAMFC,EACAC,EAyGOtI,EA4BPuI,EACHC,EASSxI,EA6BNoE,EAtMLqE,EAAUlF,EAASzC,KAIpB,GAAIyC,EAASvB,cAAb,OAAwC,OAAO,KR9ClB,IQiDzBwB,EAAQrB,MACXuC,EAAAA,CAAAA,ERpD0B,GQoDTlB,EAAArB,KAEjBsC,EAAoB,CADpBhB,EAASF,EAAA1B,IAAgB2B,EAAzB3B,GAAAA,IAIIgG,EAAMvI,EAAHsC,MAAmBiG,EAAItE,CAAAA,EAE/BmF,EAAO,GAAsB,OAAXD,GAAW,WAC5B,GAAA,CAkEC,GAhEIN,EAAW5E,EAAS/C,MAClB4H,EACL,cAAeK,GAAWA,EAAQE,UAAUC,OAKzCP,GADJR,EAAMY,EAAQI,cACQtE,EAAcsD,EAAD9F,GAAAA,EAC/BuG,EAAmBT,EACpBQ,EACCA,EAAS7H,MAAM+F,MACfsB,EAFOlG,GAGR4C,EAGCf,EAAqBzB,IAExBmG,GADAjF,EAAIM,EAAQxB,IAAcyB,EAAAA,KACC7B,GAAyBsB,EAAzB6F,KAGvBV,EAEH7E,EAAQxB,IAAckB,EAAI,IAAIwF,EAAQN,EAAUG,CAAAA,GAGhD/E,EAAAxB,IAAsBkB,EAAI,IAAIV,GAC7B4F,EACAG,CAAAA,EAEDrF,EAAEjB,YAAcyG,EAChBxF,EAAE2F,OAASG,IAERV,GAAUA,EAASW,IAAI/F,CAAAA,EAE3BA,EAAEzC,MAAQ2H,EACLlF,EAAEgG,QAAOhG,EAAEgG,MAAQ,CAAA,GACxBhG,EAAET,QAAU8F,EACZrF,EAAAiG,IAAmB3E,EACnBuD,EAAQ7E,EAAAnB,IAAAA,GACRmB,EAACkG,IAAoB,CAAA,EACrBlG,EAACmG,IAAmB,CAAA,GAIjBhB,GAAoBnF,EAAAoG,KAAgB,OACvCpG,EAAAoG,IAAepG,EAAEgG,OAGdb,GAAoBK,EAAQa,0BAA4B,OACvDrG,EAAAoG,KAAgBpG,EAAEgG,QACrBhG,EAAAA,IAAe3C,GAAO,CAAD,EAAK2C,EAC1BoG,GAAAA,GAED/I,GACC2C,EADKoG,IAELZ,EAAQa,yBAAyBnB,EAAUlF,EAFtCoG,GAAAA,CAAAA,GAMPtB,EAAW9E,EAAEzC,MACbwH,EAAW/E,EAAEgG,MACbhG,EAAAhB,IAAWsB,EAGPuE,EAEFM,GACAK,EAAQa,0BAA4B,MACpCrG,EAAEsG,oBAAsB,MAExBtG,EAAEsG,mBAAAA,EAGCnB,GAAoBnF,EAAEuG,mBAAqB,MAC9CvG,EAACkG,IAAkBjG,KAAKD,EAAEuG,iBAAAA,MAErB,CAUN,GARCpB,GACAK,EAAQa,0BAA4B,MACpCnB,IAAaJ,GACb9E,EAAEwG,2BAA6B,MAE/BxG,EAAEwG,0BAA0BtB,EAAUG,CAAAA,EAAAA,CAIrCrF,EACCA,MAAAA,EAAEyG,uBAAyB,MAC5BzG,EAAEyG,sBACDvB,EACAlF,EACAqF,IAAAA,CAAAA,IAJEoB,IAMHnG,EAAAA,MAAuBC,EAPxBvB,KAQC,CAkBD,IAhBIsB,EAAAtB,MAAuBuB,EAAvBvB,MAKHgB,EAAEzC,MAAQ2H,EACVlF,EAAEgG,MAAQhG,EAAAA,IACVA,EAACnB,IAAAA,IAGFyB,EAAA1B,IAAgB2B,EAChBD,IAAAA,EAAA7B,IAAqB8B,EAArB9B,IACA6B,EAAQ7B,IAAWiI,QAAQ,SAAAlI,EAAAA,CACtBA,IAAOA,EAAAE,GAAgB4B,EAC3B,CAAA,EAEQvD,EAAI,EAAGA,EAAIiD,EAAAA,IAAkB7B,OAAQpB,IAC7CiD,EAAAkG,IAAmBjG,KAAKD,EAACmG,IAAiBpJ,CAAAA,CAAAA,EAE3CiD,EAACmG,IAAmB,CAAA,EAEhBnG,EAAAkG,IAAmB/H,QACtBsC,EAAYR,KAAKD,CAAAA,EAGlB,MAAMyF,CACN,CAEGzF,EAAE2G,qBAAuB,MAC5B3G,EAAE2G,oBAAoBzB,EAAUlF,EAAhCoG,IAA8Cf,CAAAA,EAG3CF,GAAoBnF,EAAE4G,oBAAsB,MAC/C5G,EAAAkG,IAAmBjG,KAAK,UAAA,CACvBD,EAAE4G,mBAAmB9B,EAAUC,EAAUC,CAAAA,CACzC,CAAA,CAEF,CASD,GAPAhF,EAAET,QAAU8F,EACZrF,EAAEzC,MAAQ2H,EACVlF,EAAAc,IAAeI,EACflB,EAACpB,IAAAA,GAEG0G,EAAajJ,EAAjBwK,IACCtB,EAAQ,EACLJ,EAAkB,CAQrB,IAPAnF,EAAEgG,MAAQhG,EAAVoG,IACApG,EAACnB,IAAAA,GAEGyG,GAAYA,EAAWhF,CAAAA,EAE3BsE,EAAM5E,EAAE2F,OAAO3F,EAAEzC,MAAOyC,EAAEgG,MAAOhG,EAAET,OAAAA,EAE1BxC,EAAI,EAAGA,EAAIiD,EAAAmG,IAAkBhI,OAAQpB,IAC7CiD,EAACkG,IAAkBjG,KAAKD,EAAAA,IAAkBjD,CAAAA,CAAAA,EAE3CiD,EAAAmG,IAAoB,CAAA,CACpB,KACA,IACCnG,EAAAnB,IAAAA,GACIyG,GAAYA,EAAWhF,CAAAA,EAE3BsE,EAAM5E,EAAE2F,OAAO3F,EAAEzC,MAAOyC,EAAEgG,MAAOhG,EAAET,OAAAA,EAGnCS,EAAEgG,MAAQhG,EAAVoG,UACQpG,EAAAnB,KAAAA,EAAc0G,EAAQ,IAIhCvF,EAAEgG,MAAQhG,EAAVoG,IAEIpG,EAAE8G,iBAAmB,OACxBxF,EAAgBjE,GAAOA,GAAO,CAAD,EAAKiE,CAAAA,EAAgBtB,EAAE8G,gBAAAA,CAAAA,GAGjD3B,GAAAA,CAAqBN,GAAS7E,EAAE+G,yBAA2B,OAC9D/B,EAAWhF,EAAE+G,wBAAwBjC,EAAUC,CAAAA,GAOhD9D,GACCC,EACA/D,GAJGgE,EADHyD,GAAO,MAAQA,EAAI/G,OAASwB,IAAYuF,EAAI7G,KAAO,KACZ6G,EAAIrH,MAAMO,SAAW8G,CAAAA,EAIpCzD,EAAe,CAACA,CAAAA,EACxCb,EACAC,EACAe,EACAC,EACAC,EACAf,EACAD,EACAiB,EACAf,CAAAA,EAGDV,EAAEF,KAAOQ,EAAT1B,IAGA0B,EAAApB,KAAAA,KAEIc,EAAAkG,IAAmB/H,QACtBsC,EAAYR,KAAKD,CAAAA,EAGdiF,IACHjF,EAAA6F,IAAkB7F,EAAAtB,GAAyB,KAkB5C,OAhBQ2F,EAAAA,CACR/D,EAAQtB,IAAa,KAEjByC,GAAeD,GAAqB,MACvClB,EAAA1B,IAAgB4B,EAChBF,EAAApB,KAAmBuC,EAChBtF,IRpRqB,GQsRxBqF,EAAkBA,EAAkBwF,QAAQxG,CAAAA,CAAAA,EAAW,OAIvDF,EAAQ1B,IAAQ2B,EAChBD,IAAAA,EAAA7B,IAAqB8B,EACrB9B,KACDpC,EAAOuC,IAAayF,EAAG/D,EAAUC,CAAAA,CACjC,MAEDiB,GAAqB,MACrBlB,EAAAtB,MAAuBuB,EAAvBvB,KAEAsB,EAAA7B,IAAqB8B,EAArB9B,IACA6B,EAAQ1B,IAAQ2B,EAAAA,KAEhBD,EAAA1B,IAAgBqI,GACf1G,EACAD,IAAAA,EACAC,EACAe,EACAC,EACAC,EACAf,EACAgB,EACAf,CAAAA,GAIGkE,EAAMvI,EAAQ6K,SAAStC,EAAItE,CAAAA,CAChC,CAOM,SAASU,GAAWP,EAAa0G,EAAMzG,EAAAA,CAC7CyG,EAAAA,IAAAA,OAEA,QAASpK,EAAI,EAAGA,EAAI2D,EAASvC,OAAQpB,IACpCiF,GAAStB,EAAS3D,CAAAA,EAAI2D,EAAAA,EAAW3D,CAAAA,EAAI2D,EAAAA,EAAW3D,CAAAA,CAAAA,EAG7CV,EAAJyC,KAAqBzC,EAAOyC,IAASqI,EAAM1G,CAAAA,EAE3CA,EAAYwC,KAAK,SAAAjD,EAAAA,CAChB,GAAA,CAECS,EAAcT,EAAdkG,IACAlG,EAACkG,IAAoB,CAAA,EACrBzF,EAAYwC,KAAK,SAAAmE,EAAAA,CAEhBA,EAAGhJ,KAAK4B,CAAAA,CACR,CAAA,CAGD,OAFQqE,EAAAA,CACRhI,EAAOuC,IAAayF,EAAGrE,EAAvBhB,GAAAA,CACA,CACD,CAAA,CACD,CAiBD,SAASiI,GACRxD,EACAnD,EACAC,EACAe,EACAC,EACAC,EACAf,EACAgB,EACAf,EAAAA,CATD,IAeK3D,EAEAsK,EAEAC,EAEAC,EACAjE,EACAkE,EACAC,EAbA3C,EAAWvE,EAAShD,MACpB2H,EAAW5E,EAAS/C,MACpBuF,EAAkCxC,EAASzC,KAmB/C,GALIiF,IAAa,MAAOvB,EAAY,6BAC3BuB,IAAa,OACrBvB,EAAY,qCACHA,IAAWA,EAAY,gCAE7BC,GAAqB,MACxB,IAAKzE,EAAI,EAAGA,EAAIyE,EAAkBrD,OAAQpB,IAMzC,IALAuG,EAAQ9B,EAAkBzE,CAAAA,IAOzB,iBAAkBuG,GAAAA,CAAAA,CAAYR,IAC7BA,EAAWQ,EAAMoE,YAAc5E,EAAWQ,EAAMR,WAAa,GAC7D,CACDW,EAAMH,EACN9B,EAAkBzE,CAAAA,EAAK,KACvB,KACA,EAIH,GAAI0G,GAAO,KAAM,CAChB,GAAIX,IAAa,KAChB,OAAO6E,SAASC,eAAe1C,CAAAA,EAGhCzB,EAAMkE,SAASE,gBACdtG,EACAuB,EACAoC,EAAS4C,IAAM5C,CAAAA,EAIhB1D,EAAoB,KAGpBC,EAAAA,EACA,CAED,GAAIqB,IAAa,KAEZgC,IAAaI,GAAczD,GAAegC,EAAIsE,OAAS7C,IAC1DzB,EAAIsE,KAAO7C,OAEN,CASN,GAPA1D,EAAoBA,GAAqBpF,GAAMgC,KAAKqF,EAAIuE,UAAAA,EAExDlD,EAAWvE,EAAShD,OAASP,GAAAA,CAKxByE,GAAeD,GAAqB,KAExC,IADAsD,EAAW,CAAX,EACK/H,EAAI,EAAGA,EAAI0G,EAAIwE,WAAW9J,OAAQpB,IAEtC+H,GADAxB,EAAQG,EAAIwE,WAAWlL,CAAAA,GACR2G,IAAAA,EAAQJ,EAAMA,MAI/B,IAAKvG,KAAK+H,EAET,GADAxB,EAAQwB,EAAS/H,CAAAA,EACbA,GAAK,YACEA,GAAAA,GAAK,0BACfuK,EAAUhE,UACAvG,IAAM,OAANA,EAAiBA,KAAKmI,GAAW,CAC3C,GACEnI,GAAK,SAAW,iBAAkBmI,GAClCnI,GAAK,WAAa,mBAAoBmI,EAEvC,SAED3B,GAAYE,EAAK1G,EAAG,KAAMuG,EAAO/B,CAAAA,CACjC,EAKF,IAAKxE,KAAKmI,EACT5B,EAAQ4B,EAASnI,CAAAA,EACbA,GAAK,WACRwK,EAAcjE,EACJvG,GAAK,0BACfsK,EAAU/D,EACAvG,GAAK,QACfyK,EAAalE,EACHvG,GAAK,UACf0K,EAAUnE,EAEVvG,IAAM,OACJ0E,GAA+B,OAAT6B,GAAS,YACjCwB,EAAS/H,CAAAA,IAAOuG,GAEhBC,GAAYE,EAAK1G,EAAGuG,EAAOwB,EAAS/H,CAAAA,EAAIwE,CAAAA,EAK1C,GAAI8F,EAGD5F,GACC6F,IACAD,EAAOa,SAAYZ,EACnBD,QAAAA,EAAAa,SAAmBzE,EAAI0E,aAEzB1E,EAAI0E,UAAYd,EAAhBa,QAGD5H,EAAA7B,IAAqB,CAAA,UAEjB6I,IAAS7D,EAAI0E,UAAY,IAE7BlH,GACCwC,EACAtG,GAAQoK,CAAAA,EAAeA,EAAc,CAACA,CAAAA,EACtCjH,EACAC,EACAe,EACAwB,IAAa,gBACV,+BACAvB,EACHC,EACAf,EACAe,EACGA,EAAkB,CAAA,EAClBjB,EAAAA,KAAsBd,GAAcc,EAAU,CAAA,EACjDkB,EACAf,CAAAA,EAIGc,GAAqB,KACxB,IAAKzE,EAAIyE,EAAkBrD,OAAQpB,KAC9ByE,EAAkBzE,CAAAA,GAAM,MAAMS,GAAWgE,EAAkBzE,CAAAA,CAAAA,EAM7D0E,IACJ1E,EAAI,QAEHyK,IAFG,SAOFA,IAAe/D,EAAI1G,CAAAA,GAClB+F,IAAa,YAAbA,CAA4B0E,GAI5B1E,IAAa,UAAY0E,IAAe1C,EAAS/H,CAAAA,IAEnDwG,GAAYE,EAAK1G,EAAGyK,EAAY1C,EAAS/H,CAAAA,EAAIwE,CAAAA,EAG9CxE,EAAI,UACA0K,IADA,QACyBA,IAAYhE,EAAI1G,CAAAA,GAC5CwG,GAAYE,EAAK1G,EAAG0K,EAAS3C,EAAS/H,CAAAA,EAAIwE,CAAAA,EAG5C,CAED,OAAOkC,CACP,CAQM,SAASzB,GAAShE,EAAKsF,EAAO9E,EAAAA,CACpC,GAAA,CACmB,OAAPR,GAAO,WAAYA,EAAIsF,CAAAA,EAC7BtF,EAAIoB,QAAUkE,CAGnB,OAFQe,EAAAA,CACRhI,EAAAA,IAAoBgI,EAAG7F,CAAAA,CACvB,CACD,CASemE,SAAAA,GAAQnE,EAAOoE,EAAawF,EAAAA,CAA5BzF,IACX0F,EAsBMtL,EAbV,GARIV,EAAQsG,SAAStG,EAAQsG,QAAQnE,CAAAA,GAEhC6J,EAAI7J,EAAMR,OACTqK,EAAEjJ,SAAWiJ,EAAEjJ,UAAYZ,EAAdI,KACjBoD,GAASqG,EAAG,KAAMzF,CAAAA,IAIfyF,EAAI7J,EAAHM,MAAwB,KAAM,CACnC,GAAIuJ,EAAEC,qBACL,GAAA,CACCD,EAAEC,qBAAAA,CAGF,OAFQjE,EAAAA,CACRhI,EAAOuC,IAAayF,EAAGzB,CAAAA,CACvB,CAGFyF,EAAEvI,KAAOuI,EAAAvH,IAAe,IACxB,CAED,GAAKuH,EAAI7J,EAATC,IACC,IAAS1B,EAAI,EAAGA,EAAIsL,EAAElK,OAAQpB,IACzBsL,EAAEtL,CAAAA,GACL4F,GACC0F,EAAEtL,CAAAA,EACF6F,EACAwF,GAAmC,OAAd5J,EAAMX,MAAQ,UAARA,EAM1BuK,GAAc5J,EAAKI,KAAS,MAChCpB,GAAWgB,EACXI,GAAAA,EAIDJ,EAAKM,IAAcN,EAAAA,GAAgBA,EAAAI,IAAaJ,EAAKK,IAAAA,MACrD,CAGD,SAASiH,GAASvI,EAAOyI,EAAOzG,EAAAA,CAC/B,OAAOC,KAAKT,YAAYxB,EAAOgC,CAAAA,CAC/B,CCjmBeoG,SAAAA,GAAOnH,EAAO0C,EAAWqH,EAAAA,CAAzB5C,IAMXlE,EAOAlB,EAQAE,EACHC,EArBGrE,EAAeA,IAAAA,EAAAqC,GAAcF,EAAO0C,CAAAA,EAYpCX,GAPAkB,EAAoC,OAAf8G,GAAe,YAQrC,KACCA,GAAeA,EAAhB9J,KAA0CyC,EAF7CzC,IAQIgC,EAAc,CAAA,EACjBC,EAAW,CAAA,EACZG,GACCK,EAPD1C,GAAAA,CAAWiD,GAAe8G,GAAgBrH,GAAlCzC,IACPb,GAAcyB,GAAU,KAAM,CAACb,CAAAA,CAAAA,EAU/B+B,GAAYvD,GACZA,GACAkE,EAAUH,aAAAA,CACTU,GAAe8G,EACb,CAACA,CAAAA,EACDhI,EACC,KACAW,EAAUsH,WACTpM,GAAMgC,KAAK8C,EAAU8G,UAAAA,EACrB,KACLvH,EAAAA,CACCgB,GAAe8G,EACbA,EACAhI,EACCA,EACAW,IAAAA,EAAUsH,WACd/G,EACAf,CAAAA,EAIDM,GAAWP,EAAajC,EAAOkC,CAAAA,CAC/B,CAOM,SAAS+H,GAAQjK,EAAO0C,EAAAA,CAC9ByE,GAAOnH,EAAO0C,EAAWuH,EAAAA,CACzB,CAAA,SC5DeC,GAAalK,EAAOjB,EAAOO,EAAAA,CAAAA,IAEzCC,EACAC,EACAjB,EAEGsB,EALAJ,EAAkBZ,GAAO,CAAD,EAAKmB,EAAMjB,KAAAA,EAWvC,IAAKR,KAJDyB,EAAMX,MAAQW,EAAMX,KAAKQ,eAC5BA,EAAeG,EAAMX,KAAKQ,cAGjBd,EACLR,GAAK,MAAOgB,EAAMR,EAAMR,CAAAA,EACnBA,GAAK,MAAOiB,EAAMT,EAAMR,CAAAA,EAEhCkB,EAAgBlB,CAAAA,EADRQ,EAAMR,CAAAA,IACEA,QADkBsB,IAApBtB,OACOsB,EAAatB,CAAAA,EAEbQ,EAAMR,CAAAA,EAS7B,OALImB,UAAUC,OAAS,IACtBF,EAAgBH,SACfI,UAAUC,OAAS,EAAI/B,GAAMgC,KAAKF,UAAW,CAAA,EAAKJ,GAG7CQ,GACNE,EAAMX,KACNI,EACAF,GAAOS,EAAMT,IACbC,GAAOQ,EAAMR,IACb,IAAA,CAED,CAAA,SJ1Ce2K,GAAcC,EAAcC,EAAAA,CAG3C,IAAMtJ,EAAU,CACfT,IAHD+J,EAAY,OAAS9L,KAIpB2B,GAAekK,EAEfE,SAJe,SAINvL,EAAOwL,EAAAA,CAIf,OAAOxL,EAAMO,SAASiL,CAAAA,CACtB,EAEDC,SAXe,SAWNzL,EAAAA,CAXM,IAcT0L,EACAC,EA8BL,OAjCK1J,KAAKsH,kBAELmC,EAAO,CAAA,GACPC,EAAM,CAAA,GACNL,CAAAA,EAAarJ,KAEjBA,KAAKsH,gBAAkB,UAAA,CAAA,OAAMoC,CAAN,EAEvB1J,KAAK8I,qBAAuB,UAAA,CAC3BW,EAAO,IACP,EAEDzJ,KAAKiH,sBAAwB,SAAU0C,EAAAA,CAClC3J,KAAKjC,MAAM+F,QAAU6F,EAAO7F,OAC/B2F,EAAKhG,KAAK,SAAAjD,EAAAA,CACTA,EAACpB,IAAAA,GACDmB,GAAcC,CAAAA,CACd,CAAA,CAEF,EAEDR,KAAKuG,IAAM,SAAA/F,EAAAA,CACViJ,EAAKhJ,KAAKD,CAAAA,EACV,IAAIoJ,EAAMpJ,EAAEsI,qBACZtI,EAAEsI,qBAAuB,UAAA,CACpBW,GACHA,EAAKI,OAAOJ,EAAKjC,QAAQhH,CAAAA,EAAI,CAAA,EAE1BoJ,GAAKA,EAAIhL,KAAK4B,CAAAA,CAClB,CACD,GAGKzC,EAAMO,QACb,CAAA,EASF,OAAQyB,EAAQyJ,SAAuBzJ,GAAAA,EAAQuJ,SAASlD,YACvDrG,CACD,CLpCYnD,GAAQa,GAAUb,MCjBzBC,EAAU,CACfuC,ISHM,SAAqB0K,EAAO9K,EAAO+B,EAAUgJ,EAAAA,CAQnD,QANIlJ,EAEHmJ,EAEAC,EAEOjL,EAAQA,EAAhBE,IACC,IAAK2B,EAAY7B,EAAHM,MAAAA,CAAyBuB,EAAD3B,GACrC,GAAA,CAcC,IAbA8K,EAAOnJ,EAAUtB,cAELyK,EAAKE,0BAA4B,OAC5CrJ,EAAUsJ,SAASH,EAAKE,yBAAyBJ,CAAAA,CAAAA,EACjDG,EAAUpJ,EAAHxB,KAGJwB,EAAUuJ,mBAAqB,OAClCvJ,EAAUuJ,kBAAkBN,EAAOC,GAAa,CAAhD,CAAA,EACAE,EAAUpJ,EACVxB,KAGG4K,EACH,OAAQpJ,EAASwF,IAAiBxF,CAInC,OAFQgE,EAAAA,CACRiF,EAAQjF,CACR,CAIH,MAAMiF,CACN,CAAA,ERxCGhN,GAAU,EAgGDC,GAAiB,SAAAiC,EAAAA,CAC7BA,OAAAA,GAAS,MAAQA,EAAMO,aAAe8K,IADJ,ECxEnCvK,GAAcoG,UAAUiE,SAAW,SAAUG,EAAQC,EAAAA,CAEpD,IAAIC,EAEHA,EADGxK,KAAA4G,KAAmB,MAAQ5G,KAAA4G,MAAoB5G,KAAKwG,MACnDxG,KAAH4G,IAEG5G,KAAA4G,IAAkB/I,GAAO,CAAD,EAAKmC,KAAKwG,KAAAA,EAGlB,OAAV8D,GAAU,aAGpBA,EAASA,EAAOzM,GAAO,CAAA,EAAI2M,CAAAA,EAAIxK,KAAKjC,KAAAA,GAGjCuM,GACHzM,GAAO2M,EAAGF,CAAAA,EAIPA,GAAU,MAEVtK,KAAJR,MACK+K,GACHvK,KAAA2G,IAAqBlG,KAAK8J,CAAAA,EAE3BhK,GAAcP,IAAAA,EAEf,EAQDF,GAAcoG,UAAUuE,YAAc,SAAUF,EAAAA,CAC3CvK,KAAAA,MAIHA,KAAAZ,IAAAA,GACImL,GAAUvK,KAAA0G,IAAsBjG,KAAK8J,CAAAA,EACzChK,GAAcP,IAAAA,EAEf,EAYDF,GAAcoG,UAAUC,OAAStG,GA8F7B7C,GAAgB,CAAA,EAadE,GACa,OAAXwN,SAAW,WACfA,QAAQxE,UAAUyE,KAAKC,KAAKF,QAAQG,QAAAA,CAAAA,EACpCC,WAuBE3N,GAAY,SAAC4N,EAAGC,EAAAA,CAAMD,OAAAA,EAAAvL,IAAAL,IAAkB6L,EAA5BxL,IAAAL,GAAA,EAuBlBuB,GAAO2G,IAAkB,ECtNrBjK,GAAa,EAmJXC,GAAa2H,GAAAA,EAAiB,EAC9B1H,GAAoB0H,GAAAA,EAAiB,EC5KhCzH,GAAI,EMCf,IAAI0N,GAGAC,EAGAC,GAmBAC,GAhBAC,GAAc,EAGdC,GAAoB,CAAA,EAGlBC,EAAuDC,EAEzDC,GAAgBF,EAApBG,IACIC,GAAkBJ,EAAHK,IACfC,GAAeN,EAAQO,OACvBC,GAAYR,EAAhBS,IACIC,GAAmBV,EAAQW,QAC3BC,GAAUZ,EAAda,GA8GA,SAASC,GAAaC,EAAOC,EAAAA,CACxBhB,EAAAA,KACHA,EAAAiB,IAActB,EAAkBoB,EAAOjB,IAAekB,CAAAA,EAEvDlB,GAAc,EAOd,IAAMoB,EACLvB,EAAAwB,MACCxB,EAAgBwB,IAAW,CAC3BN,GAAO,CAAA,EACPI,IAAiB,CAAA,CAAA,GAOnB,OAJIF,GAASG,EAAKL,GAAOO,QACxBF,EAAAL,GAAYQ,KAAK,CAAjB,CAAA,EAGMH,EAAAL,GAAYE,CAAAA,CACnB,CAOM,SAASO,EAASC,EAAAA,CAExB,OADAzB,GAAc,EACP0B,GAAWC,GAAgBF,CAAAA,CAClC,CAUeC,SAAAA,GAAWE,EAASH,EAAcI,EAAAA,CAEjD,IAAMC,EAAYd,GAAapB,KAAgB,CAAA,EAE/C,GADAkC,EAAUC,EAAWH,EAAAA,CAChBE,EAALnB,MACCmB,EAASf,GAAU,CACjBc,EAAiDA,EAAKJ,CAAAA,EAA/CE,GAAAA,OAA0BF,CAAAA,EAElC,SAAAO,EAAAA,CACC,IAAMC,EAAeH,EAAAA,IAClBA,EAAAI,IAAqB,CAAA,EACrBJ,EAAAf,GAAiB,CAAA,EACdoB,EAAYL,EAAUC,EAASE,EAAcD,CAAAA,EAE/CC,IAAiBE,IACpBL,EAASI,IAAc,CAACC,EAAWL,EAAAf,GAAiB,CAAA,CAAA,EACpDe,EAAAnB,IAAqByB,SAAS,CAA9B,CAAA,EAED,CAAA,EAGFN,EAASnB,IAAcd,EAAAA,CAElBA,EAAiBwC,GAAkB,CAgC9BC,IAAAA,EAAT,SAAyBC,EAAGC,EAAGC,EAAAA,CAC9B,GAAA,CAAKX,EAADnB,IAAAU,IAA+B,MAAA,GAGnC,IACMqB,EACLZ,EAAAnB,IAAAU,IAAAN,GAAmC4B,OAFhB,SAAAC,EAAAA,CAAC,MAAA,CAAA,CAAMA,EAANjC,GAAA,CAAA,EAOrB,GAHsB+B,EAAWG,MAAM,SAAAD,EAAAA,CAAK,MAAA,CAACA,EAADV,GAAJ,CAAA,EAIvC,MAAA,CAAOY,GAAUA,EAAQC,KAAKC,KAAMT,EAAGC,EAAGC,CAAAA,EAM3C,IAAIQ,EAAAA,GAUJ,OATAP,EAAWQ,QAAQ,SAAAC,EAAAA,CAClB,GAAIA,EAAqBjB,IAAA,CACxB,IAAMD,EAAekB,EAAApC,GAAgB,CAAA,EACrCoC,EAAApC,GAAkBoC,EAAlBjB,IACAiB,EAAAjB,IAAAA,OACID,IAAiBkB,EAAApC,GAAgB,CAAA,IAAIkC,EAAAA,GACzC,CACD,CAAA,EAAA,EAAA,CAEMA,GAAgBnB,EAAAnB,IAAqByC,QAAUb,KAAAA,CACnDO,GACCA,EAAQC,KAAKC,KAAMT,EAAGC,EAAGC,CAAAA,EAG7B,EAhED5C,EAAiBwC,EAAAA,GACjB,IAAIS,EAAUjD,EAAiBwD,sBACzBC,EAAUzD,EAAiB0D,oBAKjC1D,EAAiB0D,oBAAsB,SAAUhB,EAAGC,EAAGC,EAAAA,CACtD,GAAIO,KAAJQ,IAAiB,CAChB,IAAIC,EAAMX,EAEVA,EAAAA,OACAR,EAAgBC,EAAGC,EAAGC,CAAAA,EACtBK,EAAUW,CACV,CAEGH,GAASA,EAAQP,KAAKC,KAAMT,EAAGC,EAAGC,CAAAA,CACtC,EAiDD5C,EAAiBwD,sBAAwBf,CACzC,CAGF,OAAOR,EAAAA,KAAwBA,EAC/Bf,EAAA,CAOM,SAAS2C,EAAUC,EAAUC,EAAAA,CAEnC,IAAMC,EAAQ7C,GAAapB,KAAgB,CAAA,EAAA,CACtCM,EAAD4D,KAAyBC,GAAYF,EAADxC,IAAcuC,CAAAA,IACrDC,EAAA9C,GAAe4C,EACfE,EAAMG,EAAeJ,EAErB/D,EAAgBwB,IAAAA,IAAyBE,KAAKsC,CAAAA,EAE/C,CAOeI,SAAAA,GAAgBN,EAAUC,EAAAA,CAEzC,IAAMC,EAAQ7C,GAAapB,KAAgB,CAAA,EAAA,CACtCM,EAAwB6D,KAAAA,GAAYF,EAAaD,IAAAA,CAAAA,IACrDC,EAAA9C,GAAe4C,EACfE,EAAMG,EAAeJ,EAErB/D,EAAAsB,IAAkCI,KAAKsC,CAAAA,EAExC,CAGeK,SAAAA,EAAOC,EAAAA,CAEtB,OADAnE,GAAc,EACPoE,GAAQ,UAAA,CAAA,MAAO,CAAEC,QAASF,CAAAA,CAAlB,EAAmC,CAAA,CAAA,CAClD,CAQeG,SAAAA,GAAoBC,EAAKC,EAAcZ,EAAAA,CACtD5D,GAAc,EACdiE,GACC,UAAA,CACC,OAAkB,OAAPM,GAAO,YACjBA,EAAIC,EAAAA,CAAAA,EACSD,UAAAA,CAAAA,OAAAA,EAAI,IAAA,CAAV,GACGA,GACVA,EAAIF,QAAUG,EAAAA,EACP,UAAA,CAAA,OAAOD,EAAIF,QAAU,IAArB,GAAA,MAER,EACDT,GAAQ,KAAOA,EAAOA,EAAKa,OAAOF,CAAAA,CAAAA,CAEnC,CAQM,SAASH,GAAQM,EAASd,EAAAA,CAEhC,IAAMC,EAAQ7C,GAAapB,KAAgB,CAAA,EAO3C,OANImE,GAAYF,EAADxC,IAAcuC,CAAAA,IAC5BC,EAAK9C,GAAU2D,EAAAA,EACfb,EAAAxC,IAAcuC,EACdC,EAAK1C,IAAYuD,GAGXb,EACP9C,EAAA,CAOe4D,SAAAA,EAAYhB,EAAUC,EAAAA,CAErC,OADA5D,GAAc,EACPoE,GAAQ,UAAA,CAAMT,OAAAA,CAAN,EAAgBC,CAAAA,CAC/B,CAKegB,SAAAA,GAAWC,EAAAA,CAC1B,IAAMC,EAAWjF,EAAiBgF,QAAQA,EAAzBlE,GAAAA,EAKXkD,EAAQ7C,GAAapB,KAAgB,CAAA,EAK3C,OADAiE,EAAKpB,EAAYoC,EACZC,GAEDjB,EAAA9C,IAAgB,OACnB8C,EAAK9C,GAAAA,GACL+D,EAASC,IAAIlF,CAAAA,GAEPiF,EAAS1B,MAAM4B,OANAH,EAAP9D,EAOf,CAMM,SAASkE,GAAcD,EAAOE,EAAAA,CAChChF,EAAQ+E,eACX/E,EAAQ+E,cACPC,EAAYA,EAAUF,CAAAA,EAA4BA,CAAAA,CAGpD,CA0BM,SAASG,IAAAA,CAEf,IAAMC,EAAQC,GAAaC,KAAgB,EAAA,EAC3C,GAAA,CAAKF,EAAAA,GAAc,CAIlB,QADIG,EAAOC,EAAHC,IACDF,IAAS,MAATA,CAAkBA,EAADG,KAAeH,EAAAI,KAAiB,MACvDJ,EAAOA,EAAHI,GAGL,IAAIC,EAAOL,EAAIG,MAAWH,EAAAG,IAAa,CAAC,EAAG,CAAA,GAC3CN,EAAKO,GAAU,IAAMC,EAAK,CAAA,EAAK,IAAMA,EAAK,CAAA,GAC1C,CAED,OAAOR,EAAPO,EACA,CAKD,SAASE,IAAAA,CAER,QADIC,EACIA,EAAYC,GAAkBC,MAAAA,GACrC,GAAKF,EAADG,KAA0BH,EAA9BI,IACA,GAAA,CACCJ,EAAAI,IAAAC,IAAkCC,QAAQC,EAAAA,EAC1CP,EAAAI,IAAAC,IAAkCC,QAAQE,EAAAA,EAC1CR,EAASI,IAA2BC,IAAA,CAAA,CAIpC,OAHQI,EAAAA,CACRT,EAASI,IAA2BC,IAAA,CAAA,EACpCK,EAAAC,IAAoBF,EAAGT,EAAvBL,GAAAA,CACA,CAEF,CAzaDe,EAAAE,IAAgB,SAAAC,EAAAA,CACfnB,EAAmB,KACfoB,IAAeA,GAAcD,CAAAA,CACjC,EAEDH,EAAOb,GAAS,SAACgB,EAAOE,EAAAA,CACnBF,GAASE,EAAJC,KAA2BD,EAApCC,IAAApB,MACCiB,EAAKjB,IAASmB,EACdC,IAAApB,KAEGqB,IAASA,GAAQJ,EAAOE,CAAAA,CAC5B,EAGDL,EAAOQ,IAAW,SAAAL,EAAAA,CACbM,IAAiBA,GAAgBN,CAAAA,EAGrCrB,GAAe,EAEf,IAAM4B,GAHN1B,EAAmBmB,EAAHQ,KAGLjB,IACPgB,IACCE,KAAsB5B,GACzB0B,EAAAf,IAAwB,CAAA,EACxBX,EAAgBW,IAAoB,CAAA,EACpCe,EAAAvB,GAAYS,QAAQ,SAAAiB,EAAAA,CACfA,EAAJC,MACCD,EAAA1B,GAAkB0B,EAAlBC,KAEDD,EAASE,EAAeF,EAAQC,IAAAA,MAChC,CAAA,IAEDJ,EAAAf,IAAsBC,QAAQC,EAAAA,EAC9Ba,EAAAf,IAAsBC,QAAQE,EAAAA,EAC9BY,EAAAf,IAAwB,CAAA,EACxBb,GAAe,IAGjB8B,GAAoB5B,CACpB,EAGDgB,EAAQgB,OAAS,SAAAb,EAAAA,CACZc,IAAcA,GAAad,CAAAA,EAE/B,IAAMe,EAAIf,EAAVQ,IACIO,GAAKA,EAATxB,MACKwB,EAACxB,IAAAA,IAAyByB,SAAmB5B,GAAkB6B,KAAKF,CAAAA,IA+ZlD,GAAKG,KAAYrB,EAAQsB,yBAC/CD,GAAUrB,EAAQsB,wBACNC,IAAgBlC,EAAAA,GAha5B6B,EAAAA,IAAgBtB,GAAAA,QAAQ,SAAAiB,EAAAA,CACnBA,EAASE,IACZF,EAAAA,IAAiBA,EAASE,GAE3BF,EAASE,EAAAA,MACT,CAAA,GAEFH,GAAoB5B,EAAmB,IACvC,EAIDgB,EAAAW,IAAkB,SAACR,EAAOqB,EAAAA,CACzBA,EAAYC,KAAK,SAAAnC,EAAAA,CAChB,GAAA,CACCA,EAASK,IAAkBC,QAAQC,EAAAA,EACnCP,EAASK,IAAoBL,EAAAK,IAA2B+B,OAAO,SAAAC,EAAAA,CAC9DA,MAAAA,CAAAA,EAAAxC,IAAYW,GAAa6B,CAAAA,CADuC,CAAA,CASjE,OANQ5B,EAAAA,CACRyB,EAAYC,KAAK,SAAAP,EAAAA,CACZA,EAAoBA,MAAAA,EAAAvB,IAAqB,CAAA,EAC7C,CAAA,EACD6B,EAAc,CAAA,EACdxB,EAAAC,IAAoBF,EAAGT,EAAvBL,GAAAA,CACA,CACD,CAAA,EAEG2C,IAAWA,GAAUzB,EAAOqB,CAAAA,CAChC,EAGDxB,EAAQ6B,QAAU,SAAA1B,EAAAA,CACb2B,IAAkBA,GAAiB3B,CAAAA,EAEvC,IAEK4B,EAFCb,EAAIf,EAAVQ,IACIO,GAAKA,EAATxB,MAECwB,EAACxB,IAAeE,GAAAA,QAAQ,SAAAoC,EAAAA,CACvB,GAAA,CACCnC,GAAcmC,CAAAA,CAGd,OAFQjC,EAAAA,CACRgC,EAAahC,CACb,CACD,CAAA,EACDmB,EAAAxB,IAAAA,OACIqC,GAAY/B,EAAOC,IAAa8B,EAAYb,EAAAA,GAAAA,EAEjD,EA2UD,IAAIe,GAA0C,OAAzBX,uBAAyB,WAY9C,SAASC,GAAeW,EAAAA,CACvB,IAOIC,EAPEC,EAAO,UAAA,CACZC,aAAaC,CAAAA,EACTL,IAASM,qBAAqBJ,CAAAA,EAClCK,WAAWN,CAAAA,CACX,EACKI,EAAUE,WAAWJ,EAjcR,GAAA,EAocfH,KACHE,EAAMb,sBAAsBc,CAAAA,EAE7B,CAqBD,SAASvC,GAAc4C,EAAAA,CAGtB,IAAMC,EAAO1D,EACT2D,EAAUF,EAAH9B,IACW,OAAXgC,GAAW,aACrBF,EAAI9B,IAAAA,OACJgC,EAAAA,GAGD3D,EAAmB0D,CACnB,CAOD,SAAS5C,GAAa2C,EAAAA,CAGrB,IAAMC,EAAO1D,EACbyD,EAAA9B,IAAgB8B,EAAItD,GAAAA,EACpBH,EAAmB0D,CACnB,CAOD,SAASE,GAAYC,EAASC,EAAAA,CAC7B,MAAA,CACED,GACDA,EAAQ1B,SAAW2B,EAAQ3B,QAC3B2B,EAAQrB,KAAK,SAACsB,EAAKC,EAAAA,CAAUD,OAAAA,IAAQF,EAAQG,CAAAA,CAAhC,CAAA,CAEd,CAQD,SAASC,GAAeF,EAAKG,EAAAA,CAC5B,OAAmB,OAALA,GAAK,WAAaA,EAAEH,CAAAA,EAAOG,CACzC,CC/hBeC,SAAAA,GAAOC,EAAKC,EAAAA,CAC3B,QAASC,KAAKD,EAAOD,EAAIE,CAAAA,EAAKD,EAAMC,CAAAA,EACpC,OAA6BF,CAC7B,CAQeG,SAAAA,GAAeC,EAAGC,EAAAA,CACjC,QAASH,KAAKE,EAAG,GAAIF,IAAM,YAANA,EAAsBA,KAAKG,GAAI,MAAA,GACpD,QAASH,KAAKG,EAAG,GAAIH,IAAM,YAAcE,EAAEF,CAAAA,IAAOG,EAAEH,CAAAA,EAAI,MAAA,GACxD,MAAA,EACA,CChBeI,SAAAA,GAAcC,EAAGC,EAAAA,CAChCC,KAAKR,MAAQM,EACbE,KAAKC,QAAUF,CACf,CCCM,SAASG,GAAKH,EAAGI,EAAAA,CACvB,SAASC,EAAaC,EAAAA,CACrB,IAAIC,EAAMN,KAAKR,MAAMc,IACjBC,EAAYD,GAAOD,EAAUC,IAKjC,MAAA,CAJKC,GAAaD,IACjBA,EAAIE,KAAOF,EAAI,IAAA,EAASA,EAAIG,QAAU,MAGlCN,EAAAA,CAIGA,EAASH,KAAKR,MAAOa,CAAAA,GAAAA,CAAeE,EAHpCb,GAAeM,KAAKR,MAAOa,CAAAA,CAInC,CAED,SAASK,EAAOlB,EAAAA,CAEf,OADAQ,KAAKW,sBAAwBP,EACtBQ,GAAcb,EAAGP,CAAAA,CACxB,CAID,OAHAkB,EAAOG,YAAc,SAAWd,EAAEc,aAAed,EAAEe,MAAQ,IAC3DJ,EAAOK,UAAUC,iBAAAA,GACjBN,EAAAA,IAAAA,GACOA,CACP,EDvBDb,GAAckB,UAAY,IAAIE,IAENC,qBAAAA,GACxBrB,GAAckB,UAAUJ,sBAAwB,SAAUnB,EAAO2B,EAAAA,CAChE,OAAOzB,GAAeM,KAAKR,MAAOA,CAAAA,GAAUE,GAAeM,KAAKmB,MAAOA,CAAAA,CACvE,EEZD,IAAIC,GAAcC,EAAlBC,IACAD,EAAAC,IAAgB,SAAAC,EAAAA,CACXA,EAAMC,MAAQD,EAAMC,KAApBC,KAAuCF,EAAMjB,MAChDiB,EAAM/B,MAAMc,IAAMiB,EAAMjB,IACxBiB,EAAMjB,IAAM,MAETc,IAAaA,GAAYG,CAAAA,CAC7B,EAEYG,IAAAA,GACM,OAAVC,OAAU,KACjBA,OAAOC,KACPD,OAAOC,IAAI,mBAAA,GACZ,KAAA,SASeC,GAAWC,EAAAA,CAC1B,SAASC,EAAUvC,EAAAA,CAClB,IAAIwC,EAAQ1C,GAAO,CAAD,EAAKE,CAAAA,EAEvB,OAAA,OADOwC,EAAM1B,IACNwB,EAAGE,EAAOxC,EAAMc,KAAO,IAAA,CAC9B,CAYD,OATAyB,EAAUE,SAAWP,GAKrBK,EAAUG,OAASH,EAEnBA,EAAUhB,UAAUC,iBAAmBe,EAASN,IAAAA,GAChDM,EAAUlB,YAAc,eAAiBiB,EAAGjB,aAAeiB,EAAGhB,MAAQ,IAC/DiB,CACP,CCzCD,IAAMI,GAAQ,SAACC,EAAUN,EAAAA,CACxB,OAAIM,GAAY,KAAa,KACtBC,GAAaA,GAAaD,CAAAA,EAAUE,IAAIR,CAAAA,CAAAA,CAC/C,EAGYS,GAAW,CACvBD,IAAKH,GACLK,QAASL,GACTM,MAHuB,SAGjBL,EAAAA,CACL,OAAOA,EAAWC,GAAaD,CAAAA,EAAUM,OAAS,CAClD,EACDC,KAAAA,SAAKP,EAAAA,CACJ,IAAMQ,EAAaP,GAAaD,CAAAA,EAChC,GAAIQ,EAAWF,SAAW,EAAG,KAAM,gBACnC,OAAOE,EAAW,CAAA,CAClB,EACDC,QAASR,EAAAA,ECfJS,GAAgBzB,EAAAA,IACtBA,EAAAA,IAAsB,SAAU0B,EAAOC,EAAUC,EAAUC,EAAAA,CAC1D,GAAIH,EAAMI,MAKT,QAHIC,EACA7B,EAAQyB,EAEJzB,EAAQA,EAAH8B,IACZ,IAAKD,EAAY7B,EAAb+B,MAAkCF,EAAlCE,IAMH,OALIN,EAAQO,KAAS,OACpBP,EAAAO,IAAgBN,EAAhBM,IACAP,EAAAQ,IAAqBP,EAArBO,KAGMJ,EAASE,IAAkBP,EAAOC,CAAAA,EAI5CF,GAAcC,EAAOC,EAAUC,EAAUC,CAAAA,CACzC,EAED,IAAMO,GAAapC,EAAQqC,QAmB3B,SAASC,GAAcpC,EAAOqC,EAAgBC,EAAAA,CAyB7C,OAxBItC,IACCA,EAAK+B,KAAe/B,EAAxB+B,IAAAQ,MACCvC,EAAK+B,IAA0Bd,IAAAA,GAAAA,QAAQ,SAAAuB,EAAAA,CACR,OAAnBA,EAAAA,KAAmB,YAAYA,EAAMT,IAAAA,CAChD,CAAA,EAED/B,EAAK+B,IAAAA,IAAsB,OAG5B/B,EAAQjC,GAAO,CAAA,EAAIiC,CAAAA,GACV+B,KAAe,OACnB/B,EAAK+B,IAA2BO,MAAAA,IACnCtC,EAAA+B,IAAAU,IAA8BJ,GAE/BrC,EAAA+B,IAAmB,MAGpB/B,EAAKiC,IACJjC,EAAKiC,KACLjC,EAAAiC,IAAgBlB,IAAI,SAAA2B,EAAAA,CAAK,OACxBN,GAAcM,EAAOL,EAAgBC,CAAAA,CADb,CAAA,GAKpBtC,CACP,CAED,SAAS2C,GAAe3C,EAAOqC,EAAgBO,EAAAA,CAoB9C,OAnBI5C,GAAS4C,IACZ5C,EAAA6C,IAAkB,KAClB7C,EAAAiC,IACCjC,EAAKiC,KACLjC,EAAKiC,IAAWlB,IAAI,SAAA2B,EAAAA,CACnBC,OAAAA,GAAeD,EAAOL,EAAgBO,CAAAA,CADd,CAAA,EAItB5C,EAAkB+B,KACjB/B,EAAAA,IAAgCqC,MAAAA,IAC/BrC,EAAAA,KACH4C,EAAeE,YAAY9C,EAAAA,GAAAA,EAE5BA,EAAA+B,IAAAC,IAAAA,GACAhC,EAAA+B,IAAAU,IAA8BG,IAK1B5C,CACP,CAGe+C,SAAAA,IAAAA,CAEftE,KAA+BuE,IAAA,EAC/BvE,KAAKwE,EAAc,KACnBxE,KAA2BsB,IAAA,IAC3B,CAqIM,SAASmD,GAAUlD,EAAAA,CAEzB,IAAI6B,EAAY7B,EAAH8B,GAAAC,IACb,OAAOF,GAAaA,EAAJsB,KAA4BtB,EAAAA,IAAqB7B,CAAAA,CACjE,CAAA,SAEeoD,GAAKC,EAAAA,CACpB,IAAIC,EACAzB,EACAL,EAEJ,SAAS+B,EAAKtF,EAAAA,CAab,GAZKqF,IACJA,EAAOD,EAAAA,GACFzB,KACJ,SAAA4B,EAAAA,CACC3B,EAAY2B,EAAQC,SAAWD,CAC/B,EACD,SAAAE,EAAAA,CACClC,EAAQkC,CACR,CAAA,EAIClC,EACH,MAAMA,EAGP,GAAA,CAAKK,EACJ,MAAMyB,EAGP,OAAOjE,GAAcwC,EAAW5D,CAAAA,CAChC,CAID,OAFAsF,EAAKjE,YAAc,OACnBiE,EAAIrD,IAAAA,GACGqD,CACP,CCvQeI,SAAAA,IAAAA,CACflF,KAAKmF,EAAQ,KACbnF,KAAKoF,EAAO,IACZ,CDcD/D,EAAQqC,QAAU,SAAUnC,EAAAA,CAE3B,IAAM6B,EAAY7B,EAAlB+B,IACIF,GAAaA,EAAJiC,KACZjC,EAASiC,IAAAA,EAONjC,GEpCuB,GFoCV7B,EAAKgD,MACrBhD,EAAMC,KAAO,MAGViC,IAAYA,GAAWlC,CAAAA,CAC3B,GAgED+C,GAASvD,UAAY,IAAIE,IAOaqC,IAAA,SAAUgC,EAASC,EAAAA,CACxD,IAAMC,EAAsBD,EAA5BjC,IAGMvD,EAAIC,KAEND,EAAEyE,GAAe,OACpBzE,EAAEyE,EAAc,CAAA,GAEjBzE,EAAEyE,EAAYiB,KAAKD,CAAAA,EAEnB,IAAME,EAAUjB,GAAU1E,EAADqE,GAAAA,EAErBuB,EAAAA,GACEC,EAAa,UAAA,CACdD,IAEJA,EAAAA,GACAH,EAAAH,IAAiC,KAE7BK,EACHA,EAAQG,CAAAA,EAERA,EAAAA,EAED,EAEDL,EAAmBH,IAAcO,EAEjC,IAAMC,EAAuB,UAAA,CAC5B,GAAA,CAAA,EAAO9F,EAAFwE,IAA6B,CAGjC,GAAIxE,EAAEoB,MAANuD,IAAwB,CACvB,IAAMoB,EAAiB/F,EAAEoB,MAALuD,IACpB3E,EAAAA,IAAmByD,IAAA,CAAA,EAAKU,GACvB4B,EACAA,EAFqCxC,IAAAU,IAGrC8B,EAHqCxC,IAAAyC,GAAAA,CAKtC,CAID,IAAItB,EACJ,IAHA1E,EAAEiG,SAAS,CAAEtB,IAAa3E,EAAAA,IAAwB,IAAA,CAAA,EAG1C0E,EAAY1E,EAAEyE,EAAYyB,IAAAA,GACjCxB,EAAUyB,YAAAA,CAEX,CACD,EAQCnG,EAAAwE,OEzKyB,GF0KxBgB,EAAAhB,KAEFxE,EAAEiG,SAAS,CAAEtB,IAAa3E,EAAAA,IAAwBA,EAAAA,IAAmByD,IAAA,CAAA,CAAA,CAAA,EAEtE8B,EAAQnC,KAAKyC,EAAYA,CAAAA,CACzB,EAEDtB,GAASvD,UAAUoF,qBAAuB,UAAA,CACzCnG,KAAKwE,EAAc,CAAA,CACnB,EAODF,GAASvD,UAAUmB,OAAS,SAAU1C,EAAO2B,EAAAA,CAC5C,GAAInB,KAAAA,IAA0B,CAI7B,GAAIA,KAAJoE,IAAAZ,IAA2B,CAC1B,IAAMI,EAAiBwC,SAASxF,cAAc,KAAA,EACxCyF,EAAoBrG,KAAsBoE,IAAAZ,IAAA,CAAA,EAAzBF,IACvBtD,KAAAoE,IAAAZ,IAAsB,CAAA,EAAKG,GAC1B3D,KACA4D,IAAAA,EACCyC,EAAiBN,IAAsBM,EAHDrC,GAAAA,CAKxC,CAEDhE,KAA2BsB,IAAA,IAC3B,CAID,IAAMgF,EACLnF,EAAKuD,KAAe9D,GAAc2F,GAAU,KAAM/G,EAAM8G,QAAAA,EAGzD,OAFIA,IAAUA,EAAQ/B,KAAAA,KAEf,CACN3D,GAAc2F,GAAU,KAAMpF,EAAKuD,IAAc,KAAOlF,EAAM4C,QAAAA,EAC9DkE,CAAAA,CAED,ECrMD,IAAMZ,GAAU,SAACc,EAAMvC,EAAOwC,EAAAA,CAc7B,GAAA,EAbMA,EAdgB,CAAA,IAcSA,EAfR,CAAA,GAqBtBD,EAAKpB,EAAKsB,OAAOzC,CAAAA,EAQhBuC,EAAKhH,MAAMmH,cACXH,EAAKhH,MAAMmH,YAAY,CAAA,IAAO,KAAP,CAAcH,EAAKpB,EAAKwB,MASjD,IADAH,EAAOD,EAAKrB,EACLsB,GAAM,CACZ,KAAOA,EAAK/D,OAAS,GACpB+D,EAAKR,IAAAA,EAALQ,EAED,GAAIA,EA1CiB,CAAA,EA0CMA,EA3CL,CAAA,EA4CrB,MAEDD,EAAKrB,EAAQsB,EAAOA,EA5CJ,CAAA,CA6ChB,CACD,EE/CD,SAASI,GAAgBrH,EAAAA,CAExB,OADAQ,KAAK8G,gBAAkB,UAAA,CAAMtH,OAAAA,EAAMS,OAAZ,EAChBT,EAAM4C,QACb,CASD,SAAS2E,GAAOvH,EAAAA,CACf,IAAMwH,EAAQhH,KACViH,EAAYzH,EAAM0H,EAEtBF,EAAMb,qBAAuB,UAAA,CAC5BjE,GAAO,KAAM8E,EAAMG,CAAAA,EACnBH,EAAMG,EAAQ,KACdH,EAAME,EAAa,IACnB,EAIGF,EAAME,GAAcF,EAAME,IAAeD,GAC5CD,EAAMb,qBAAAA,EAGFa,EAAMG,IACVH,EAAME,EAAaD,EAGnBD,EAAMG,EAAQ,CACbC,SAAU,EACVC,WAAYJ,EACZK,WAAY,CAAA,EACZC,SAAU,UAAA,CAAA,MAAA,EAAA,EACVlD,YALa,SAKDJ,EAAAA,CACXjE,KAAKsH,WAAW7B,KAAKxB,CAAAA,EACrB+C,EAAME,EAAW7C,YAAYJ,CAAAA,CAC7B,EACDuD,aAAavD,SAAAA,EAAOwD,EAAAA,CACnBzH,KAAKsH,WAAW7B,KAAKxB,CAAAA,EACrB+C,EAAME,EAAW7C,YAAYJ,CAAAA,CAC7B,EACDyD,YAba,SAaDzD,EAAAA,CACXjE,KAAKsH,WAAWK,OAAO3H,KAAKsH,WAAWM,QAAQ3D,CAAAA,IAAW,EAAG,CAAA,EAC7D+C,EAAME,EAAWQ,YAAYzD,CAAAA,CAC7B,CAAA,GAKH/B,GACCtB,GAAciG,GAAiB,CAAE5G,QAAS+G,EAAM/G,OAAAA,EAAWT,EADtD4E,GAAAA,EAEL4C,EAAMG,CAAAA,CAEP,CAAA,SAOeU,GAAatG,EAAO0F,EAAAA,CACnC,IAAMa,EAAKlH,GAAcmG,GAAQ,CAAE3C,IAAQ7C,EAAO2F,EAAYD,CAAAA,CAAAA,EAE9D,OADAa,EAAGC,cAAgBd,EACZa,CACP,EFhBD5C,GAAanE,UAAY,IAAIE,IAEOyD,IAAA,SAAUT,EAAAA,CAC7C,IAAMuC,EAAOxG,KACPgI,EAAYvD,GAAU+B,EAA5BpC,GAAAA,EAEIqC,EAAOD,EAAKpB,EAAK6C,IAAIhE,CAAAA,EAGzB,OAFAwC,EA5DuB,CAAA,IAAA,SA8DhByB,EAAAA,CACN,IAAMC,EAAmB,UAAA,CACnB3B,EAAKhH,MAAMmH,aAKfF,EAAKhB,KAAKyC,CAAAA,EACVxC,GAAQc,EAAMvC,EAAOwC,CAAAA,GAHrByB,EAAAA,CAKD,EACGF,EACHA,EAAUG,CAAAA,EAEVA,EAAAA,CAED,CACD,EAEDjD,GAAanE,UAAUmB,OAAS,SAAU1C,EAAAA,CACzCQ,KAAKmF,EAAQ,KACbnF,KAAKoF,EAAO,IAAIgD,IAEhB,IAAMhG,EAAWC,GAAa7C,EAAM4C,QAAAA,EAChC5C,EAAMmH,aAAenH,EAAMmH,YAAY,CAAA,IAAO,KAIjDvE,EAASiG,QAAAA,EAIV,QAAS5I,EAAI2C,EAASM,OAAQjD,KAY7BO,KAAKoF,EAAKkD,IAAIlG,EAAS3C,CAAAA,EAAKO,KAAKmF,EAAQ,CAAC,EAAG,EAAGnF,KAAKmF,CAAAA,CAAAA,EAEtD,OAAO3F,EAAM4C,QACb,EAED8C,GAAanE,UAAUwH,mBACtBrD,GAAanE,UAAUyH,kBAAoB,UAAA,CAAY,IAAAxB,EAAAhH,KAOtDA,KAAKoF,EAAK5C,QAAQ,SAACiE,EAAMxC,EAAAA,CACxByB,GAAQsB,EAAM/C,EAAOwC,CAAAA,CACrB,CAAA,CACD,EGnGK,IAAMgC,GACM,OAAV9G,OAAU,KAAeA,OAAOC,KAAOD,OAAOC,IAAI,eAAA,GAC1D,MAEK8G,GACL,8RACKC,GAAS,mCACTC,GAAgB,YAEhBC,GAA6B,OAAbzC,SAAa,IAK7B0C,GAAoB,SAAAtH,EAAAA,CACzB,OAAkB,OAAVG,OAAU,KAAkC,OAAZA,OAAAA,GAAY,SACjD,cACA,cACDoH,KAAKvH,CAAAA,CAJsB,EA2CdU,SAAAA,GAAOX,EAAOyH,EAAQC,EAAAA,CAUrC,OAPID,EAAMxF,KAAc,OACvBwF,EAAOE,YAAc,IAGtBC,GAAa5H,EAAOyH,CAAAA,EACG,OAAZC,GAAY,YAAYA,EAAAA,EAE5B1H,EAAQA,EAAmB+B,IAAA,IAClC,CAEM,SAAS8F,GAAQ7H,EAAOyH,EAAQC,EAAAA,CAItC,OAHAI,GAAc9H,EAAOyH,CAAAA,EACE,OAAZC,GAAY,YAAYA,EAAAA,EAE5B1H,EAAQA,EAAH+B,IAAsB,IAClC,CAtDDrC,GAAUF,UAAUC,iBAAmB,CAAA,EASvC,CACC,qBACA,4BACA,qBAAA,EACCwB,QAAQ,SAAA8G,EAAAA,CACTC,OAAOC,eAAevI,GAAUF,UAAWuI,EAAK,CAC/CG,aAAAA,GACAxB,IAAM,UAAA,CACL,OAAOjI,KAAK,UAAYsJ,CAAAA,CACxB,EACDhB,IAL+C,SAK3CoB,EAAAA,CACHH,OAAOC,eAAexJ,KAAMsJ,EAAK,CAChCG,aAAAA,GACAE,SAAAA,GACAC,MAAOF,CAAAA,CAAAA,CAER,CAAA,CAAA,CAEF,CAAA,EA6BD,IAAIG,GAAexI,EAAQyI,MAU3B,SAASC,IAAAA,CAET,CAAA,SAASC,IAAAA,CACR,OAAOhK,KAAKiK,YACZ,CAED,SAASC,IAAAA,CACR,OAAOlK,KAAKmK,gBACZ,CAjBD9I,EAAQyI,MAAQ,SAAA7E,EAAAA,CAMf,OALI4E,KAAc5E,EAAI4E,GAAa5E,CAAAA,GAEnCA,EAAEmF,QAAUL,GACZ9E,EAAE+E,qBAAuBA,GACzB/E,EAAEiF,mBAAqBA,GACfjF,EAAEoF,YAAcpF,CACxB,EAYD,IAiIIqF,GAjIEC,GAAoC,CACzCC,WAAAA,GACAf,aAAAA,GACAxB,IAAM,UAAA,CACL,OAAOjI,KAAKyK,KACZ,CAAA,EA+GEC,GAAerJ,EAAQE,MAC3BF,EAAQE,MAAQ,SAAAA,EAAAA,CAEW,OAAfA,EAAMC,MAAS,UA/G3B,SAAwBD,EAAAA,CACvB,IAAI/B,EAAQ+B,EAAM/B,MACjBgC,EAAOD,EAAMC,KACbmJ,EAAkB,CAFnB,EAIA,QAASlL,KAAKD,EAAO,CACpB,IAAIoK,EAAQpK,EAAMC,CAAAA,EAElB,GAAA,EACEA,IAAM,SAAW,iBAAkBD,GAASoK,GAAS,MAErDf,IAAUpJ,IAAM,YAAc+B,IAAS,YACxC/B,IAAM,SACNA,IAAM,aALP,CAYA,IAAImL,EAAanL,EAAEoL,YAAAA,EACfpL,IAAM,gBAAkB,UAAWD,GAASA,EAAMoK,OAAS,KAG9DnK,EAAI,QACMA,IAAM,YAAcmK,IAApBnK,GAMVmK,EAAQ,GACEgB,IAAe,aAAehB,IAAU,KAClDA,EAAAA,GACUgB,IAAe,gBACzBnL,EAAI,aAEJmL,IAAe,YACdpJ,IAAS,SAAWA,IAAS,YAC7BsH,GAAkBtJ,EAAMgC,IAAAA,EAGfoJ,IAAe,UACzBnL,EAAI,YACMmL,IAAe,SACzBnL,EAAI,aACMkJ,GAAOI,KAAKtJ,CAAAA,EACtBA,EAAImL,EACMpJ,EAAKoG,QAAQ,GAAA,IADnBgD,IACkClC,GAAYK,KAAKtJ,CAAAA,EACvDA,EAAIA,EAAEqL,QAAQlC,GAAe,KAAA,EAAOiC,YAAAA,EAC1BjB,IAAU,OACpBA,EAAAA,QAVAgB,EAAanL,EAAI,UAedmL,IAAe,WAEdD,EADJlL,EAAImL,CAAAA,IAEHnL,EAAI,kBAINkL,EAAgBlL,CAAAA,EAAKmK,CA7CpB,CA8CD,CAIApI,GAAQ,UACRmJ,EAAgBI,UAChBC,MAAMC,QAAQN,EAAgBf,KAAAA,IAG9Be,EAAgBf,MAAQvH,GAAa7C,EAAM4C,QAAAA,EAAUI,QAAQ,SAAAyB,EAAAA,CAC5DA,EAAMzE,MAAM0L,SACXP,EAAgBf,MAAMhC,QAAQ3D,EAAMzE,MAAMoK,KAAAA,GAD/BsB,EAEZ,CAAA,GAIE1J,GAAQ,UAAYmJ,EAAgBQ,cAAgB,OACvDR,EAAgBf,MAAQvH,GAAa7C,EAAM4C,QAAAA,EAAUI,QAAQ,SAAAyB,EAAAA,CAE3DA,EAAMzE,MAAM0L,SADTP,EAAgBI,SAElBJ,EAAgBQ,aAAavD,QAAQ3D,EAAMzE,MAAMoK,KAAAA,GAF/BmB,GAKlBJ,EAAgBQ,cAAgBlH,EAAMzE,MAAMoK,KAE9C,CAAA,GAGEpK,EAAMiL,OAAAA,CAAUjL,EAAM4L,WACzBT,EAAgBF,MAAQjL,EAAMiL,MAC9BlB,OAAOC,eACNmB,EACA,YACAJ,EAAAA,IAES/K,EAAM4L,WAAAA,CAAc5L,EAAMiL,OAE1BjL,EAAMiL,OAASjL,EAAM4L,aAD/BT,EAAgBF,MAAQE,EAAgBS,UAAY5L,EAAM4L,WAK3D7J,EAAM/B,MAAQmL,CACd,EAMgBpJ,CAAAA,EAGhBA,EAAMU,SAAWwG,GAEbiC,IAAcA,GAAanJ,CAAAA,CAC/B,EAID,IAAM8J,GAAkBhK,EAAxBiK,IACAjK,EAAOiK,IAAW,SAAU/J,EAAAA,CACvB8J,IACHA,GAAgB9J,CAAAA,EAEjB+I,GAAmB/I,EAAH+B,GAChB,EAED,IAAMiI,GAAYlK,EAAQmK,OAE1BnK,EAAQmK,OAAS,SAAUjK,EAAAA,CACtBgK,IACHA,GAAUhK,CAAAA,EAGX,IAAM/B,EAAQ+B,EAAM/B,MACdiM,EAAMlK,EAAZgC,IAGCkI,GAAO,MACPlK,EAAMC,OAAS,YACf,UAAWhC,GACXA,EAAMoK,QAAU6B,EAAI7B,QAEpB6B,EAAI7B,MAAQpK,EAAMoK,OAAS,KAAO,GAAKpK,EAAMoK,OAG9CU,GAAmB,IACnB,EAIYoB,IAAAA,GAAqD,CACjEC,uBAAwB,CACvBlL,QAAS,CACRmL,YADQ,SACI3L,EAAAA,CACX,OAAOqK,GAAgBuB,IAAgB5L,EAAaT,GAAAA,EAAAA,MAAMoK,KAC1D,EACDkC,YAAAA,EACAC,WAAAA,GACAC,cAAAA,GACAC,iBAAAA,GACAC,UAAAA,EACAC,MAAAA,GACAC,oBAAAA,GACAC,mBAAAA,GACAC,gBAAAA,GACAC,QAAAA,GAEAC,WAAAA,GACAC,OAAAA,EACAC,SAAAA,EACAC,qBAAAA,GACAC,cAAAA,EAAAA,CAAAA,CAAAA,ECxQH,SAASC,GAAcC,EAAAA,CACtB,OAAOC,GAAcC,KAAK,KAAMF,CAAAA,CAChC,CAOD,SAASG,GAAeC,EAAAA,CACvB,MAAA,CAAA,CAASA,GAAWA,EAAQC,WAAaC,EACzC,CAOD,SAASC,GAAWH,EAAAA,CACnB,OAAOD,GAAeC,CAAAA,GAAYA,EAAQJ,OAASQ,EACnD,CAOD,SAASC,GAAOL,EAAAA,CACf,MAAA,CAAA,CACGA,GAAAA,CAAAA,CACAA,EAAQM,cACsB,OAAxBN,EAAQM,aAAgB,UAC/BN,EAAQM,uBAAuBC,SAChCP,EAAQM,YAAYE,WAAW,OAAA,CAEhC,CASD,SAASC,GAAaT,EAAAA,CACrB,OAAKD,GAAeC,CAAAA,EACbU,GAAmBC,MAAM,KAAMC,SAAAA,EADDZ,CAErC,CAOD,SAASa,GAAuBC,EAAAA,CAC/B,MAAA,CAAA,CAAIA,EAAqBC,MACxBC,GAAa,KAAMF,CAAAA,EAAAA,GAIpB,CAOD,SAASG,GAAYC,EAAAA,CACpB,OACEA,IACCA,EAAUC,MAASD,EAAUE,WAAa,GAAKF,IACjD,IAED,CAUKG,IAAAA,GAA0B,SAACC,EAAUC,EAAAA,CAAQD,OAAAA,EAASC,CAAAA,CAA5B,EAW1BC,GAAY,SAACF,EAAUC,EAAAA,CAAAA,OAAQD,EAASC,CAAAA,CAA5B,EAMZE,GAAarB,GAEZ,SAASsB,GAAgBC,EAAAA,CAC/BA,EAAAA,CACA,CAEeC,SAAAA,GAAiBC,EAAAA,CAChC,OAAOA,CACP,CAAA,SAEeC,IAAAA,CACf,MAAO,CAAA,GAAQJ,EAAAA,CACf,CAIYK,IAAAA,GAAqBC,GAGrBC,GAAYlC,GAOlB,SAASmC,GAAqBC,EAAWC,EAAAA,CAC/C,IAAMC,EAAQD,EAAAA,EAMuBE,EAAAA,EAAS,CAC7CC,EAAW,CAAEC,GAAQH,EAAOI,EAAcL,CAAAA,CAAAA,CAAAA,EADlCG,EAATG,EAAA,CAAA,EAASH,EAAaI,EAAAA,EAAAA,CAAAA,EAyBtB,OArBAX,GAAgB,UAAA,CACfO,EAASC,GAAUH,EACnBE,EAAUE,EAAeL,EAErBQ,GAAkBL,CAAAA,GACrBI,EAAY,CAAEJ,EAAAA,CAAAA,CAAAA,CAEf,EAAE,CAACJ,EAAWE,EAAOD,CAAAA,CAAAA,EAEtBS,EAAU,UAAA,CAKT,OAJID,GAAkBL,CAAAA,GACrBI,EAAY,CAAEJ,EAAAA,CAAAA,CAAAA,EAGRJ,EAAU,UAAA,CACZS,GAAkBL,CAAAA,GACrBI,EAAY,CAAEJ,EAAAA,CAAAA,CAAAA,CAEf,CAAA,CACD,EAAE,CAACJ,CAAAA,CAAAA,EAEGE,CACP,CAGD,SAASO,GAAkBE,EAAAA,CAC1B,IVhLkBC,EAAGC,EUgLfC,EAAoBH,EAAKL,EACzBS,EAAYJ,EAAHN,GACf,GAAA,CACC,IAAMW,EAAYF,EAAAA,EAClB,MAAA,GVpLiBF,EUoLNG,MVpLSF,EUoLEG,KVnLHJ,IAAM,GAAK,EAAIA,GAAM,EAAIC,IAAQD,GAAMA,GAAKC,GAAMA,EUsLrE,MAFQI,CACR,MAAA,EACA,CACD,CAmCD,IAAeC,EAAA,CACdf,SAAAA,EACAgB,MAAAA,GACAC,WAAAA,GACAV,UAAAA,EACAb,gBAAAA,GACAD,mBAAAA,GACAD,cAAAA,GACAF,iBAAAA,GACAM,qBAAAA,GACAR,gBAAAA,GACA8B,OAAAA,EACAC,oBAAAA,GACAC,QAAAA,GACAC,YAAAA,EACAC,WAAAA,GACAC,cAAAA,GACAC,QArOe,SAsOfC,SAAAA,GACAC,OAAAA,GACAC,QAAAA,GACApD,uBAAAA,GACAqD,aAAAA,GACArE,cAAAA,GACAsE,cAAAA,GACAxE,cAAAA,GACAc,aAAAA,GACA2D,UAAAA,GACAhE,SAAAA,GACAL,eAAAA,GACAkC,UAAAA,GACA9B,WAAAA,GACAE,OAAAA,GACAY,YAAAA,GACAoD,UAAAA,GACAC,cAAAA,GACAC,KAAAA,GACAC,WAAAA,GACAhD,UAAAA,GACAH,wBAAAA,GACAI,WAAAA,GACAgD,SAAAA,GACAC,aAAAA,GACAC,KAAAA,GACAC,mDAAAA,EAAAA,EErNM,SAASC,GAAoBC,EAAqBC,EAAa,CACpE,OAAO,OAAOD,GAAY,WACrBA,EAA4BC,CAAK,EAClCD,CACN,CAMO,SAASE,GACdC,EACAC,EACA,CACA,OAAQC,GAAoC,CACxCD,EAAiBE,SAAuBC,IACjC,CACL,GAAGA,EACH,CAACJ,CAAG,EAAGK,GAAiBH,EAAUE,EAAYJ,CAAG,CAAC,GAErD,EAEL,CAIO,SAASM,GAAkCC,EAAgB,CAChE,OAAOA,aAAaC,QACtB,CAEO,SAASC,GAAcF,EAAuB,CACnD,OAAOG,MAAMC,QAAQJ,CAAC,GAAKA,EAAEK,MAAMC,GAAO,OAAOA,GAAQ,QAAQ,CACnE,CAEO,SAASC,GACdC,EACAC,EACA,CACA,IAAMC,EAAgB,CAAA,EAEhBC,EAAWC,GAAoB,CACnCA,EAAOC,QAAQC,GAAQ,CACrBJ,EAAKK,KAAKD,CAAI,EACd,IAAME,EAAWP,EAAYK,CAAI,EAC7BE,GAAQ,MAARA,EAAUC,QACZN,EAAQK,CAAQ,CAEpB,CAAC,GAGHL,OAAAA,EAAQH,CAAG,EAEJE,CACT,CAEO,SAASQ,EACdC,EACAC,EACAC,EAKiC,CACjC,IAAIC,EAAc,CAAA,EACdC,EAEJ,OAAOC,GAAW,CAChB,IAAIC,EACAJ,EAAK5B,KAAO4B,EAAKK,QAAOD,EAAUE,KAAKC,IAAG,GAE9C,IAAMC,EAAUV,EAAQK,CAAO,EAM/B,GAAI,EAHFK,EAAQZ,SAAWK,EAAKL,QACxBY,EAAQC,KAAK,CAACC,EAAUC,IAAkBV,EAAKU,CAAK,IAAMD,CAAG,GAG7D,OAAOR,EAGTD,EAAOO,EAEP,IAAII,EAMJ,GALIZ,EAAK5B,KAAO4B,EAAKK,QAAOO,EAAaN,KAAKC,IAAG,GAEjDL,EAASH,EAAG,GAAGS,CAAO,EACtBR,GAAI,MAAJA,EAAMa,UAAQ,MAAdb,EAAMa,SAAWX,CAAM,EAEnBF,EAAK5B,KAAO4B,EAAKK,OACfL,GAAAA,MAAAA,EAAMK,MAAK,EAAI,CACjB,IAAMS,EAAaC,KAAKC,OAAOV,KAAKC,IAAG,EAAKH,GAAY,GAAG,EAAI,IACzDa,EAAgBF,KAAKC,OAAOV,KAAKC,IAAG,EAAKK,GAAe,GAAG,EAAI,IAC/DM,EAAsBD,EAAgB,GAEtCE,EAAMA,CAACC,EAAsBC,IAAgB,CAEjD,IADAD,EAAME,OAAOF,CAAG,EACTA,EAAIxB,OAASyB,GAClBD,EAAM,IAAMA,EAEd,OAAOA,GAGTG,QAAQC,KACN,YAAOL,EAAIF,EAAe,CAAC,CAAC,KAAKE,EAAIL,EAAY,CAAC,CAAC,MACnD;;;yBAGeC,KAAKU,IAChB,EACAV,KAAKW,IAAI,IAAM,IAAMR,EAAqB,GAAG,CAC/C,CAAC,iBACHlB,GAAM5B,GACR,CACF,CAGF,OAAO8B,EAEX,CAEO,SAASyB,EACdC,EACAC,EAOAzD,EACAyC,EACA,CACA,MAAO,CACLR,MAAOA,IAAA,CAAA,IAAAyB,EAAA,OAAAA,EAAMF,GAAcG,WAAQ,KAAAD,EAAIF,EAAaC,CAAU,CAAC,EAC/DzD,IAAK4D,GACLnB,SAAAA,EAEJ,CCvKO,SAASoB,GACdC,EACAC,EACAC,EACAC,EACqB,CACrB,IAAMC,EAAiBA,IAAA,CAAA,IAAAC,EAAA,OAAAA,EACrBC,EAAKC,SAAQ,IAAEF,KAAAA,EAAIL,EAAMQ,QAAQC,mBAAmB,EAEhDH,EAAgC,CACpCI,GAAI,GAAGT,EAAIS,EAAE,IAAIR,EAAOQ,EAAE,GAC1BT,IAAAA,EACAC,OAAAA,EACAK,SAAUA,IAAMN,EAAIM,SAASJ,CAAQ,EACrCQ,YAAaP,EACbQ,WAAYjD,EACV,IAAM,CAACqC,EAAOE,EAAQD,EAAKK,CAAI,EAC/B,CAACN,EAAOE,EAAQD,EAAKK,KAAU,CAC7BN,MAAAA,EACAE,OAAAA,EACAD,IAAAA,EACAK,KAAMA,EACNC,SAAUD,EAAKC,SACfI,YAAaL,EAAKK,cAEpBlB,EAAeO,EAAMQ,QAAS,aAAc,iBAAiB,CAC/D,GAGFR,OAAAA,EAAMa,UAAUvD,QAAQwD,GAAW,CACjCA,EAAQf,YAARe,MAAAA,EAAQf,WACNO,EACAJ,EACAD,EACAD,CACF,GACC,CAAA,CAAE,EAEEM,CACT,CC1BO,SAASS,GACdf,EACAgB,EACAC,EACAC,EACuB,CAAA,IAAAC,EAAAC,EAGvB,IAAMC,EAAoB,CACxB,GAHoBrB,EAAMsB,qBAAoB,EAI9C,GAAGN,GAGCO,EAAcF,EAAkBE,YAElCb,GAAES,GAAAC,EACJC,EAAkBX,KAAE,KAAAU,EACnBG,EAAcA,EAAYC,QAAQ,IAAK,GAAG,EAAIC,SAASN,KAAAA,EACvD,OAAOE,EAAkBK,QAAW,SACjCL,EAAkBK,OAClBD,OAEFE,EA2BJ,GAzBIN,EAAkBM,WACpBA,EAAaN,EAAkBM,WACtBJ,IAELA,EAAYK,SAAS,GAAG,EAC1BD,EAAcE,GAAuB,CACnC,IAAI7D,EAAS6D,EAEb,QAAW3F,KAAOqF,EAAYO,MAAM,GAAG,EAAG,CAAA,IAAAC,EACxC/D,GAAM+D,EAAG/D,IAAM,KAAA,OAAN+D,EAAS7F,CAAG,CAMvB,CAEA,OAAO8B,GAGT2D,EAAcE,GACXA,EAAoBR,EAAkBE,WAAW,GAIpD,CAACb,EAQH,MAAM,IAAIsB,MAGZ,IAAI9B,EAAiC,CACnCQ,GAAI,GAAGtB,OAAOsB,CAAE,CAAC,GACjBiB,WAAAA,EACAT,OAAQA,EACRD,MAAAA,EACAD,UAAWK,EACXY,QAAS,CAAA,EACTC,eAAgBvE,EACd,IAAM,CAAC,EAAI,EACX,IAAM,CAAA,IAAAwE,EACJ,MAAO,CACLjC,EACA,IAAAiC,EAAGjC,EAAO+B,UAAPE,KAAAA,OAAAA,EAAgBC,QAAQ3F,GAAKA,EAAEyF,eAAc,CAAE,CAAC,GAGvDzC,EAAeO,EAAMQ,QAAS,eAAgB,uBAAuB,CACvE,EACA6B,eAAgB1E,EACd,IAAM,CAACqC,EAAMsC,mBAAkB,CAAE,EACjCC,GAAgB,CAAA,IAAAC,EACd,IAAAA,EAAItC,EAAO+B,UAAPO,MAAAA,EAAgB9E,OAAQ,CAC1B,IAAI+E,EAAcvC,EAAO+B,QAAQG,QAAQlC,GACvCA,EAAOmC,eAAc,CACvB,EAEA,OAAOE,EAAaE,CAAW,CACjC,CAEA,MAAO,CAACvC,CAAM,GAEhBT,EAAeO,EAAMQ,QAAS,eAAgB,uBAAuB,CACvE,GAGF,QAAWM,KAAWd,EAAMa,UAC1BC,EAAQC,cAAY,MAApBD,EAAQC,aAAeb,EAAiCF,CAAK,EAI/D,OAAOE,CACT,CC1JA,IAAM/B,EAAQ,eA0Md,SAASuE,GACP1C,EACAE,EACAM,EAOuB,CAAA,IAAAmC,EAGvB,IAAIjB,EAAoC,CACtChB,IAHMiC,EAAGnC,EAAQE,KAAE,KAAAiC,EAAIzC,EAAOQ,GAI9BR,OAAAA,EACAzB,MAAO+B,EAAQ/B,MACfmE,cAAe,CAAC,CAACpC,EAAQoC,cACzBC,cAAerC,EAAQqC,cACvB5B,MAAOT,EAAQS,MACf6B,WAAY,CAAA,EACZC,QAAS,EACTC,QAAS,EACTC,YAAa,KACbC,eAAgBA,IAAgC,CAC9C,IAAMC,EAAwC,CAAA,EAExCC,EAAiBC,GAA8B,CAC/CA,EAAEP,YAAcO,EAAEP,WAAWpF,QAC/B2F,EAAEP,WAAWQ,IAAIF,CAAa,EAEhCD,EAAY3F,KAAK6F,CAA2B,GAG9CD,OAAAA,EAAc1B,CAAM,EAEbyB,GAETvC,WAAYA,KAAO,CACjBZ,MAAAA,EACA0B,OAAQA,EACRxB,OAAAA,KAIJF,OAAAA,EAAMa,UAAUvD,QAAQwD,GAAW,CACjCA,EAAQ4B,cAAY,MAApB5B,EAAQ4B,aAAehB,EAAiC1B,CAAK,CAC/D,CAAC,EAEM0B,CACT,CAEO,IAAM6B,GAAwB,CACnCC,YAAqCxD,GAA8B,CAGjEA,EAAMyD,gBAAkB9F,EACtB,IAAM,CACJqC,EAAM0D,cAAa,EACnB1D,EAAM2D,sBAAqB,EAC3B3D,EAAM4D,SAAQ,EAAGC,cAAcC,KAC/B9D,EAAM4D,SAAQ,EAAGC,cAAcE,KAAK,EAEtC,CAACC,EAAYvB,EAAaqB,EAAMC,IAAU,CAAA,IAAAE,EAAAC,EACxC,IAAMC,GAAWF,EACfH,GACIR,IAAInD,GAAYsC,EAAY2B,KAAK3H,GAAKA,EAAEiE,KAAOP,CAAQ,CAAE,EAC1DkE,OAAOC,OAAO,IAACL,KAAAA,EAAI,CAAA,EAElBM,GAAYL,EAChBH,GACIT,IAAInD,GAAYsC,EAAY2B,KAAK3H,GAAKA,EAAEiE,KAAOP,CAAQ,CAAE,EAC1DkE,OAAOC,OAAO,IAACJ,KAAAA,EAAI,CAAA,EAElBM,EAAgB/B,EAAY4B,OAChCnE,GAAU,EAAC4D,GAAI,MAAJA,EAAMlC,SAAS1B,EAAOQ,EAAE,IAAK,EAACqD,GAAK,MAALA,EAAOnC,SAAS1B,EAAOQ,EAAE,EACpE,EAQA,OANqB+D,GACnBT,EACA,CAAC,GAAGG,EAAa,GAAGK,EAAe,GAAGD,CAAY,EAClDvE,CACF,GAIFP,EAAeO,EAAMQ,QAASrC,EAAO,iBAAiB,CACxD,EAEA6B,EAAM0E,sBAAwB/G,EAC5B,IAAM,CACJqC,EAAM0D,cAAa,EACnB1D,EAAM2D,sBAAqB,EAC3B3D,EAAM4D,SAAQ,EAAGC,cAAcC,KAC/B9D,EAAM4D,SAAQ,EAAGC,cAAcE,KAAK,EAEtC,CAACC,EAAYvB,EAAaqB,EAAMC,KAC9BtB,EAAcA,EAAY4B,OACxBnE,GAAU,EAAC4D,GAAI,MAAJA,EAAMlC,SAAS1B,EAAOQ,EAAE,IAAK,EAACqD,GAAK,MAALA,EAAOnC,SAAS1B,EAAOQ,EAAE,EACpE,EACO+D,GAAkBT,EAAYvB,EAAazC,EAAO,QAAQ,GAEnEP,EAAeO,EAAMQ,QAASrC,EAAO,uBAAuB,CAC9D,EAEA6B,EAAM2E,oBAAsBhH,EAC1B,IAAM,CACJqC,EAAM0D,cAAa,EACnB1D,EAAM2D,sBAAqB,EAC3B3D,EAAM4D,SAAQ,EAAGC,cAAcC,IAAI,EAErC,CAACE,EAAYvB,EAAaqB,IAAS,CAAA,IAAAc,EACjC,IAAMC,GAAkBD,EACtBd,GACIR,IAAInD,GAAYsC,EAAY2B,KAAK3H,GAAKA,EAAEiE,KAAOP,CAAQ,CAAE,EAC1DkE,OAAOC,OAAO,IAACM,KAAAA,EAAI,CAAA,EAExB,OAAOH,GAAkBT,EAAYa,EAAoB7E,EAAO,MAAM,GAExEP,EAAeO,EAAMQ,QAASrC,EAAO,qBAAqB,CAC5D,EAEA6B,EAAM8E,qBAAuBnH,EAC3B,IAAM,CACJqC,EAAM0D,cAAa,EACnB1D,EAAM2D,sBAAqB,EAC3B3D,EAAM4D,SAAQ,EAAGC,cAAcE,KAAK,EAEtC,CAACC,EAAYvB,EAAasB,IAAU,CAAA,IAAAgB,EAClC,IAAMF,GAAkBE,EACtBhB,GACIT,IAAInD,GAAYsC,EAAY2B,KAAK3H,GAAKA,EAAEiE,KAAOP,CAAQ,CAAE,EAC1DkE,OAAOC,OAAO,IAACS,KAAAA,EAAI,CAAA,EAExB,OAAON,GAAkBT,EAAYa,EAAoB7E,EAAO,OAAO,GAEzEP,EAAeO,EAAMQ,QAASrC,EAAO,sBAAsB,CAC7D,EAIA6B,EAAMgF,gBAAkBrH,EACtB,IAAM,CAACqC,EAAMyD,gBAAe,CAAE,EAC9BwB,GACS,CAAC,GAAGA,CAAY,EAAEC,QAAO,EAElCzF,EAAeO,EAAMQ,QAASrC,EAAO,iBAAiB,CACxD,EAEA6B,EAAMmF,oBAAsBxH,EAC1B,IAAM,CAACqC,EAAM2E,oBAAmB,CAAE,EAClCM,GACS,CAAC,GAAGA,CAAY,EAAEC,QAAO,EAElCzF,EAAeO,EAAMQ,QAASrC,EAAO,qBAAqB,CAC5D,EAEA6B,EAAMoF,sBAAwBzH,EAC5B,IAAM,CAACqC,EAAM0E,sBAAqB,CAAE,EACpCO,GACS,CAAC,GAAGA,CAAY,EAAEC,QAAO,EAElCzF,EAAeO,EAAMQ,QAASrC,EAAO,uBAAuB,CAC9D,EAEA6B,EAAMqF,qBAAuB1H,EAC3B,IAAM,CAACqC,EAAM8E,qBAAoB,CAAE,EACnCG,GACS,CAAC,GAAGA,CAAY,EAAEC,QAAO,EAElCzF,EAAeO,EAAMQ,QAASrC,EAAO,sBAAsB,CAC7D,EAIA6B,EAAMsF,eAAiB3H,EACrB,IAAM,CAACqC,EAAMyD,gBAAe,CAAE,EAC9BwB,GACSA,EACJ3B,IAAIL,GACIA,EAAYsC,OACpB,EACApI,KAAI,EAETsC,EAAeO,EAAMQ,QAASrC,EAAO,gBAAgB,CACvD,EAEA6B,EAAMwF,mBAAqB7H,EACzB,IAAM,CAACqC,EAAM2E,oBAAmB,CAAE,EAClCb,GACSA,EACJR,IAAIL,GACIA,EAAYsC,OACpB,EACApI,KAAI,EAETsC,EAAeO,EAAMQ,QAASrC,EAAO,oBAAoB,CAC3D,EAEA6B,EAAMyF,qBAAuB9H,EAC3B,IAAM,CAACqC,EAAM0E,sBAAqB,CAAE,EACpCZ,GACSA,EACJR,IAAIL,GACIA,EAAYsC,OACpB,EACApI,KAAI,EAETsC,EAAeO,EAAMQ,QAASrC,EAAO,sBAAsB,CAC7D,EAEA6B,EAAM0F,oBAAsB/H,EAC1B,IAAM,CAACqC,EAAM8E,qBAAoB,CAAE,EACnChB,GACSA,EACJR,IAAIL,GACIA,EAAYsC,OACpB,EACApI,KAAI,EAETsC,EAAeO,EAAMQ,QAASrC,EAAO,qBAAqB,CAC5D,EAIA6B,EAAM2F,qBAAuBhI,EAC3B,IAAM,CAACqC,EAAMyF,qBAAoB,CAAE,EACnCG,GACSA,EAAYvB,OAAO3C,GAAM,CAAA,IAAAmE,EAAA,MAAI,GAAAA,EAACnE,EAAOoB,aAAU,MAAjB+C,EAAmBnI,QAAO,EAEjE+B,EAAeO,EAAMQ,QAASrC,EAAO,sBAAsB,CAC7D,EAEA6B,EAAM8F,mBAAqBnI,EACzB,IAAM,CAACqC,EAAMwF,mBAAkB,CAAE,EACjCI,GACSA,EAAYvB,OAAO3C,GAAM,CAAA,IAAAqE,EAAA,MAAI,GAAAA,EAACrE,EAAOoB,aAAU,MAAjBiD,EAAmBrI,QAAO,EAEjE+B,EAAeO,EAAMQ,QAASrC,EAAO,oBAAoB,CAC3D,EAEA6B,EAAMgG,oBAAsBrI,EAC1B,IAAM,CAACqC,EAAM0F,oBAAmB,CAAE,EAClCE,GACSA,EAAYvB,OAAO3C,GAAM,CAAA,IAAAuE,EAAA,MAAI,GAAAA,EAACvE,EAAOoB,aAAU,MAAjBmD,EAAmBvI,QAAO,EAEjE+B,EAAeO,EAAMQ,QAASrC,EAAO,qBAAqB,CAC5D,EAEA6B,EAAMkD,eAAiBvF,EACrB,IAAM,CACJqC,EAAM2E,oBAAmB,EACzB3E,EAAM0E,sBAAqB,EAC3B1E,EAAM8E,qBAAoB,CAAE,EAE9B,CAAChB,EAAMoC,EAAQnC,IAAU,CAAA,IAAAoC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EACvB,MAAO,CACL,IAAAL,GAAAC,EAAItC,EAAK,CAAC,IAANsC,KAAAA,OAAAA,EAASb,UAAOY,KAAAA,EAAI,CAAA,EACxB,IAAAE,GAAAC,EAAIJ,EAAO,CAAC,IAARI,KAAAA,OAAAA,EAAWf,UAAOc,KAAAA,EAAI,CAAA,EAC1B,IAAAE,GAAAC,EAAIzC,EAAM,CAAC,IAAC,KAAA,OAARyC,EAAUjB,UAAO,KAAAgB,EAAI,CAAA,CAAE,EAE1BjD,IAAI5B,GACIA,EAAOwB,eAAc,CAC7B,EACA/F,KAAI,GAETsC,EAAeO,EAAMQ,QAASrC,EAAO,gBAAgB,CACvD,CACF,CACF,EAEO,SAASsG,GACdT,EACAyC,EACAzG,EACA0G,EACA,CAAA,IAAAC,EAAAC,EAOA,IAAIC,EAAW,EAETC,EAAe,SAAC7E,EAAmChB,EAAc,CAAdA,IAAK,SAALA,EAAQ,GAC/D4F,EAAWhI,KAAKU,IAAIsH,EAAU5F,CAAK,EAEnCgB,EACGoC,OAAOnE,GAAUA,EAAO6G,aAAY,CAAE,EACtCzJ,QAAQ4C,GAAU,CAAA,IAAAiC,GACjBA,EAAIjC,EAAO+B,UAAPE,MAAAA,EAAgBzE,QAClBoJ,EAAa5G,EAAO+B,QAAShB,EAAQ,CAAC,GAEvC,CAAC,GAGR6F,EAAa9C,CAAU,EAEvB,IAAIiB,EAAqC,CAAA,EAEnC+B,EAAoBA,CACxBC,EACAhG,IACG,CAEH,IAAMgC,EAAkC,CACtChC,MAAAA,EACAP,GAAI,CAACgG,EAAc,GAAGzF,CAAK,EAAE,EAAEoD,OAAOC,OAAO,EAAE4C,KAAK,GAAG,EACvD3B,QAAS,CAAA,GAIL4B,EAAiD,CAAA,EAGvDF,EAAe3J,QAAQ8J,GAAiB,CAGtC,IAAMC,EAA4B,CAAC,GAAGF,CAAoB,EAAEjC,QAAO,EAAG,CAAC,EAEjEoC,EAAeF,EAAclH,OAAOe,QAAUgC,EAAYhC,MAE5Df,EACA0C,EAAgB,GAWpB,GATI0E,GAAgBF,EAAclH,OAAOgB,OAEvChB,EAASkH,EAAclH,OAAOgB,QAG9BhB,EAASkH,EAAclH,OACvB0C,EAAgB,IAIhByE,GACAA,GAA2BnH,SAAWA,EAGtCmH,EAA0BvE,WAAWtF,KAAK4J,CAAa,MAClD,CAEL,IAAM1F,EAASgB,GAAa1C,EAAOE,EAAQ,CACzCQ,GAAI,CAACgG,EAAczF,EAAOf,EAAOQ,GAAI0G,GAAe1G,EAAE,EACnD2D,OAAOC,OAAO,EACd4C,KAAK,GAAG,EACXtE,cAAAA,EACAC,cAAeD,EACX,GAAGuE,EAAqB9C,OAAO5H,GAAKA,EAAEyD,SAAWA,CAAM,EAAExC,MAAM,GAC/D+D,OACJR,MAAAA,EACAxC,MAAO0I,EAAqBzJ,MAC9B,CAAC,EAGDgE,EAAOoB,WAAWtF,KAAK4J,CAAa,EAGpCD,EAAqB3J,KAAKkE,CAAM,CAClC,CAEAuB,EAAYsC,QAAQ/H,KAAK4J,CAAa,EACtCA,EAAcnE,YAAcA,CAC9B,CAAC,EAEDgC,EAAazH,KAAKyF,CAAW,EAEzBhC,EAAQ,GACV+F,EAAkBG,EAAsBlG,EAAQ,CAAC,GAI/CsG,EAAgBd,EAAenD,IAAI,CAACpD,EAAQzB,IAChDiE,GAAa1C,EAAOE,EAAQ,CAC1Be,MAAO4F,EACPpI,MAAAA,CACF,CAAC,CACH,EAEAuI,EAAkBO,EAAeV,EAAW,CAAC,EAE7C5B,EAAaC,QAAO,EAMpB,IAAMsC,EACJjC,GAEwBA,EAAQlB,OAAO3C,GACrCA,EAAOxB,OAAO6G,aAAY,CAC5B,EAEuBzD,IAAI5B,GAAU,CACnC,IAAIqB,EAAU,EACVC,EAAU,EACVyE,EAAgB,CAAC,CAAC,EAElB/F,EAAOoB,YAAcpB,EAAOoB,WAAWpF,QACzC+J,EAAgB,CAAA,EAEhBD,EAAuB9F,EAAOoB,UAAU,EAAExF,QACxC6D,GAAsD,CAAA,GAArD,CAAE4B,QAAS2E,EAAc1E,QAAS2E,CAAa,EAACxG,EAC/C4B,GAAW2E,EACXD,EAAcjK,KAAKmK,CAAY,CACjC,CACF,GAEA5E,EAAU,EAGZ,IAAM6E,EAAkB/I,KAAKW,IAAI,GAAGiI,CAAa,EACjDzE,OAAAA,EAAUA,EAAU4E,EAEpBlG,EAAOqB,QAAUA,EACjBrB,EAAOsB,QAAUA,EAEV,CAAED,QAAAA,EAASC,QAAAA,EACpB,CAAC,EAGHwE,OAAAA,GAAsBb,GAAAC,EAAC3B,EAAa,CAAC,IAAC,KAAA,OAAf2B,EAAiBrB,UAAO,KAAAoB,EAAI,CAAA,CAAE,EAE9C1B,CACT,KChiBa4C,GAAYA,CACvB7H,EACAU,EACAoH,EACAC,EACA9G,EACA+G,EACAC,IACe,CACf,IAAIhI,EAAsB,CACxBS,GAAAA,EACAjC,MAAOsJ,EACPD,SAAAA,EACA7G,MAAAA,EACAgH,SAAAA,EACAC,aAAc,CAAA,EACdC,mBAAoB,CAAA,EACpB5H,SAAUJ,GAAY,CACpB,GAAIF,EAAIiI,aAAaE,eAAejI,CAAQ,EAC1C,OAAOF,EAAIiI,aAAa/H,CAAQ,EAGlC,IAAMD,EAASF,EAAMqI,UAAUlI,CAAQ,EAEvC,GAAKD,GAAM,MAANA,EAAQyB,WAIb1B,OAAAA,EAAIiI,aAAa/H,CAAQ,EAAID,EAAOyB,WAClC1B,EAAI6H,SACJC,CACF,EAEO9H,EAAIiI,aAAa/H,CAAQ,GAElCmI,gBAAiBnI,GAAY,CAC3B,GAAIF,EAAIkI,mBAAmBC,eAAejI,CAAQ,EAChD,OAAOF,EAAIkI,mBAAmBhI,CAAQ,EAGxC,IAAMD,EAASF,EAAMqI,UAAUlI,CAAQ,EAEvC,GAAKD,GAAM,MAANA,EAAQyB,WAIb,OAAKzB,EAAOc,UAAUsH,iBAKtBrI,EAAIkI,mBAAmBhI,CAAQ,EAAID,EAAOc,UAAUsH,gBAClDrI,EAAI6H,SACJC,CACF,EAEO9H,EAAIkI,mBAAmBhI,CAAQ,IATpCF,EAAIkI,mBAAmBhI,CAAQ,EAAI,CAACF,EAAIM,SAASJ,CAAQ,CAAC,EACnDF,EAAIkI,mBAAmBhI,CAAQ,IAU1CQ,YAAaR,GAAQ,CAAA,IAAAoI,EAAA,OAAAA,EACnBtI,EAAIM,SAASJ,CAAQ,IAAC,KAAAoI,EAAIvI,EAAMQ,QAAQC,mBAAmB,EAC7DuH,QAASA,GAAW,CAAA,EACpBQ,YAAaA,IAAMxL,GAAUiD,EAAI+H,QAASvL,GAAKA,EAAEuL,OAAO,EACxDS,aAAcA,IACZxI,EAAIgI,SAAWjI,EAAM0I,OAAOzI,EAAIgI,SAAU,EAAI,EAAIxG,OACpDkH,cAAeA,IAAM,CACnB,IAAIC,EAA2B,CAAA,EAC3BC,EAAa5I,EACjB,OAAa,CACX,IAAM6I,EAAYD,EAAWJ,aAAY,EACzC,GAAI,CAACK,EAAW,MAChBF,EAAWpL,KAAKsL,CAAS,EACzBD,EAAaC,CACf,CACA,OAAOF,EAAW1D,QAAO,GAE3B6D,YAAapL,EACX,IAAM,CAACqC,EAAMgJ,kBAAiB,CAAE,EAChCvG,GACSA,EAAYa,IAAIpD,GACdH,GAAWC,EAAOC,EAAmBC,EAAQA,EAAOQ,EAAE,CAC9D,EAEHjB,EAAeO,EAAMQ,QAAS,YAAa,aAAa,CAC1D,EAEAyI,uBAAwBtL,EACtB,IAAM,CAACsC,EAAI8I,YAAW,CAAE,EACxBG,GACSA,EAASC,OACd,CAACC,EAAK9I,KACJ8I,EAAI9I,EAAKJ,OAAOQ,EAAE,EAAIJ,EACf8I,GAET,CAAA,CACF,EAEF3J,EAAeO,EAAMQ,QAAS,YAAa,uBAAuB,CACpE,GAGF,QAAS6I,EAAI,EAAGA,EAAIrJ,EAAMa,UAAUnD,OAAQ2L,IAAK,CAC/C,IAAMvI,EAAUd,EAAMa,UAAUwI,CAAC,EACjCvI,GAAAA,MAAAA,EAAS+G,WAAT/G,MAAAA,EAAS+G,UAAY5H,EAAmBD,CAAK,CAC/C,CAEA,OAAOC,CACT,ECzJaqJ,GAA+B,CAC1CvI,aAAcA,CACZb,EACAF,IACS,CACTE,EAAOqJ,oBACLvJ,EAAMQ,QAAQgJ,oBACdxJ,EAAMQ,QAAQgJ,mBAAmBxJ,EAAOE,EAAOQ,EAAE,EACnDR,EAAOsJ,mBAAqB,IACrBtJ,EAAOqJ,oBAILrJ,EAAOqJ,oBAAmB,EAHxBvJ,EAAMyJ,uBAAsB,EAKvCvJ,EAAOwJ,wBACL1J,EAAMQ,QAAQmJ,wBACd3J,EAAMQ,QAAQmJ,uBAAuB3J,EAAOE,EAAOQ,EAAE,EACvDR,EAAOyJ,uBAAyB,IACzBzJ,EAAOwJ,wBAILxJ,EAAOwJ,wBAAuB,EAH5B,IAAIE,IAKf1J,EAAO2J,wBACL7J,EAAMQ,QAAQsJ,wBACd9J,EAAMQ,QAAQsJ,uBAAuB9J,EAAOE,EAAOQ,EAAE,EACvDR,EAAO4J,uBAAyB,IAAM,CACpC,GAAK5J,EAAO2J,wBAIZ,OAAO3J,EAAO2J,wBAAuB,EAEzC,CACF,ECjFME,GAAgCA,CACpC9J,EACAE,EACA6J,IACG,CAAA,IAAAzB,EACH,IAAM0B,EAASD,EAAYE,YAAW,EACtC,MAAO5F,GAAOiE,GAAAA,EACZtI,EACGM,SAAwBJ,CAAQ,IAAC,OAAAoI,EADpCA,EAEI4B,SAAQ,IAAE5B,OAAAA,EAFdA,EAGI2B,YAAW,IAAE,OAHjB3B,EAII3G,SAASqI,CAAM,EAEvB,EAEAF,GAAeK,WAAcrN,GAAasN,GAAWtN,CAAG,EAExD,IAAMuN,GAAyCA,CAC7CrK,EACAE,EACA6J,IACG,CAAA,IAAAO,EACH,MAAOjG,GAAOiG,GAAAA,EACZtK,EAAIM,SAAwBJ,CAAQ,IAACoK,OAAAA,EAArCA,EAAuCJ,SAAQ,IAAE,OAAjDI,EAAmD3I,SAASoI,CAAW,EAE3E,EAEAM,GAAwBF,WAAcrN,GAAasN,GAAWtN,CAAG,EAEjE,IAAMyN,GAA8BA,CAClCvK,EACAE,EACA6J,IACG,CAAA,IAAAS,EACH,QACEA,EAAAxK,EAAIM,SAAwBJ,CAAQ,IAAC,OAAAsK,EAArCA,EAAuCN,SAAQ,IAA/CM,KAAAA,OAAAA,EAAmDP,YAAW,KAC9DF,GAAaE,YAAW,CAE5B,EAEAM,GAAaJ,WAAcrN,GAAasN,GAAWtN,CAAG,EAEtD,IAAM2N,GAA6BA,CACjCzK,EACAE,EACA6J,IACG,CAAA,IAAAW,EACH,OAAAA,EAAO1K,EAAIM,SAAoBJ,CAAQ,IAAC,KAAA,OAAjCwK,EAAmC/I,SAASoI,CAAW,CAChE,EAEAU,GAAYN,WAAcrN,GAAasN,GAAWtN,CAAG,GAAK,EAACA,GAAAA,MAAAA,EAAKW,QAEhE,IAAMkN,GAAgCA,CACpC3K,EACAE,EACA6J,IAEO,CAACA,EAAYzL,KAClBxB,GAAG,CAAA,IAAA8N,EAAA,MAAI,GAAAA,EAAC5K,EAAIM,SAAoBJ,CAAQ,IAAC,MAAjC0K,EAAmCjJ,SAAS7E,CAAG,EAAC,CAC1D,EAGF6N,GAAeR,WAAcrN,GAAasN,GAAWtN,CAAG,GAAK,EAACA,GAAAA,MAAAA,EAAKW,QAEnE,IAAMoN,GAAiCA,CACrC7K,EACAE,EACA6J,IAEOA,EAAYzL,KAAKxB,GAAG,CAAA,IAAAgO,EAAA,OAAAA,EACzB9K,EAAIM,SAAoBJ,CAAQ,IAAC,KAAA,OAAjC4K,EAAmCnJ,SAAS7E,CAAG,CAAC,CAClD,EAGF+N,GAAgBV,WAAcrN,GAAasN,GAAWtN,CAAG,GAAK,EAACA,GAAAA,MAAAA,EAAKW,QAEpE,IAAMsN,GAAwBA,CAAC/K,EAAKE,EAAkB6J,IAC7C/J,EAAIM,SAASJ,CAAQ,IAAM6J,EAGpCgB,GAAOZ,WAAcrN,GAAasN,GAAWtN,CAAG,EAEhD,IAAMkO,GAA4BA,CAChChL,EACAE,EACA6J,IAEO/J,EAAIM,SAASJ,CAAQ,GAAK6J,EAGnCiB,GAAWb,WAAcrN,GAAasN,GAAWtN,CAAG,EAEpD,IAAMmO,GAA+BA,CACnCjL,EACAE,EACA6J,IACG,CACH,GAAI,CAACxK,EAAKD,CAAG,EAAIyK,EAEXmB,EAAWlL,EAAIM,SAAiBJ,CAAQ,EAC9C,OAAOgL,GAAY3L,GAAO2L,GAAY5L,CACxC,EAEA2L,GAAcE,mBAAsBrO,GAAoB,CACtD,GAAI,CAACsO,EAAWC,CAAS,EAAIvO,EAEzBwO,EACF,OAAOF,GAAc,SAAWG,WAAWH,CAAmB,EAAIA,EAChEI,EACF,OAAOH,GAAc,SAAWE,WAAWF,CAAmB,EAAIA,EAEhE9L,EACF6L,IAAc,MAAQK,OAAOC,MAAMJ,CAAS,EAAI,KAAYA,EAC1DhM,EAAM+L,IAAc,MAAQI,OAAOC,MAAMF,CAAS,EAAIG,IAAWH,EAErE,GAAIjM,EAAMD,EAAK,CACb,IAAMsM,EAAOrM,EACbA,EAAMD,EACNA,EAAMsM,CACR,CAEA,MAAO,CAACrM,EAAKD,CAAG,CAClB,EAEA2L,GAAcd,WAAcrN,GAC1BsN,GAAWtN,CAAG,GAAMsN,GAAWtN,EAAI,CAAC,CAAC,GAAKsN,GAAWtN,EAAI,CAAC,CAAC,EAItD,IAAM+O,GAAY,CACvB/B,eAAAA,GACAO,wBAAAA,GACAE,aAAAA,GACAE,YAAAA,GACAE,eAAAA,GACAE,gBAAAA,GACAE,OAAAA,GACAC,WAAAA,GACAC,cAAAA,EACF,EAMA,SAASb,GAAWtN,EAAU,CAC5B,OAA4BA,GAAQ,MAAQA,IAAQ,EACtD,CC6FO,IAAMgP,GAAgC,CAC3CC,oBAAqBA,KAGZ,CACLC,SAAU,SAIdC,gBAAkBC,IACT,CACLC,cAAe,CAAA,EACf,GAAGD,IAIPE,kBACErM,IAEO,CACLsM,sBAAuBrQ,GAAiB,gBAAiB+D,CAAK,EAC9DuM,mBAAoB,GACpBC,sBAAuB,MAI3BzL,aAAcA,CACZb,EACAF,IACS,CACTE,EAAOuM,gBAAkB,IAAM,CAC7B,IAAMC,EAAW1M,EAAM2M,gBAAe,EAAGC,SAAS,CAAC,EAE7CC,EAAQH,GAAUnM,SAASL,EAAOQ,EAAE,EAE1C,OAAI,OAAOmM,GAAU,SACZf,GAAU/B,eAGf,OAAO8C,GAAU,SACZf,GAAUZ,cAGf,OAAO2B,GAAU,WAIjBA,IAAU,MAAQ,OAAOA,GAAU,SAC9Bf,GAAUd,OAGfpO,MAAMC,QAAQgQ,CAAK,EACdf,GAAUpB,YAGZoB,GAAUb,YAEnB/K,EAAO4M,YAAc,IAAM,CAAA,IAAAC,EAAAC,EACzB,OAAOxQ,GAAW0D,EAAOc,UAAUiL,QAAQ,EACvC/L,EAAOc,UAAUiL,SACjB/L,EAAOc,UAAUiL,WAAa,OAC5B/L,EAAOuM,gBAAe,GACtBM,GAAAC,EACAhN,EAAMQ,QAAQsL,YAAS,KAAA,OAAvBkB,EAA0B9M,EAAOc,UAAUiL,QAAQ,IAAWc,KAAAA,EAC9DjB,GAAU5L,EAAOc,UAAUiL,QAAQ,GAE3C/L,EAAO+M,aAAe,IAAM,CAAA,IAAAC,EAAAC,EAAAC,EAC1B,QACEF,EAAChN,EAAOc,UAAUqM,qBAAkB,KAAAH,EAAI,OAAIC,EAC3CnN,EAAMQ,QAAQ8M,sBAAmB,KAAAH,EAAI,OAAKC,EAC1CpN,EAAMQ,QAAQ+M,gBAAa,KAAAH,EAAI,KAChC,CAAC,CAAClN,EAAOyB,YAIbzB,EAAOsN,cAAgB,IAAMtN,EAAOuN,eAAc,EAAK,GAEvDvN,EAAOwN,eAAiB,IAAA,CAAA,IAAAC,EAAA,OAAAA,EACtB3N,EAAM4D,SAAQ,EAAGwI,gBAAa,OAAAuB,EAA9BA,EAAgCvJ,KAAK3H,GAAKA,EAAEiE,KAAOR,EAAOQ,EAAE,IAA5DiN,KAAAA,OAAAA,EAA+Dd,KAAK,EAEtE3M,EAAOuN,eAAiB,IAAA,CAAA,IAAAG,EAAAC,EAAA,OAAAD,GAAAC,EACtB7N,EAAM4D,SAAQ,EAAGwI,gBAAa,KAAA,OAA9ByB,EAAgCC,UAAUrR,GAAKA,EAAEiE,KAAOR,EAAOQ,EAAE,IAAC,KAAAkN,EAAI,EAAE,EAE1E1N,EAAO6N,eAAiBlB,GAAS,CAC/B7M,EAAMgO,iBAAiB1R,GAAO,CAC5B,IAAM2P,EAAW/L,EAAO4M,YAAW,EAC7BmB,EAAiB3R,GAAK8H,KAAK3H,GAAKA,EAAEiE,KAAOR,EAAOQ,EAAE,EAElDwN,EAAY3R,GAChBsQ,EACAoB,EAAiBA,EAAepB,MAAQpL,MAC1C,EAGA,GACE0M,GAAuBlC,EAA6BiC,EAAWhO,CAAM,EACrE,CAAA,IAAAkO,EACA,OAAAA,EAAO9R,GAAK+H,OAAO5H,GAAKA,EAAEiE,KAAOR,EAAOQ,EAAE,IAAC,KAAA0N,EAAI,CAAA,CACjD,CAEA,IAAMC,EAAe,CAAE3N,GAAIR,EAAOQ,GAAImM,MAAOqB,GAE7C,GAAID,EAAgB,CAAA,IAAAK,EAClB,OAAAA,EACEhS,GAAKgH,IAAI7G,GACHA,EAAEiE,KAAOR,EAAOQ,GACX2N,EAEF5R,CACR,IAAC,KAAA6R,EAAI,CAAA,CAEV,CAEA,OAAIhS,GAAG,MAAHA,EAAKoB,OACA,CAAC,GAAGpB,EAAK+R,CAAY,EAGvB,CAACA,CAAY,CACtB,CAAC,IAILxG,UAAWA,CACT5H,EACAsO,IACS,CACTtO,EAAImM,cAAgB,CAAA,EACpBnM,EAAIuO,kBAAoB,CAAA,GAG1BhL,YAAqCxD,GAA8B,CACjEA,EAAMgO,iBAAoB5R,GAAyC,CACjE,IAAMqG,EAAczC,EAAMgJ,kBAAiB,EAErCyF,EAAYnS,GAA4B,CAAA,IAAAoS,EAC5C,OAAAA,EAAOnS,GAAiBH,EAASE,CAAG,IAAC,KAAA,OAA9BoS,EAAgCrK,OAAOA,GAAU,CACtD,IAAMnE,EAASuC,EAAY2B,KAAK3H,GAAKA,EAAEiE,KAAO2D,EAAO3D,EAAE,EAEvD,GAAIR,EAAQ,CACV,IAAM+L,EAAW/L,EAAO4M,YAAW,EAEnC,GAAIqB,GAAuBlC,EAAU5H,EAAOwI,MAAO3M,CAAM,EACvD,MAAO,EAEX,CAEA,MAAO,EACT,CAAC,GAGHF,EAAMQ,QAAQ8L,uBAAdtM,MAAAA,EAAMQ,QAAQ8L,sBAAwBmC,CAAQ,GAGhDzO,EAAM2O,mBAAqBC,GAAgB,CAAA,IAAAC,EAAAC,EACzC9O,EAAMgO,iBACJY,EAAe,CAAA,GAAEC,GAAAC,EAAG9O,EAAM+O,eAAY,KAAA,OAAlBD,EAAoB1C,gBAAayC,KAAAA,EAAI,CAAA,CAC3D,GAGF7O,EAAMyJ,uBAAyB,IAAMzJ,EAAM2M,gBAAe,EAC1D3M,EAAMgP,oBAAsB,KACtB,CAAChP,EAAMiP,sBAAwBjP,EAAMQ,QAAQwO,sBAC/ChP,EAAMiP,qBAAuBjP,EAAMQ,QAAQwO,oBAAoBhP,CAAK,GAGlEA,EAAMQ,QAAQ0O,iBAAmB,CAAClP,EAAMiP,qBACnCjP,EAAMyJ,uBAAsB,EAG9BzJ,EAAMiP,qBAAoB,EAErC,CACF,EAEO,SAASd,GACdlC,EACAY,EACA3M,EACA,CACA,OACG+L,GAAYA,EAAS7B,WAClB6B,EAAS7B,WAAWyC,EAAO3M,CAAM,EACjC,KACJ,OAAO2M,EAAU,KAChB,OAAOA,GAAU,UAAY,CAACA,CAEnC,CCzaA,IAAMsC,GAA0BA,CAAChP,EAAUiP,EAAWC,IAG7CA,EAAUlG,OAAO,CAACgG,EAAKG,IAAS,CACrC,IAAMC,EAAYD,EAAK/O,SAASJ,CAAQ,EACxC,OAAOgP,GAAO,OAAOI,GAAc,SAAWA,EAAY,IACzD,CAAC,EAGA/P,GAA0BA,CAACW,EAAUiP,EAAWC,IAAc,CAClE,IAAI7P,EAEJ6P,OAAAA,EAAU/R,QAAQ2C,GAAO,CACvB,IAAM4M,EAAQ5M,EAAIM,SAAiBJ,CAAQ,EAGzC0M,GAAS,OACRrN,EAAOqN,GAAUrN,IAAQiC,QAAaoL,GAASA,KAEhDrN,EAAMqN,EAEV,CAAC,EAEMrN,CACT,EAEMD,GAA0BA,CAACY,EAAUiP,EAAWC,IAAc,CAClE,IAAI9P,EAEJ8P,OAAAA,EAAU/R,QAAQ2C,GAAO,CACvB,IAAM4M,EAAQ5M,EAAIM,SAAiBJ,CAAQ,EAEzC0M,GAAS,OACRtN,EAAOsN,GAAUtN,IAAQkC,QAAaoL,GAASA,KAEhDtN,EAAMsN,EAEV,CAAC,EAEMtN,CACT,EAEMiQ,GAA6BA,CAACrP,EAAUiP,EAAWC,IAAc,CACrE,IAAI7P,EACAD,EAEJ8P,OAAAA,EAAU/R,QAAQ2C,GAAO,CACvB,IAAM4M,EAAQ5M,EAAIM,SAAiBJ,CAAQ,EACvC0M,GAAS,OACPrN,IAAQiC,OACNoL,GAASA,IAAOrN,EAAMD,EAAMsN,IAE5BrN,EAAMqN,IAAOrN,EAAMqN,GACnBtN,EAAOsN,IAAOtN,EAAMsN,IAG9B,CAAC,EAEM,CAACrN,EAAKD,CAAG,CAClB,EAEMkQ,GAA2BA,CAACtP,EAAUuP,IAAa,CACvD,IAAIC,EAAQ,EACRR,EAAM,EASV,GAPAO,EAASpS,QAAQ2C,GAAO,CACtB,IAAI4M,EAAQ5M,EAAIM,SAAiBJ,CAAQ,EACrC0M,GAAS,OAASA,EAAQ,CAACA,IAAUA,IACvC,EAAE8C,EAAQR,GAAOtC,EAErB,CAAC,EAEG8C,EAAO,OAAOR,EAAMQ,CAG1B,EAEMC,GAA6BA,CAACzP,EAAUuP,IAAa,CACzD,GAAI,CAACA,EAAShS,OACZ,OAGF,IAAMmS,EAASH,EAASpM,IAAIrD,GAAOA,EAAIM,SAASJ,CAAQ,CAAC,EACzD,GAAI,CAACxD,GAAckT,CAAM,EACvB,OAEF,GAAIA,EAAOnS,SAAW,EACpB,OAAOmS,EAAO,CAAC,EAGjB,IAAMC,EAAMjR,KAAKkR,MAAMF,EAAOnS,OAAS,CAAC,EAClCsS,EAAOH,EAAOI,KAAK,CAACC,EAAGC,IAAMD,EAAIC,CAAC,EACxC,OAAON,EAAOnS,OAAS,IAAM,EAAIsS,EAAKF,CAAG,GAAKE,EAAKF,EAAM,CAAC,EAAKE,EAAKF,CAAG,GAAM,CAC/E,EAEMM,GAA6BA,CAACjQ,EAAUuP,IACrC9S,MAAMyT,KAAK,IAAIC,IAAIZ,EAASpM,IAAI7G,GAAKA,EAAE8D,SAASJ,CAAQ,CAAC,CAAC,EAAE0P,OAAM,CAAE,EAGvEU,GAAkCA,CAACpQ,EAAUuP,IAC1C,IAAIY,IAAIZ,EAASpM,IAAI7G,GAAKA,EAAE8D,SAASJ,CAAQ,CAAC,CAAC,EAAEqQ,KAGpDb,GAA4BA,CAACc,EAAWf,IACrCA,EAAShS,OAGLgT,GAAiB,CAC5BvB,IAAAA,GACA3P,IAAAA,GACAD,IAAAA,GACAiQ,OAAAA,GACAC,KAAAA,GACAG,OAAAA,GACAQ,OAAAA,GACAG,YAAAA,GACAZ,MAAAA,EACF,ECyHagB,GAA+B,CAC1C3E,oBAAqBA,KAIZ,CACL4E,eAAgBC,GAAK,CAAA,IAAAC,EAAAC,EAAA,OAAAD,GAAAC,EAAKF,EAAMtQ,SAAQ,IAAfwQ,MAAAA,EAA2B5G,UAAQ,KAAA,OAAnC4G,EAA2B5G,SAAQ,IAAI,KAAA2G,EAAI,IAAI,EACxEE,cAAe,SAInB9E,gBAAkBC,IACT,CACL8E,SAAU,CAAA,EACV,GAAG9E,IAIPE,kBACErM,IAEO,CACLkR,iBAAkBjV,GAAiB,WAAY+D,CAAK,EACpDmR,kBAAmB,YAIvBpQ,aAAcA,CACZb,EACAF,IACS,CACTE,EAAOkR,eAAiB,IAAM,CAC5BpR,EAAMqR,YAAY/U,GAEZA,GAAAA,MAAAA,EAAKsF,SAAS1B,EAAOQ,EAAE,EAClBpE,EAAI+H,OAAO5H,GAAKA,IAAMyD,EAAOQ,EAAE,EAGjC,CAAC,GAAIpE,GAAO,CAAA,EAAK4D,EAAOQ,EAAE,CAClC,GAGHR,EAAOoR,YAAc,IAAM,CAAA,IAAApE,EAAAC,EACzB,QACED,EAAChN,EAAOc,UAAUuQ,iBAAcrE,KAAAA,EAAI,OAAIC,EACvCnN,EAAMQ,QAAQ+Q,iBAAc,KAAApE,EAAI,MAChC,CAAC,CAACjN,EAAOyB,YAAc,CAAC,CAACzB,EAAOc,UAAUwQ,mBAI/CtR,EAAOuR,aAAe,IAAM,CAAA,IAAAC,EAC1B,OAAAA,EAAO1R,EAAM4D,SAAQ,EAAGqN,WAAQ,KAAA,OAAzBS,EAA2B9P,SAAS1B,EAAOQ,EAAE,GAGtDR,EAAOyR,gBAAkB,IAAA,CAAA,IAAAC,EAAA,OAAAA,EAAM5R,EAAM4D,SAAQ,EAAGqN,WAAQ,KAAA,OAAzBW,EAA2BC,QAAQ3R,EAAOQ,EAAE,CAAC,EAE5ER,EAAO4R,yBAA2B,IAAM,CACtC,IAAMC,EAAW7R,EAAOoR,YAAW,EAEnC,MAAO,IAAM,CACNS,GACL7R,EAAOkR,eAAc,IAGzBlR,EAAO8R,qBAAuB,IAAM,CAClC,IAAMtF,EAAW1M,EAAM2M,gBAAe,EAAGC,SAAS,CAAC,EAE7CC,EAAQH,GAAUnM,SAASL,EAAOQ,EAAE,EAE1C,GAAI,OAAOmM,GAAU,SACnB,OAAO6D,GAAevB,IAGxB,GAAI8C,OAAOC,UAAU/H,SAASgI,KAAKtF,CAAK,IAAM,gBAC5C,OAAO6D,GAAelB,QAG1BtP,EAAOkS,iBAAmB,IAAM,CAAA,IAAAC,EAAAC,EAC9B,GAAI,CAACpS,EACH,MAAM,IAAI8B,MAGZ,OAAOxF,GAAW0D,EAAOc,UAAUgQ,aAAa,EAC5C9Q,EAAOc,UAAUgQ,cACjB9Q,EAAOc,UAAUgQ,gBAAkB,OACjC9Q,EAAO8R,qBAAoB,GAAEK,GAAAC,EAC7BtS,EAAMQ,QAAQkQ,iBAAc,KAAA,OAA5B4B,EACEpS,EAAOc,UAAUgQ,aAAa,IAC/BqB,KAAAA,EACD3B,GACExQ,EAAOc,UAAUgQ,aAAa,IAK1CxN,YAAqCxD,GAA8B,CACjEA,EAAMqR,YAAcjV,GAAW4D,EAAMQ,QAAQ0Q,kBAAgB,KAAA,OAA9BlR,EAAMQ,QAAQ0Q,iBAAmB9U,CAAO,EAEvE4D,EAAMuS,cAAgB3D,GAAgB,CAAA,IAAA4D,EAAA1D,EACpC9O,EAAMqR,YAAYzC,EAAe,CAAA,GAAE4D,GAAA1D,EAAG9O,EAAM+O,eAAY,KAAA,OAAlBD,EAAoBmC,WAAQuB,KAAAA,EAAI,CAAA,CAAE,GAG1ExS,EAAMyS,sBAAwB,IAAMzS,EAAMgP,oBAAmB,EAC7DhP,EAAM0S,mBAAqB,KACrB,CAAC1S,EAAM2S,qBAAuB3S,EAAMQ,QAAQkS,qBAC9C1S,EAAM2S,oBAAsB3S,EAAMQ,QAAQkS,mBAAmB1S,CAAK,GAGhEA,EAAMQ,QAAQoS,gBAAkB,CAAC5S,EAAM2S,oBAClC3S,EAAMyS,sBAAqB,EAG7BzS,EAAM2S,oBAAmB,IAIpC9K,UAAWA,CACT5H,EACAD,IACS,CACTC,EAAIwR,aAAe,IAAM,CAAC,CAACxR,EAAI4S,iBAC/B5S,EAAIuR,iBAAmBrR,GAAY,CACjC,GAAIF,EAAI6S,qBAAqB1K,eAAejI,CAAQ,EAClD,OAAOF,EAAI6S,qBAAqB3S,CAAQ,EAG1C,IAAMD,EAASF,EAAMqI,UAAUlI,CAAQ,EAEvC,OAAKD,GAAAA,MAAAA,EAAQc,UAAUwQ,kBAIvBvR,EAAI6S,qBAAqB3S,CAAQ,EAAID,EAAOc,UAAUwQ,iBACpDvR,EAAI6H,QACN,EAEO7H,EAAI6S,qBAAqB3S,CAAQ,GAP/BF,EAAIM,SAASJ,CAAQ,GAShCF,EAAI6S,qBAAuB,CAAA,GAG7B/S,WAAYA,CACVO,EACAJ,EACAD,EACAD,IACS,CAITM,EAAKmR,aAAe,IAClBvR,EAAOuR,aAAY,GAAMvR,EAAOQ,KAAOT,EAAI4S,iBAC7CvS,EAAKyS,iBAAmB,IAAM,CAACzS,EAAKmR,aAAY,GAAMvR,EAAOuR,aAAY,EACzEnR,EAAK0S,gBAAkB,IAAA,CAAA,IAAAC,EAAA,MACrB,CAAC3S,EAAKmR,aAAY,GAAM,CAACnR,EAAKyS,iBAAgB,GAAM,CAAC,GAAAE,EAAChT,EAAI+H,UAAO,MAAXiL,EAAavV,OAAM,CAC7E,CACF,EAEO,SAAS6E,GACdE,EACAwO,EACAE,EACA,CACA,GAAI,EAACF,GAAAA,MAAAA,EAAUvT,SAAU,CAACyT,EACxB,OAAO1O,EAGT,IAAMyQ,EAAqBzQ,EAAY4B,OACrC8O,GAAO,CAAClC,EAASrP,SAASuR,EAAIzS,EAAE,CAClC,EAEA,OAAIyQ,IAAsB,SACjB+B,EAOF,CAAC,GAJgBjC,EACrB3N,IAAI8P,GAAK3Q,EAAY2B,KAAK+O,GAAOA,EAAIzS,KAAO0S,CAAC,CAAE,EAC/C/O,OAAOC,OAAO,EAEW,GAAG4O,CAAkB,CACnD,CC3VO,IAAMG,GAA+B,CAC1CnH,gBAAkBC,IACT,CACLmH,YAAa,CAAA,EACb,GAAGnH,IAIPE,kBACErM,IAEO,CACLuT,oBAAqBtX,GAAiB,cAAe+D,CAAK,IAI9De,aAAcA,CACZb,EACAF,IACS,CACTE,EAAOsT,SAAW7V,EAChB8V,GAAY,CAACC,GAAuB1T,EAAOyT,CAAQ,CAAC,EACpDxR,GAAWA,EAAQ6L,UAAUrR,GAAKA,EAAEiE,KAAOR,EAAOQ,EAAE,EACpDjB,EAAeO,EAAMQ,QAAS,eAAgB,UAAU,CAC1D,EACAN,EAAOyT,iBAAmBF,GAAY,CAAA,IAAAG,EAEpC,QAAOA,EADSF,GAAuB1T,EAAOyT,CAAQ,EACvC,CAAC,IAATG,KAAAA,OAAAA,EAAYlT,MAAOR,EAAOQ,IAEnCR,EAAO2T,gBAAkBJ,GAAY,CAAA,IAAAK,EACnC,IAAM7R,EAAUyR,GAAuB1T,EAAOyT,CAAQ,EACtD,QAAOK,EAAA7R,EAAQA,EAAQvE,OAAS,CAAC,IAAC,KAAA,OAA3BoW,EAA6BpT,MAAOR,EAAOQ,KAItD8C,YAAqCxD,GAA8B,CACjEA,EAAM+T,eAAiB3X,GACrB4D,EAAMQ,QAAQ+S,qBAAmB,KAAA,OAAjCvT,EAAMQ,QAAQ+S,oBAAsBnX,CAAO,EAC7C4D,EAAMgU,iBAAmBpF,GAAgB,CAAA,IAAAC,EACvC7O,EAAM+T,eACJnF,EAAe,CAAA,GAAEC,EAAG7O,EAAM+O,aAAauE,cAAW,KAAAzE,EAAI,CAAA,CACxD,GAEF7O,EAAMsC,mBAAqB3E,EACzB,IAAM,CACJqC,EAAM4D,SAAQ,EAAG0P,YACjBtT,EAAM4D,SAAQ,EAAGqN,SACjBjR,EAAMQ,QAAQ2Q,iBAAiB,EAEjC,CAACmC,EAAarC,EAAUE,IACrBlP,GAAsC,CAGrC,IAAIgS,EAA2C,CAAA,EAG/C,GAAI,EAACX,GAAW,MAAXA,EAAa5V,QAChBuW,EAAiBhS,MACZ,CACL,IAAMiS,EAAkB,CAAC,GAAGZ,CAAW,EAGjCa,EAAc,CAAC,GAAGlS,CAAO,EAK/B,KAAOkS,EAAYzW,QAAUwW,EAAgBxW,QAAQ,CACnD,IAAM0W,EAAiBF,EAAgBG,MAAK,EACtCC,EAAaH,EAAYrG,UAC7BrR,GAAKA,EAAEiE,KAAO0T,CAChB,EACIE,EAAa,IACfL,EAAezW,KAAK2W,EAAYI,OAAOD,EAAY,CAAC,EAAE,CAAC,CAAE,CAE7D,CAGAL,EAAiB,CAAC,GAAGA,EAAgB,GAAGE,CAAW,CACrD,CAEA,OAAO5R,GAAa0R,EAAgBhD,EAAUE,CAAiB,GAEnE1R,EAAeO,EAAMQ,QAAS,aAAc,oBAAoB,CAClE,CACF,CACF,ECbMgU,GAA+BA,KAA2B,CAC9D1Q,KAAM,CAAA,EACNC,MAAO,CAAA,CACT,GAEa0Q,GAA8B,CACzCvI,gBAAkBC,IACT,CACLtI,cAAe2Q,GAA4B,EAC3C,GAAGrI,IAIPE,kBACErM,IAEO,CACL0U,sBAAuBzY,GAAiB,gBAAiB+D,CAAK,IAIlEe,aAAcA,CACZb,EACAF,IACS,CACTE,EAAOyU,IAAMlB,GAAY,CACvB,IAAMmB,EAAY1U,EACfmC,eAAc,EACdiB,IAAI7G,GAAKA,EAAEiE,EAAE,EACb2D,OAAOC,OAAO,EAEjBtE,EAAM6U,iBAAiBvY,GAAO,CAAA,IAAAwY,EAAAC,EAC5B,GAAItB,IAAa,QAAS,CAAA,IAAAuB,EAAAC,EACxB,MAAO,CACLnR,OAAMkR,EAAC1Y,GAAKwH,OAAIkR,KAAAA,EAAI,CAAA,GAAI3Q,OAAO5H,GAAK,EAACmY,GAAS,MAATA,EAAWhT,SAASnF,CAAC,EAAE,EAC5DsH,MAAO,CACL,KAAGkR,EAAC3Y,GAAKyH,QAAKkR,KAAAA,EAAI,CAAA,GAAI5Q,OAAO5H,GAAK,EAACmY,GAAS,MAATA,EAAWhT,SAASnF,CAAC,EAAE,EAC1D,GAAGmY,CAAS,EAGlB,CAEA,GAAInB,IAAa,OAAQ,CAAA,IAAAyB,EAAAC,EACvB,MAAO,CACLrR,KAAM,CACJ,KAAGoR,EAAC5Y,GAAKwH,OAAIoR,KAAAA,EAAI,CAAA,GAAI7Q,OAAO5H,GAAK,EAACmY,GAAS,MAATA,EAAWhT,SAASnF,CAAC,EAAC,EACxD,GAAGmY,CAAS,EAEd7Q,QAAOoR,EAAC7Y,GAAKyH,QAAKoR,KAAAA,EAAI,CAAA,GAAI9Q,OAAO5H,GAAK,EAACmY,GAAAA,MAAAA,EAAWhT,SAASnF,CAAC,EAAC,EAEjE,CAEA,MAAO,CACLqH,OAAMgR,EAACxY,GAAKwH,OAAIgR,KAAAA,EAAI,CAAA,GAAIzQ,OAAO5H,GAAK,EAACmY,GAAS,MAATA,EAAWhT,SAASnF,CAAC,EAAE,EAC5DsH,QAAOgR,EAACzY,GAAKyH,QAAKgR,KAAAA,EAAI,CAAA,GAAI1Q,OAAO5H,GAAK,EAACmY,GAAAA,MAAAA,EAAWhT,SAASnF,CAAC,EAAC,EAEjE,CAAC,GAGHyD,EAAOkV,UAAY,IACGlV,EAAOmC,eAAc,EAEtB9D,KACjB9B,GAAC,CAAA,IAAA4Y,EAAAlU,EAAAgM,EAAA,QACCkI,EAAC5Y,EAAEuE,UAAUsU,gBAAa,KAAAD,EAAI,OAAIlU,GAAAgM,EACjCnN,EAAMQ,QAAQ+U,sBAAmB,KAAApI,EAChCnN,EAAMQ,QAAQ8U,gBAAa,KAAAnU,EAC3B,GAAK,CACX,EAGFjB,EAAOsV,YAAc,IAAM,CACzB,IAAMC,EAAgBvV,EAAOmC,eAAc,EAAGiB,IAAI7G,GAAKA,EAAEiE,EAAE,EAErD,CAAEoD,KAAAA,EAAMC,MAAAA,CAAM,EAAI/D,EAAM4D,SAAQ,EAAGC,cAEnC6R,EAASD,EAAclX,KAAK9B,GAAKqH,GAAMlC,SAASnF,CAAC,CAAC,EAClDkZ,EAAUF,EAAclX,KAAK9B,GAAKsH,GAAOnC,SAASnF,CAAC,CAAC,EAE1D,OAAOiZ,EAAS,OAASC,EAAU,QAAU,IAG/CzV,EAAO0V,eAAiB,IAAM,CAAA,IAAAjI,EAAAC,EAC5B,IAAM6F,EAAWvT,EAAOsV,YAAW,EAEnC,OAAO/B,GAAQ9F,GAAAC,EACX5N,EAAM4D,SAAQ,EAAGC,gBAAa,OAAA+J,EAA9BA,EAAiC6F,CAAQ,IAAzC7F,KAAAA,OAAAA,EAA4CiE,QAAQ3R,EAAOQ,EAAE,IAAC,KAAAiN,EAAI,GAClE,IAIR9F,UAAWA,CACT5H,EACAD,IACS,CACTC,EAAI4V,sBAAwBlY,EAC1B,IAAM,CACJsC,EAAI6V,oBAAmB,EACvB9V,EAAM4D,SAAQ,EAAGC,cAAcC,KAC/B9D,EAAM4D,SAAQ,EAAGC,cAAcE,KAAK,EAEtC,CAACmF,EAAUpF,EAAMC,IAAU,CACzB,IAAMgS,EAAyB,CAAC,GAAIjS,GAAQ,CAAA,EAAK,GAAIC,GAAS,CAAA,CAAE,EAEhE,OAAOmF,EAAS7E,OAAO5H,GAAK,CAACsZ,EAAanU,SAASnF,EAAEyD,OAAOQ,EAAE,CAAC,GAEjEjB,EAAeO,EAAMQ,QAAS,YAAa,uBAAuB,CACpE,EACAP,EAAI+V,oBAAsBrY,EACxB,IAAM,CAACsC,EAAI6V,oBAAmB,EAAI9V,EAAM4D,SAAQ,EAAGC,cAAcC,IAAI,EACrE,CAACoF,EAAUpF,KACMA,GAAQ,CAAA,GACpBR,IAAInD,GAAY+I,EAAS9E,KAAK9D,GAAQA,EAAKJ,OAAOQ,KAAOP,CAAQ,CAAE,EACnEkE,OAAOC,OAAO,EACdhB,IAAI7G,IAAM,CAAE,GAAGA,EAAGgX,SAAU,MAAO,EAA0B,EAIlEhU,EAAeO,EAAMQ,QAAS,YAAa,qBAAqB,CAClE,EACAP,EAAIgW,qBAAuBtY,EACzB,IAAM,CAACsC,EAAI6V,oBAAmB,EAAI9V,EAAM4D,SAAQ,EAAGC,cAAcE,KAAK,EACtE,CAACmF,EAAUnF,KACMA,GAAS,CAAA,GACrBT,IAAInD,GAAY+I,EAAS9E,KAAK9D,GAAQA,EAAKJ,OAAOQ,KAAOP,CAAQ,CAAE,EACnEkE,OAAOC,OAAO,EACdhB,IAAI7G,IAAM,CAAE,GAAGA,EAAGgX,SAAU,OAAQ,EAA0B,EAInEhU,EAAeO,EAAMQ,QAAS,YAAa,sBAAsB,CACnE,GAGFgD,YAAqCxD,GAA8B,CACjEA,EAAM6U,iBAAmBzY,GACvB4D,EAAMQ,QAAQkU,uBAAqB,KAAA,OAAnC1U,EAAMQ,QAAQkU,sBAAwBtY,CAAO,EAE/C4D,EAAMkW,mBAAqBtH,GAAY,CAAA,IAAAC,EAAAC,EAAA,OACrC9O,EAAM6U,iBACJjG,EACI4F,GAA4B,GAAE3F,GAAAC,EAC9B9O,EAAM+O,eAAND,KAAAA,OAAAA,EAAoBjL,gBAAagL,KAAAA,EAAI2F,GAA4B,CACvE,CAAC,EAEHxU,EAAMmW,uBAAyB1C,GAAY,CAAA,IAAA2C,EACzC,IAAMC,EAAerW,EAAM4D,SAAQ,EAAGC,cAEtC,GAAI,CAAC4P,EAAU,CAAA,IAAA6C,EAAAC,EACb,MAAOjS,IAAQgS,EAAAD,EAAavS,OAAI,MAAjBwS,EAAmB5Y,SAAM6Y,EAAIF,EAAatS,QAAbwS,MAAAA,EAAoB7Y,OAClE,CACA,MAAO4G,IAAO8R,EAACC,EAAa5C,CAAQ,IAArB2C,MAAAA,EAAwB1Y,SAGzCsC,EAAMwW,mBAAqB7Y,EACzB,IAAM,CAACqC,EAAMgJ,kBAAiB,EAAIhJ,EAAM4D,SAAQ,EAAGC,cAAcC,IAAI,EACrE,CAACE,EAAYF,KACHA,GAAQ,CAAA,GACbR,IAAInD,GAAY6D,EAAWI,KAAKlE,GAAUA,EAAOQ,KAAOP,CAAQ,CAAE,EAClEkE,OAAOC,OAAO,EAEnB7E,EAAeO,EAAMQ,QAAS,eAAgB,oBAAoB,CACpE,EAEAR,EAAMyW,oBAAsB9Y,EAC1B,IAAM,CAACqC,EAAMgJ,kBAAiB,EAAIhJ,EAAM4D,SAAQ,EAAGC,cAAcE,KAAK,EACtE,CAACC,EAAYD,KACHA,GAAS,CAAA,GACdT,IAAInD,GAAY6D,EAAWI,KAAKlE,GAAUA,EAAOQ,KAAOP,CAAQ,CAAE,EAClEkE,OAAOC,OAAO,EAEnB7E,EAAeO,EAAMQ,QAAS,eAAgB,qBAAqB,CACrE,EAEAR,EAAM0W,qBAAuB/Y,EAC3B,IAAM,CACJqC,EAAMgJ,kBAAiB,EACvBhJ,EAAM4D,SAAQ,EAAGC,cAAcC,KAC/B9D,EAAM4D,SAAQ,EAAGC,cAAcE,KAAK,EAEtC,CAACC,EAAYF,EAAMC,IAAU,CAC3B,IAAMgS,EAAyB,CAAC,GAAIjS,GAAQ,CAAA,EAAK,GAAIC,GAAS,CAAA,CAAE,EAEhE,OAAOC,EAAWK,OAAO5H,GAAK,CAACsZ,EAAanU,SAASnF,EAAEiE,EAAE,CAAC,GAE5DjB,EAAeO,EAAMQ,QAAS,eAAgB,sBAAsB,CACtE,CACF,CACF,ECrHamW,GAAsB,CACjCnG,KAAM,IACNoG,QAAS,GACTC,QAASnL,OAAOoL,gBAClB,EAEMC,GAAkCA,KAA8B,CACpEC,YAAa,KACbC,UAAW,KACXC,YAAa,KACbC,gBAAiB,KACjBC,iBAAkB,GAClBC,kBAAmB,CAAA,CACrB,GAEaC,GAA6B,CACxCtL,oBAAqBA,IACZ2K,GAETzK,gBAAkBC,IACT,CACLoL,aAAc,CAAA,EACdC,iBAAkBT,GAA+B,EACjD,GAAG5K,IAIPE,kBACErM,IAEO,CACLyX,iBAAkB,QAClBC,sBAAuB,MACvBC,qBAAsB1b,GAAiB,eAAgB+D,CAAK,EAC5D4X,yBAA0B3b,GAAiB,mBAAoB+D,CAAK,IAIxEe,aAAcA,CACZb,EACAF,IACS,CACTE,EAAO2X,QAAU,IAAM,CAAA,IAAAC,EAAA3W,EAAA4W,EACrB,IAAMC,EAAahY,EAAM4D,SAAQ,EAAG2T,aAAarX,EAAOQ,EAAE,EAE1D,OAAO7B,KAAKW,IACVX,KAAKU,KAAGuY,EACN5X,EAAOc,UAAU4V,UAAOkB,KAAAA,EAAInB,GAAoBC,SAAOzV,EACvD6W,GAAc9X,EAAOc,UAAUwP,OAAI,KAAArP,EAAIwV,GAAoBnG,IAC7D,GAACuH,EACD7X,EAAOc,UAAU6V,UAAOkB,KAAAA,EAAIpB,GAAoBE,OAClD,GAGF3W,EAAO+X,SAAWta,EAChB8V,GAAY,CACVA,EACAC,GAAuB1T,EAAOyT,CAAQ,EACtCzT,EAAM4D,SAAQ,EAAG2T,YAAY,EAE/B,CAAC9D,EAAUxR,IACTA,EACGiW,MAAM,EAAGhY,EAAOsT,SAASC,CAAQ,CAAC,EAClCtK,OAAO,CAACgG,EAAKjP,IAAWiP,EAAMjP,EAAO2X,QAAO,EAAI,CAAC,EACtDpY,EAAeO,EAAMQ,QAAS,eAAgB,UAAU,CAC1D,EAEAN,EAAOiY,SAAWxa,EAChB8V,GAAY,CACVA,EACAC,GAAuB1T,EAAOyT,CAAQ,EACtCzT,EAAM4D,SAAQ,EAAG2T,YAAY,EAE/B,CAAC9D,EAAUxR,IACTA,EACGiW,MAAMhY,EAAOsT,SAASC,CAAQ,EAAI,CAAC,EACnCtK,OAAO,CAACgG,EAAKjP,IAAWiP,EAAMjP,EAAO2X,QAAO,EAAI,CAAC,EACtDpY,EAAeO,EAAMQ,QAAS,eAAgB,UAAU,CAC1D,EAEAN,EAAOkY,UAAY,IAAM,CACvBpY,EAAMqY,gBAAgBC,GAAiC,CAAA,GAAhC,CAAE,CAACpY,EAAOQ,EAAE,EAAG6X,EAAG,GAAGC,CAAK,EAACF,EAChD,OAAOE,CACT,CAAC,GAEHtY,EAAOuY,aAAe,IAAM,CAAA,IAAAvL,EAAAC,EAC1B,QACED,EAAChN,EAAOc,UAAU0X,iBAAcxL,KAAAA,EAAI,OAAIC,EACvCnN,EAAMQ,QAAQmY,uBAAoBxL,KAAAA,EAAI,KAG3CjN,EAAO0Y,cAAgB,IACd5Y,EAAM4D,SAAQ,EAAG4T,iBAAiBJ,mBAAqBlX,EAAOQ,IAIzEgC,aAAcA,CACZhB,EACA1B,IACS,CACT0B,EAAOmW,QAAU,IAAM,CACrB,IAAI1I,EAAM,EAEJ/R,EAAWsE,GAAkC,CACjD,GAAIA,EAAOoB,WAAWpF,OACpBgE,EAAOoB,WAAWxF,QAAQF,CAAO,MAC5B,CAAA,IAAAyb,EACL1J,IAAG0J,EAAInX,EAAOxB,OAAO2X,QAAO,IAAEgB,KAAAA,EAAI,CACpC,GAGFzb,OAAAA,EAAQsE,CAAM,EAEPyN,GAETzN,EAAOuW,SAAW,IAAM,CACtB,GAAIvW,EAAOjD,MAAQ,EAAG,CACpB,IAAMqa,EAAoBpX,EAAOuB,YAAYsC,QAAQ7D,EAAOjD,MAAQ,CAAC,EACrE,OAAOqa,EAAkBb,SAAQ,EAAKa,EAAkBjB,QAAO,CACjE,CAEA,MAAO,IAETnW,EAAOqX,iBAAmBC,GAAoB,CAC5C,IAAM9Y,EAASF,EAAMqI,UAAU3G,EAAOxB,OAAOQ,EAAE,EACzCuY,EAAY/Y,GAAQuY,aAAY,EAEtC,OAAQS,GAAe,CAOrB,GANI,CAAChZ,GAAU,CAAC+Y,IAIdC,EAAUC,SAAO,MAAjBD,EAAUC,QAAO,EAEfC,GAAkBF,CAAC,GAEjBA,EAAEG,SAAWH,EAAEG,QAAQ3b,OAAS,GAClC,OAIJ,IAAMuZ,EAAYvV,EAAOmW,QAAO,EAE1BR,EAAwC3V,EAC1CA,EAAOwB,eAAc,EAAGI,IAAI7G,GAAK,CAACA,EAAEyD,OAAOQ,GAAIjE,EAAEyD,OAAO2X,QAAO,CAAE,CAAC,EAClE,CAAC,CAAC3X,EAAOQ,GAAIR,EAAO2X,QAAO,CAAE,CAAC,EAE5ByB,EAAUF,GAAkBF,CAAC,EAC/Bra,KAAKC,MAAMoa,EAAEG,QAAQ,CAAC,EAAGC,OAAO,EAC/BJ,EAAiBI,QAEhBC,EAAqC,CAAA,EAErCC,EAAeA,CACnBC,EACAC,IACG,CACC,OAAOA,GAAe,WAI1B1Z,EAAM2Z,oBAAoBrd,GAAO,CAAA,IAAAsd,EAAAC,EAC/B,IAAMC,EACJ9Z,EAAMQ,QAAQkX,wBAA0B,MAAQ,GAAK,EACjDR,GACHwC,IAAUE,EAAItd,GAAK0a,cAAW4C,KAAAA,EAAI,IAAME,EACrC3C,EAAkBtY,KAAKU,IAC3B2X,IAAW2C,EAAIvd,GAAK2a,YAAS,KAAA4C,EAAI,GACjC,QACF,EAEAvd,OAAAA,EAAI+a,kBAAkB/Z,QAAQyc,GAA4B,CAAA,GAA3B,CAAC5Z,EAAU6Z,CAAU,EAACD,EACnDR,EAAgBpZ,CAAQ,EACtBtB,KAAKC,MACHD,KAAKU,IAAIya,EAAaA,EAAa7C,EAAiB,CAAC,EAAI,GAC3D,EAAI,GACR,CAAC,EAEM,CACL,GAAG7a,EACH4a,YAAAA,EACAC,gBAAAA,EAEJ,CAAC,GAGCnX,EAAMQ,QAAQiX,mBAAqB,YACnCgC,IAAc,QAEdzZ,EAAMqY,gBAAgB/b,IAAQ,CAC5B,GAAGA,EACH,GAAGid,CACL,EAAE,IAIAU,EAAUP,GAAwBF,EAAa,OAAQE,CAAU,EAEjEQ,EAASR,GAAwB,CACrCF,EAAa,MAAOE,CAAU,EAE9B1Z,EAAM2Z,oBAAoBrd,IAAQ,CAChC,GAAGA,EACH8a,iBAAkB,GAClBJ,YAAa,KACbC,UAAW,KACXC,YAAa,KACbC,gBAAiB,KACjBE,kBAAmB,CAAA,CACrB,EAAE,GAGE8C,EACJnB,GAAoB,OAAOoB,SAAa,IAAcA,SAAW,KAE7DC,EAAc,CAClBC,YAAcpB,GAAkBe,EAAOf,EAAEI,OAAO,EAChDiB,UAAYrB,GAAkB,CAC5BiB,GAAiBK,oBACf,YACAH,EAAYC,WACd,EACAH,GAAiBK,oBACf,UACAH,EAAYE,SACd,EACAL,EAAMhB,EAAEI,OAAO,CACjB,GAGImB,EAAc,CAClBH,YAAcpB,IACRA,EAAEwB,aACJxB,EAAEyB,eAAc,EAChBzB,EAAE0B,gBAAe,GAEnBX,EAAOf,EAAEG,QAAQ,CAAC,EAAGC,OAAO,EACrB,IAETiB,UAAYrB,GAAkB,CAAA,IAAA2B,EAC5BV,GAAiBK,oBACf,YACAC,EAAYH,WACd,EACAH,GAAiBK,oBACf,WACAC,EAAYF,SACd,EACIrB,EAAEwB,aACJxB,EAAEyB,eAAc,EAChBzB,EAAE0B,gBAAe,GAEnBV,GAAKW,EAAC3B,EAAEG,QAAQ,CAAC,IAAC,KAAA,OAAZwB,EAAcvB,OAAO,CAC7B,GAGIwB,EAAqBC,GAAqB,EAC5C,CAAEC,QAAS,EAAM,EACjB,GAEA5B,GAAkBF,CAAC,GACrBiB,GAAiBc,iBACf,YACAR,EAAYH,YACZQ,CACF,EACAX,GAAiBc,iBACf,WACAR,EAAYF,UACZO,CACF,IAEAX,GAAiBc,iBACf,YACAZ,EAAYC,YACZQ,CACF,EACAX,GAAiBc,iBACf,UACAZ,EAAYE,UACZO,CACF,GAGF9a,EAAM2Z,oBAAoBrd,IAAQ,CAChC,GAAGA,EACH0a,YAAasC,EACbrC,UAAAA,EACAC,YAAa,EACbC,gBAAiB,EACjBE,kBAAAA,EACAD,iBAAkBlX,EAAOQ,EAC3B,EAAE,KAKR8C,YAAqCxD,GAA8B,CACjEA,EAAMqY,gBAAkBjc,GACtB4D,EAAMQ,QAAQmX,sBAAoB,KAAA,OAAlC3X,EAAMQ,QAAQmX,qBAAuBvb,CAAO,EAC9C4D,EAAM2Z,oBAAsBvd,GAC1B4D,EAAMQ,QAAQoX,0BAAwB,KAAA,OAAtC5X,EAAMQ,QAAQoX,yBAA2Bxb,CAAO,EAClD4D,EAAMkb,kBAAoBtM,GAAgB,CAAA,IAAAC,EACxC7O,EAAMqY,gBACJzJ,EAAe,CAAA,GAAEC,EAAG7O,EAAM+O,aAAawI,eAAY,KAAA1I,EAAI,CAAA,CACzD,GAEF7O,EAAMmb,oBAAsBvM,GAAgB,CAAA,IAAAwM,EAC1Cpb,EAAM2Z,oBACJ/K,EACImI,GAA+B,GAAEqE,EACjCpb,EAAM+O,aAAayI,mBAAgB,KAAA4D,EACjCrE,GAA+B,CACvC,GAEF/W,EAAMqb,aAAe,IAAA,CAAA,IAAAC,EAAAC,EAAA,OAAAD,GAAAC,EACnBvb,EAAMyD,gBAAe,EAAG,CAAC,IAAzB8X,KAAAA,OAAAA,EAA4BhW,QAAQ4D,OAAO,CAACgG,EAAKzN,IACxCyN,EAAMzN,EAAOmW,QAAO,EAC1B,CAAC,IAACyD,KAAAA,EAAI,CAAC,EACZtb,EAAMwb,iBAAmB,IAAA,CAAA,IAAAC,EAAAC,EAAA,OAAAD,GAAAC,EACvB1b,EAAM2E,oBAAmB,EAAG,CAAC,IAA7B+W,KAAAA,OAAAA,EAAgCnW,QAAQ4D,OAAO,CAACgG,EAAKzN,IAC5CyN,EAAMzN,EAAOmW,QAAO,EAC1B,CAAC,IAAC4D,KAAAA,EAAI,CAAC,EACZzb,EAAM2b,mBAAqB,IAAA,CAAA,IAAAC,EAAAC,EAAA,OAAAD,GAAAC,EACzB7b,EAAM0E,sBAAqB,EAAG,CAAC,IAA/BmX,KAAAA,OAAAA,EAAkCtW,QAAQ4D,OAAO,CAACgG,EAAKzN,IAC9CyN,EAAMzN,EAAOmW,QAAO,EAC1B,CAAC,IAAC+D,KAAAA,EAAI,CAAC,EACZ5b,EAAM8b,kBAAoB,IAAA,CAAA,IAAAC,EAAAC,EAAA,OAAAD,GAAAC,EACxBhc,EAAM8E,qBAAoB,EAAG,CAAC,IAA9BkX,KAAAA,OAAAA,EAAiCzW,QAAQ4D,OAAO,CAACgG,EAAKzN,IAC7CyN,EAAMzN,EAAOmW,QAAO,EAC1B,CAAC,IAACkE,KAAAA,EAAI,CAAC,CACd,CACF,EAEIE,GAAmC,KAChC,SAASlB,IAAwB,CACtC,GAAI,OAAOkB,IAAqB,UAAW,OAAOA,GAElD,IAAIC,EAAY,GAChB,GAAI,CACF,IAAM1b,EAAU,CACd,IAAIwa,SAAU,CACZkB,OAAAA,EAAY,GACL,EACT,GAGIC,EAAOA,IAAM,CAAA,EAEnBC,OAAOnB,iBAAiB,OAAQkB,EAAM3b,CAAO,EAC7C4b,OAAO5B,oBAAoB,OAAQ2B,CAAI,OAC3B,CACZD,EAAY,EACd,CACAD,OAAAA,GAAmBC,EACZD,EACT,CAEA,SAAS7C,GAAkBF,EAA6B,CACtD,OAAQA,EAAiBmD,OAAS,YACpC,CC3aO,IAAMC,GAAiC,CAC5CpQ,gBAAkBC,IACT,CACLoQ,iBAAkB,CAAA,EAClB,GAAGpQ,IAIPE,kBACErM,IAEO,CACLwc,yBAA0BvgB,GAAiB,mBAAoB+D,CAAK,IAIxEe,aAAcA,CACZb,EACAF,IACS,CACTE,EAAOuc,iBAAmB5P,GAAS,CAC7B3M,EAAOwc,WAAU,GACnB1c,EAAM2c,oBAAoBrgB,IAAQ,CAChC,GAAGA,EACH,CAAC4D,EAAOQ,EAAE,EAAGmM,GAAS,CAAC3M,EAAO6G,aAAY,CAC5C,EAAE,GAGN7G,EAAO6G,aAAe,IAAM,CAAA,IAAA5F,EAAAwM,EAC1B,IAAMiP,EAAe1c,EAAO+B,QAC5B,OAAAd,EACGyb,EAAalf,OACVkf,EAAare,KAAKse,GAAKA,EAAE9V,aAAY,CAAE,GAAC4G,EACxC3N,EAAM4D,SAAQ,EAAG2Y,mBAAgB,KAAA,OAAjC5O,EAAoCzN,EAAOQ,EAAE,IAACS,KAAAA,EAAK,IAI3DjB,EAAOwc,WAAa,IAAM,CAAA,IAAAxP,EAAAC,EACxB,QACED,EAAChN,EAAOc,UAAU8b,eAAY5P,KAAAA,EAAI,OAAIC,EACrCnN,EAAMQ,QAAQsc,eAAY3P,KAAAA,EAAI,KAGnCjN,EAAO6c,2BAA6B,IAC1B7D,GAAe,CACrBhZ,EAAOuc,kBAAPvc,MAAAA,EAAOuc,iBACHvD,EAAiB8D,OAA4BC,OACjD,IAKNpV,UAAWA,CACT5H,EACAD,IACS,CACTC,EAAI6V,oBAAsBnY,EACxB,IAAM,CAACsC,EAAI8I,YAAW,EAAI/I,EAAM4D,SAAQ,EAAG2Y,gBAAgB,EAC3DW,GACSA,EAAM7Y,OAAO/D,GAAQA,EAAKJ,OAAO6G,aAAY,CAAE,EAExDtH,EAAeO,EAAMQ,QAAS,YAAa,qBAAqB,CAClE,EACAP,EAAIkd,gBAAkBxf,EACpB,IAAM,CACJsC,EAAI+V,oBAAmB,EACvB/V,EAAI4V,sBAAqB,EACzB5V,EAAIgW,qBAAoB,CAAE,EAE5B,CAACnS,EAAMoC,EAAQnC,IAAU,CAAC,GAAGD,EAAM,GAAGoC,EAAQ,GAAGnC,CAAK,EACtDtE,EAAeO,EAAMQ,QAAS,YAAa,iBAAiB,CAC9D,GAGFgD,YAAqCxD,GAA8B,CACjE,IAAMod,EAA2BA,CAC/BlhB,EACAmhB,IAEO1f,EACL,IAAM,CACJ0f,EAAU,EACVA,EAAU,EACPhZ,OAAO5H,GAAKA,EAAEsK,aAAY,CAAE,EAC5BzD,IAAI7G,GAAKA,EAAEiE,EAAE,EACbwG,KAAK,GAAG,CAAC,EAEdjF,GACSA,EAAQoC,OAAO5H,GAAKA,EAAEsK,cAAY,KAAA,OAAdtK,EAAEsK,aAAY,CAAI,EAE/CtH,EAAeO,EAAMQ,QAAS,eAAgBtE,CAAG,CACnD,EAGF8D,EAAMsd,sBAAwBF,EAC5B,wBACA,IAAMpd,EAAMud,kBAAiB,CAC/B,EACAvd,EAAM2D,sBAAwByZ,EAC5B,wBACA,IAAMpd,EAAMgJ,kBAAiB,CAC/B,EACAhJ,EAAMwd,0BAA4BJ,EAChC,4BACA,IAAMpd,EAAMwW,mBAAkB,CAChC,EACAxW,EAAMyd,2BAA6BL,EACjC,6BACA,IAAMpd,EAAMyW,oBAAmB,CACjC,EACAzW,EAAM0d,4BAA8BN,EAClC,8BACA,IAAMpd,EAAM0W,qBAAoB,CAClC,EAEA1W,EAAM2c,oBAAsBvgB,GAC1B4D,EAAMQ,QAAQgc,0BAAwB,KAAA,OAAtCxc,EAAMQ,QAAQgc,yBAA2BpgB,CAAO,EAElD4D,EAAM2d,sBAAwB/O,GAAgB,CAAA,IAAAC,EAC5C7O,EAAM2c,oBACJ/N,EAAe,CAAA,GAAEC,EAAG7O,EAAM+O,aAAawN,mBAAgB,KAAA1N,EAAI,CAAA,CAC7D,GAGF7O,EAAM4d,wBAA0B/Q,GAAS,CAAA,IAAAgR,EACvChR,GAAKgR,EAAGhR,IAAKgR,KAAAA,EAAI,CAAC7d,EAAM8d,uBAAsB,EAE9C9d,EAAM2c,oBACJ3c,EAAMgJ,kBAAiB,EAAGG,OACxB,CAAC4U,EAAK7d,KAAY,CAChB,GAAG6d,EACH,CAAC7d,EAAOQ,EAAE,EAAImM,GAAQ,EAAC3M,EAAOwc,YAAPxc,MAAAA,EAAOwc,WAAU,EAC1C,GACA,CAAA,CACF,CACF,GAGF1c,EAAM8d,uBAAyB,IAC7B,CAAC9d,EAAMgJ,kBAAiB,EAAGzK,KAAK2B,GAAU,EAACA,EAAO6G,cAAP7G,MAAAA,EAAO6G,aAAY,EAAK,EAErE/G,EAAMge,wBAA0B,IAC9Bhe,EAAMgJ,kBAAiB,EAAGzK,KAAK2B,GAAUA,EAAO6G,cAAY,KAAA,OAAnB7G,EAAO6G,aAAY,CAAI,EAElE/G,EAAMie,qCAAuC,IACnC/E,GAAe,CAAA,IAAAgF,EACrBle,EAAM4d,yBAAuBM,EACzBhF,EAAiB8D,SAAnBkB,KAAAA,OAAAA,EAAgDjB,OAClD,EAGN,CACF,EAEO,SAASvJ,GACd1T,EACAyT,EACA,CACA,OAAQA,EAEJA,IAAa,SACXzT,EAAM0d,4BAA2B,EACjCjK,IAAa,OACXzT,EAAMwd,0BAAyB,EAC/Bxd,EAAMyd,2BAA0B,EALpCzd,EAAM2D,sBAAqB,CAMjC,CC/RO,IAAMwa,GAA+B,CAC1C3a,YAAqCxD,GAA8B,CACjEA,EAAMoe,0BACJpe,EAAMQ,QAAQgJ,oBACdxJ,EAAMQ,QAAQgJ,mBAAmBxJ,EAAO,YAAY,EAEtDA,EAAMqe,yBAA2B,IAC3Bre,EAAMQ,QAAQ0O,iBAAmB,CAAClP,EAAMoe,0BACnCpe,EAAMyJ,uBAAsB,EAG9BzJ,EAAMoe,0BAAyB,EAGxCpe,EAAMse,8BACJte,EAAMQ,QAAQmJ,wBACd3J,EAAMQ,QAAQmJ,uBAAuB3J,EAAO,YAAY,EAC1DA,EAAMue,6BAA+B,IAC9Bve,EAAMse,8BAIJte,EAAMse,8BAA6B,EAHjC,IAAI1U,IAMf5J,EAAMwe,8BACJxe,EAAMQ,QAAQsJ,wBACd9J,EAAMQ,QAAQsJ,uBAAuB9J,EAAO,YAAY,EAC1DA,EAAMye,6BAA+B,IAAM,CACzC,GAAKze,EAAMwe,8BAIX,OAAOxe,EAAMwe,8BAA6B,EAE9C,CACF,EC8BaE,GAAgC,CAC3CxS,gBAAkBC,IACT,CACLwS,aAAcld,OACd,GAAG0K,IAIPE,kBACErM,IAEO,CACL4e,qBAAsB3iB,GAAiB,eAAgB+D,CAAK,EAC5D6e,eAAgB,OAChBC,yBAA0B5e,GAAU,CAAA,IAAA6e,EAClC,IAAMlS,GAAKkS,EAAG/e,EACX2M,gBAAe,EACfC,SAAS,CAAC,IAACmS,OAAAA,EAFAA,EAEE9V,uBAAsB,EACnC/I,EAAOQ,EAAE,IAHEqe,KAAAA,OAAAA,EAGCxe,SAAQ,EAEvB,OAAO,OAAOsM,GAAU,UAAY,OAAOA,GAAU,QACvD,IAIJ9L,aAAcA,CACZb,EACAF,IACS,CACTE,EAAO8e,mBAAqB,IAAM,CAAA,IAAA9R,EAAAC,EAAAC,EAAA6R,EAChC,QACE/R,EAAChN,EAAOc,UAAUke,qBAAkBhS,KAAAA,EAAI,OAAIC,EAC3CnN,EAAMQ,QAAQ0e,qBAAkB,KAAA/R,EAAI,OAAKC,EACzCpN,EAAMQ,QAAQ+M,gBAAa,KAAAH,EAAI,OAAK6R,EACpCjf,EAAMQ,QAAQse,0BAAwB,KAAA,OAAtC9e,EAAMQ,QAAQse,yBAA2B5e,CAAM,IAAC,KAAA+e,EAAI,KACrD,CAAC,CAAC/e,EAAOyB,aAKf6B,YAAqCxD,GAA8B,CACjEA,EAAMmf,sBAAwB,IACrBrT,GAAU/B,eAGnB/J,EAAMof,kBAAoB,IAAM,CAAA,IAAArS,EAAAC,EAC9B,GAAM,CAAE6R,eAAgBA,GAAmB7e,EAAMQ,QAEjD,OAAOhE,GAAWqiB,CAAc,EAC5BA,EACAA,IAAmB,OACjB7e,EAAMmf,sBAAqB,GAAEpS,GAAAC,EAC7BhN,EAAMQ,QAAQsL,YAAdkB,KAAAA,OAAAA,EAA0B6R,CAAc,IAAW9R,KAAAA,EACnDjB,GAAU+S,CAAc,GAGhC7e,EAAMqf,gBAAkBjjB,GAAW,CACjC4D,EAAMQ,QAAQoe,sBAAd5e,MAAAA,EAAMQ,QAAQoe,qBAAuBxiB,CAAO,GAG9C4D,EAAMsf,kBAAoB1Q,GAAgB,CACxC5O,EAAMqf,gBACJzQ,EAAenN,OAAYzB,EAAM+O,aAAa4P,YAChD,EAEJ,CACF,ECOaY,GAA6B,CACxCrT,gBAAkBC,IACT,CACLqT,SAAU,CAAA,EACV,GAAGrT,IAIPE,kBACErM,IAEO,CACLyf,iBAAkBxjB,GAAiB,WAAY+D,CAAK,EACpD0f,qBAAsB,KAI1Blc,YAAqCxD,GAA8B,CACjE,IAAI2f,EAAa,GACbC,EAAS,GAEb5f,EAAM6f,mBAAqB,IAAM,CAAA,IAAA1e,EAAA2e,EAC/B,GAAI,CAACH,EAAY,CACf3f,EAAM+f,OAAO,IAAM,CACjBJ,EAAa,EACf,CAAC,EACD,MACF,CAEA,IAAAxe,GAAA2e,EACE9f,EAAMQ,QAAQwf,eAAYF,KAAAA,EAC1B9f,EAAMQ,QAAQyf,oBAAiB,KAAA9e,EAC/B,CAACnB,EAAMQ,QAAQ0f,gBACf,CACA,GAAIN,EAAQ,OACZA,EAAS,GACT5f,EAAM+f,OAAO,IAAM,CACjB/f,EAAMmgB,cAAa,EACnBP,EAAS,EACX,CAAC,CACH,GAEF5f,EAAMogB,YAAchkB,GAAW4D,EAAMQ,QAAQif,kBAAgB,KAAA,OAA9Bzf,EAAMQ,QAAQif,iBAAmBrjB,CAAO,EACvE4D,EAAMqgB,sBAAwBb,GAAY,CACpCA,GAAY,CAACxf,EAAMsgB,qBAAoB,EACzCtgB,EAAMogB,YAAY,EAAI,EAEtBpgB,EAAMogB,YAAY,CAAA,CAAE,GAGxBpgB,EAAMmgB,cAAgBvR,GAAgB,CAAA,IAAA2R,EAAAzR,EACpC9O,EAAMogB,YAAYxR,EAAe,CAAA,GAAE2R,GAAAzR,EAAG9O,EAAM+O,eAAND,KAAAA,OAAAA,EAAoB0Q,WAAQ,KAAAe,EAAI,CAAA,CAAE,GAE1EvgB,EAAMwgB,qBAAuB,IACpBxgB,EACJygB,yBAAwB,EACxB7T,SAASrO,KAAK0B,GAAOA,EAAIygB,aAAY,CAAE,EAE5C1gB,EAAM2gB,gCAAkC,IAC9BzH,GAAe,CACnBA,EAAUC,SAAO,MAAjBD,EAAUC,QAAO,EACnBnZ,EAAMqgB,sBAAqB,GAG/BrgB,EAAM4gB,sBAAwB,IAAM,CAClC,IAAMpB,EAAWxf,EAAM4D,SAAQ,EAAG4b,SAClC,OAAOA,IAAa,IAAQvN,OAAOpC,OAAO2P,CAAQ,EAAEjhB,KAAK+F,OAAO,GAElEtE,EAAMsgB,qBAAuB,IAAM,CACjC,IAAMd,EAAWxf,EAAM4D,SAAQ,EAAG4b,SAGlC,OAAI,OAAOA,GAAa,UACfA,IAAa,GAGlB,GAACvN,OAAO4O,KAAKrB,CAAQ,EAAE9hB,QAKvBsC,EAAM8gB,YAAW,EAAGlU,SAASrO,KAAK0B,GAAO,CAACA,EAAI8gB,cAAa,CAAE,IAOnE/gB,EAAMghB,iBAAmB,IAAM,CAC7B,IAAIna,EAAW,EAOfoa,OAJEjhB,EAAM4D,SAAQ,EAAG4b,WAAa,GAC1BvN,OAAO4O,KAAK7gB,EAAM8gB,YAAW,EAAGI,QAAQ,EACxCjP,OAAO4O,KAAK7gB,EAAM4D,SAAQ,EAAG4b,QAAQ,GAEpCliB,QAAQoD,GAAM,CACnB,IAAMygB,EAAUzgB,EAAGoB,MAAM,GAAG,EAC5B+E,EAAWhI,KAAKU,IAAIsH,EAAUsa,EAAQzjB,MAAM,CAC9C,CAAC,EAEMmJ,GAET7G,EAAMohB,uBAAyB,IAAMphB,EAAMqhB,kBAAiB,EAC5DrhB,EAAMshB,oBAAsB,KACtB,CAACthB,EAAMuhB,sBAAwBvhB,EAAMQ,QAAQ8gB,sBAC/CthB,EAAMuhB,qBAAuBvhB,EAAMQ,QAAQ8gB,oBAAoBthB,CAAK,GAGlEA,EAAMQ,QAAQ0f,iBAAmB,CAAClgB,EAAMuhB,qBACnCvhB,EAAMohB,uBAAsB,EAG9BphB,EAAMuhB,qBAAoB,IAIrC1Z,UAAWA,CACT5H,EACAD,IACS,CACTC,EAAIuhB,eAAiBhC,GAAY,CAC/Bxf,EAAMogB,YAAY9jB,GAAO,CAAA,IAAAmlB,EACvB,IAAMC,EAASplB,IAAQ,GAAO,GAAO,CAAC,EAACA,GAAAA,MAAAA,EAAM2D,EAAIS,EAAE,GAE/CihB,EAAiC,CAAA,EAYrC,GAVIrlB,IAAQ,GACV2V,OAAO4O,KAAK7gB,EAAM8gB,YAAW,EAAGI,QAAQ,EAAE5jB,QAAQskB,GAAS,CACzDD,EAAYC,CAAK,EAAI,EACvB,CAAC,EAEDD,EAAcrlB,EAGhBkjB,GAAQiC,EAAGjC,IAAQ,KAAAiC,EAAI,CAACC,EAEpB,CAACA,GAAUlC,EACb,MAAO,CACL,GAAGmC,EACH,CAAC1hB,EAAIS,EAAE,EAAG,IAId,GAAIghB,GAAU,CAAClC,EAAU,CACvB,GAAM,CAAE,CAACvf,EAAIS,EAAE,EAAG6X,EAAG,GAAGC,CAAK,EAAImJ,EACjC,OAAOnJ,CACT,CAEA,OAAOlc,CACT,CAAC,GAEH2D,EAAI8gB,cAAgB,IAAM,CAAA,IAAAc,EACxB,IAAMrC,EAAWxf,EAAM4D,SAAQ,EAAG4b,SAElC,MAAO,CAAC,GAAAqC,EACN7hB,EAAMQ,QAAQshB,kBAAd9hB,KAAAA,OAAAA,EAAMQ,QAAQshB,iBAAmB7hB,CAAG,IAAC4hB,KAAAA,EACpCrC,IAAa,IAAQA,IAAWvf,EAAIS,EAAE,IAG3CT,EAAIygB,aAAe,IAAM,CAAA,IAAAqB,EAAA5U,EAAA8F,EACvB,OAAA8O,EACE/hB,EAAMQ,QAAQwhB,iBAAdhiB,KAAAA,OAAAA,EAAMQ,QAAQwhB,gBAAkB/hB,CAAG,IAAC8hB,KAAAA,IACnC5U,EAACnN,EAAMQ,QAAQyhB,kBAAe9U,KAAAA,EAAI,KAAS,CAAC,GAAA8F,EAAChT,EAAI+H,UAAJiL,MAAAA,EAAavV,SAG/DuC,EAAIiiB,wBAA0B,IAAM,CAClC,IAAIC,EAAkB,GAClBtZ,EAAa5I,EAEjB,KAAOkiB,GAAmBtZ,EAAWZ,UACnCY,EAAa7I,EAAM0I,OAAOG,EAAWZ,SAAU,EAAI,EACnDka,EAAkBtZ,EAAWkY,cAAa,EAG5C,OAAOoB,GAETliB,EAAImiB,yBAA2B,IAAM,CACnC,IAAMC,EAAYpiB,EAAIygB,aAAY,EAElC,MAAO,IAAM,CACN2B,GACLpiB,EAAIuhB,eAAc,GAGxB,CACF,ECxKMc,GAAmB,EACnBC,GAAkB,GAElBC,GAA4BA,KAAwB,CACxDC,UAAWH,GACXI,SAAUH,EACZ,GAEaI,GAA8B,CACzCzW,gBAAkBC,IACT,CACL,GAAGA,EACHyW,WAAY,CACV,GAAGJ,GAAyB,EAC5B,GAAGrW,GAAOyW,UACZ,IAIJvW,kBACErM,IAEO,CACL6iB,mBAAoB5mB,GAAiB,aAAc+D,CAAK,IAI5DwD,YAAqCxD,GAA8B,CACjE,IAAI2f,EAAa,GACbC,EAAS,GAEb5f,EAAM8iB,oBAAsB,IAAM,CAAA,IAAA3hB,EAAA2e,EAChC,GAAI,CAACH,EAAY,CACf3f,EAAM+f,OAAO,IAAM,CACjBJ,EAAa,EACf,CAAC,EACD,MACF,CAEA,IAAAxe,GAAA2e,EACE9f,EAAMQ,QAAQwf,eAAYF,KAAAA,EAC1B9f,EAAMQ,QAAQuiB,qBAAkB,KAAA5hB,EAChC,CAACnB,EAAMQ,QAAQwiB,iBACf,CACA,GAAIpD,EAAQ,OACZA,EAAS,GACT5f,EAAM+f,OAAO,IAAM,CACjB/f,EAAMijB,eAAc,EACpBrD,EAAS,EACX,CAAC,CACH,GAEF5f,EAAMkjB,cAAgB9mB,GAAW,CAC/B,IAAM+mB,EAAwC7mB,GAC7BC,GAAiBH,EAASE,CAAG,EAK9C,OAAO0D,EAAMQ,QAAQqiB,oBAAkB,KAAA,OAAhC7iB,EAAMQ,QAAQqiB,mBAAqBM,CAAW,GAEvDnjB,EAAMojB,gBAAkBxU,GAAgB,CAAA,IAAAyU,EACtCrjB,EAAMkjB,cACJtU,EACI4T,GAAyB,GAAEa,EAC3BrjB,EAAM+O,aAAa6T,aAAU,KAAAS,EAAIb,GAAyB,CAChE,GAEFxiB,EAAMsjB,aAAelnB,GAAW,CAC9B4D,EAAMkjB,cAAc5mB,GAAO,CACzB,IAAImmB,EAAYlmB,GAAiBH,EAASE,EAAImmB,SAAS,EAEjDc,EACJ,OAAOvjB,EAAMQ,QAAQgjB,UAAc,KACnCxjB,EAAMQ,QAAQgjB,YAAc,GACxB9X,OAAOoL,iBACP9W,EAAMQ,QAAQgjB,UAAY,EAEhCf,OAAAA,EAAY5jB,KAAKU,IAAI,EAAGV,KAAKW,IAAIijB,EAAWc,CAAY,CAAC,EAElD,CACL,GAAGjnB,EACHmmB,UAAAA,EAEJ,CAAC,GAEHziB,EAAMijB,eAAiBrU,GAAgB,CAAA,IAAA6U,EAAA3U,EACrC9O,EAAMsjB,aACJ1U,EACI0T,IAAgBmB,GAAA3U,EAChB9O,EAAM+O,eAAYD,OAAAA,EAAlBA,EAAoB8T,aAApB9T,KAAAA,OAAAA,EAAgC2T,YAASgB,KAAAA,EAAInB,EACnD,GAEFtiB,EAAM0jB,cAAgB9U,GAAgB,CAAA,IAAA+U,EAAAC,EACpC5jB,EAAM6jB,YACJjV,EACI2T,IAAeoB,GAAAC,EACf5jB,EAAM+O,eAAY6U,OAAAA,EAAlBA,EAAoBhB,aAApBgB,KAAAA,OAAAA,EAAgClB,WAAQiB,KAAAA,EAAIpB,EAClD,GAEFviB,EAAM6jB,YAAcznB,GAAW,CAC7B4D,EAAMkjB,cAAc5mB,GAAO,CACzB,IAAMomB,EAAW7jB,KAAKU,IAAI,EAAGhD,GAAiBH,EAASE,EAAIomB,QAAQ,CAAC,EAC9DoB,EAAcxnB,EAAIomB,SAAWpmB,EAAImmB,UACjCA,EAAY5jB,KAAKkR,MAAM+T,EAAcpB,CAAQ,EAEnD,MAAO,CACL,GAAGpmB,EACHmmB,UAAAA,EACAC,SAAAA,EAEJ,CAAC,GAGH1iB,EAAM+jB,aAAe3nB,GACnB4D,EAAMkjB,cAAc5mB,GAAO,CAAA,IAAA0nB,EACzB,IAAIC,EAAe1nB,GACjBH,GAAO4nB,EACPhkB,EAAMQ,QAAQgjB,YAAS,KAAAQ,EAAI,EAC7B,EAEA,OAAI,OAAOC,GAAiB,WAC1BA,EAAeplB,KAAKU,IAAI,GAAI0kB,CAAY,GAGnC,CACL,GAAG3nB,EACHknB,UAAWS,EAEf,CAAC,EAEHjkB,EAAMkkB,eAAiBvmB,EACrB,IAAM,CAACqC,EAAMmkB,aAAY,CAAE,EAC3BX,GAAa,CACX,IAAIY,EAAwB,CAAA,EAC5B,OAAIZ,GAAaA,EAAY,IAC3BY,EAAc,CAAC,GAAG,IAAIxnB,MAAM4mB,CAAS,CAAC,EAAEa,KAAK,IAAI,EAAE/gB,IAAI,CAACiV,EAAGlP,IAAMA,CAAC,GAE7D+a,GAET3kB,EAAeO,EAAMQ,QAAS,aAAc,gBAAgB,CAC9D,EAEAR,EAAMskB,mBAAqB,IAAMtkB,EAAM4D,SAAQ,EAAGgf,WAAWH,UAAY,EAEzEziB,EAAMukB,eAAiB,IAAM,CAC3B,GAAM,CAAE9B,UAAAA,CAAU,EAAIziB,EAAM4D,SAAQ,EAAGgf,WAEjCY,EAAYxjB,EAAMmkB,aAAY,EAEpC,OAAIX,IAAc,GACT,GAGLA,IAAc,EACT,GAGFf,EAAYe,EAAY,GAGjCxjB,EAAMwkB,aAAe,IACZxkB,EAAMsjB,aAAahnB,GAAOA,EAAM,CAAC,EAG1C0D,EAAMykB,SAAW,IACRzkB,EAAMsjB,aAAahnB,GACjBA,EAAM,CACd,EAGH0D,EAAM0kB,UAAY,IACT1kB,EAAMsjB,aAAa,CAAC,EAG7BtjB,EAAM2kB,SAAW,IACR3kB,EAAMsjB,aAAatjB,EAAMmkB,aAAY,EAAK,CAAC,EAGpDnkB,EAAMygB,yBAA2B,IAAMzgB,EAAMshB,oBAAmB,EAChEthB,EAAM4kB,sBAAwB,KAE1B,CAAC5kB,EAAM6kB,wBACP7kB,EAAMQ,QAAQokB,wBAEd5kB,EAAM6kB,uBACJ7kB,EAAMQ,QAAQokB,sBAAsB5kB,CAAK,GAGzCA,EAAMQ,QAAQwiB,kBAAoB,CAAChjB,EAAM6kB,uBACpC7kB,EAAMygB,yBAAwB,EAGhCzgB,EAAM6kB,uBAAsB,GAGrC7kB,EAAMmkB,aAAe,IAAM,CAAA,IAAAW,EACzB,OAAAA,EACE9kB,EAAMQ,QAAQgjB,YAAS,KAAAsB,EACvBjmB,KAAKkmB,KAAK/kB,EAAMglB,YAAW,EAAKhlB,EAAM4D,SAAQ,EAAGgf,WAAWF,QAAQ,GAIxE1iB,EAAMglB,YAAc,IAAM,CAAA,IAAAC,EACxB,OAAAA,EACEjlB,EAAMQ,QAAQ0kB,WAAQD,KAAAA,EAAIjlB,EAAMygB,yBAAwB,EAAG0E,KAAKznB,OAGtE,CACF,EChRM0nB,GAA4BA,KAAwB,CACxDC,IAAK,CAAA,EACLC,OAAQ,CAAA,CACV,GAEaC,GAA2B,CACtCrZ,gBAAkBC,IACT,CACLqZ,WAAYJ,GAAyB,EACrC,GAAGjZ,IAIPE,kBACErM,IAEO,CACLylB,mBAAoBxpB,GAAiB,aAAc+D,CAAK,IAI5D6H,UAAWA,CACT5H,EACAD,IACS,CACTC,EAAI0U,IAAM,CAAClB,EAAUiS,EAAiBC,IAAsB,CAC1D,IAAMC,EAAaF,EACfzlB,EAAIuI,YAAW,EAAGlF,IAAInC,GAAA,CAAA,GAAC,CAAET,GAAAA,CAAG,EAACS,EAAA,OAAKT,CAAE,CAAA,EACpC,CAAA,EACEmlB,EAAeF,EACjB1lB,EAAI0I,cAAa,EAAGrF,IAAIgV,GAAA,CAAA,GAAC,CAAE5X,GAAAA,CAAG,EAAC4X,EAAA,OAAK5X,CAAE,CAAA,EACtC,CAAA,EACEugB,EAAS,IAAI3Q,IAAI,CAAC,GAAGuV,EAAc5lB,EAAIS,GAAI,GAAGklB,CAAU,CAAC,EAE/D5lB,EAAM8lB,cAAcxpB,GAAO,CAAA,IAAAypB,EAAAC,EACzB,GAAIvS,IAAa,SAAU,CAAA,IAAAwS,EAAAC,EACzB,MAAO,CACLb,MAAKY,EAAC3pB,GAAK+oB,MAAGY,KAAAA,EAAI,CAAA,GAAI5hB,OAAO5H,GAAK,EAACwkB,GAAM,MAANA,EAAQkF,IAAI1pB,CAAC,EAAE,EAClD6oB,OAAQ,CACN,KAAGY,EAAC5pB,GAAKgpB,SAAMY,KAAAA,EAAI,CAAA,GAAI7hB,OAAO5H,GAAK,EAACwkB,GAAM,MAANA,EAAQkF,IAAI1pB,CAAC,EAAC,EAClD,GAAGG,MAAMyT,KAAK4Q,CAAM,CAAC,EAG3B,CAEA,GAAIxN,IAAa,MAAO,CAAA,IAAA2S,EAAAC,EACtB,MAAO,CACLhB,IAAK,CACH,KAAGe,EAAC9pB,GAAK+oB,MAAGe,KAAAA,EAAI,CAAA,GAAI/hB,OAAO5H,GAAK,EAACwkB,GAAAA,MAAAA,EAAQkF,IAAI1pB,CAAC,EAAE,EAChD,GAAGG,MAAMyT,KAAK4Q,CAAM,CAAC,EAEvBqE,SAAQe,EAAC/pB,GAAKgpB,SAAMe,KAAAA,EAAI,CAAA,GAAIhiB,OAAO5H,GAAK,EAACwkB,GAAAA,MAAAA,EAAQkF,IAAI1pB,CAAC,EAAC,EAE3D,CAEA,MAAO,CACL4oB,MAAKU,EAACzpB,GAAK+oB,MAAGU,KAAAA,EAAI,CAAA,GAAI1hB,OAAO5H,GAAK,EAACwkB,GAAM,MAANA,EAAQkF,IAAI1pB,CAAC,EAAE,EAClD6oB,SAAQU,EAAC1pB,GAAKgpB,SAAMU,KAAAA,EAAI,CAAA,GAAI3hB,OAAO5H,GAAK,EAACwkB,GAAAA,MAAAA,EAAQkF,IAAI1pB,CAAC,EAAC,EAE3D,CAAC,GAEHwD,EAAImV,UAAY,IAAM,CAAA,IAAA2E,EACpB,GAAM,CAAEuM,iBAAAA,EAAkBhR,cAAAA,GAAkBtV,EAAMQ,QAClD,OAAI,OAAO8lB,GAAqB,WACvBA,EAAiBrmB,CAAG,GAE7B8Z,EAAOuM,GAAoBhR,IAAa,KAAAyE,EAAI,IAE9C9Z,EAAIuV,YAAc,IAAM,CACtB,IAAMyL,EAAS,CAAChhB,EAAIS,EAAE,EAEhB,CAAE2kB,IAAAA,EAAKC,OAAAA,CAAO,EAAItlB,EAAM4D,SAAQ,EAAG4hB,WAEnCe,EAAQtF,EAAO1iB,KAAK9B,GAAK4oB,GAAKzjB,SAASnF,CAAC,CAAC,EACzC+pB,EAAWvF,EAAO1iB,KAAK9B,GAAK6oB,GAAQ1jB,SAASnF,CAAC,CAAC,EAErD,OAAO8pB,EAAQ,MAAQC,EAAW,SAAW,IAE/CvmB,EAAI2V,eAAiB,IAAM,CAAA,IAAA6Q,EAAAC,EACzB,IAAMjT,EAAWxT,EAAIuV,YAAW,EAChC,GAAI,CAAC/B,EAAU,MAAO,GAEtB,IAAMkT,GAAmBF,EACvBhT,IAAa,MAAQzT,EAAM4mB,WAAU,EAAK5mB,EAAM6mB,cAAa,IAAE,KAAA,OADrCJ,EAEzBnjB,IAAIwjB,GAAA,CAAA,GAAC,CAAEpmB,GAAAA,CAAG,EAAComB,EAAA,OAAKpmB,EAAG,EAEtB,OAAAgmB,EAAOC,GAAqB9U,QAAQ5R,EAAIS,EAAE,IAAC,KAAAgmB,EAAI,KAInDljB,YAAqCxD,GAA8B,CACjEA,EAAM8lB,cAAgB1pB,GAAW4D,EAAMQ,QAAQilB,oBAAkB,KAAA,OAAhCzlB,EAAMQ,QAAQilB,mBAAqBrpB,CAAO,EAE3E4D,EAAM+mB,gBAAkBnY,GAAY,CAAA,IAAAoY,EAAAlY,EAAA,OAClC9O,EAAM8lB,cACJlX,EACIwW,GAAyB,GAAE4B,GAAAlY,EAC3B9O,EAAM+O,eAAND,KAAAA,OAAAA,EAAoB0W,aAAUwB,KAAAA,EAAI5B,GAAyB,CACjE,CAAC,EAEHplB,EAAMinB,oBAAsBxT,GAAY,CAAA,IAAA2C,EACtC,IAAMC,EAAerW,EAAM4D,SAAQ,EAAG4hB,WAEtC,GAAI,CAAC/R,EAAU,CAAA,IAAAyT,EAAAC,EACb,MAAO7iB,IAAQ4iB,EAAA7Q,EAAagP,MAAG,MAAhB6B,EAAkBxpB,SAAMypB,EAAI9Q,EAAaiP,SAAb6B,MAAAA,EAAqBzpB,OAClE,CACA,MAAO4G,IAAO8R,EAACC,EAAa5C,CAAQ,IAArB2C,MAAAA,EAAwB1Y,SAGzCsC,EAAMonB,eAAiB,CAACC,EAAaC,EAAc7T,IAAa,CAAA,IAAA8T,EAc9D,QAZEA,EAAAvnB,EAAMQ,QAAQgnB,iBAAcD,MAAAA,GAGvBD,GAAgB,CAAA,GAAIhkB,IAAIse,GAAS,CAChC,IAAM3hB,EAAMD,EAAM0I,OAAOkZ,EAAO,EAAI,EACpC,OAAO3hB,EAAIiiB,wBAAuB,EAAKjiB,EAAM,IAC/C,CAAC,GAEAqnB,GAAgB,CAAA,GAAIhkB,IACnBse,GAASyF,EAAYjjB,KAAKnE,GAAOA,EAAIS,KAAOkhB,CAAK,CACnD,GAEMvd,OAAOC,OAAO,EAAEhB,IAAI7G,IAAM,CAAE,GAAGA,EAAGgX,SAAAA,CAAS,EAAE,GAG3DzT,EAAM4mB,WAAajpB,EACjB,IAAM,CAACqC,EAAM8gB,YAAW,EAAGqE,KAAMnlB,EAAM4D,SAAQ,EAAG4hB,WAAWH,GAAG,EAChE,CAACoC,EAASC,IACR1nB,EAAMonB,eAAeK,EAASC,EAAiB,KAAK,EACtDjoB,EAAeO,EAAMQ,QAAS,YAAa,YAAY,CACzD,EAEAR,EAAM6mB,cAAgBlpB,EACpB,IAAM,CAACqC,EAAM8gB,YAAW,EAAGqE,KAAMnlB,EAAM4D,SAAQ,EAAG4hB,WAAWF,MAAM,EACnE,CAACmC,EAASE,IACR3nB,EAAMonB,eAAeK,EAASE,EAAoB,QAAQ,EAC5DloB,EAAeO,EAAMQ,QAAS,YAAa,eAAe,CAC5D,EAEAR,EAAM4nB,cAAgBjqB,EACpB,IAAM,CACJqC,EAAM8gB,YAAW,EAAGqE,KACpBnlB,EAAM4D,SAAQ,EAAG4hB,WAAWH,IAC5BrlB,EAAM4D,SAAQ,EAAG4hB,WAAWF,MAAM,EAEpC,CAACmC,EAASpC,EAAKC,IAAW,CACxB,IAAMuC,EAAe,IAAIvX,IAAI,CAAC,GAAI+U,GAAO,CAAA,EAAK,GAAIC,GAAU,CAAA,CAAE,CAAE,EAChE,OAAOmC,EAAQpjB,OAAO5H,GAAK,CAACorB,EAAa1B,IAAI1pB,EAAEiE,EAAE,CAAC,GAEpDjB,EAAeO,EAAMQ,QAAS,YAAa,eAAe,CAC5D,CACF,CACF,EC9EasnB,GAA6B,CACxC5b,gBAAkBC,IACT,CACL4b,aAAc,CAAA,EACd,GAAG5b,IAIPE,kBACErM,IAEO,CACLgoB,qBAAsB/rB,GAAiB,eAAgB+D,CAAK,EAC5DioB,mBAAoB,GACpBC,wBAAyB,GACzBC,sBAAuB,KAO3B3kB,YAAqCxD,GAA8B,CACjEA,EAAMooB,gBAAkBhsB,GACtB4D,EAAMQ,QAAQwnB,sBAAoB,KAAA,OAAlChoB,EAAMQ,QAAQwnB,qBAAuB5rB,CAAO,EAC9C4D,EAAMqoB,kBAAoBzZ,GAAY,CAAA,IAAAoY,EAAA,OACpChnB,EAAMooB,gBACJxZ,EAAe,CAAA,GAAEoY,EAAGhnB,EAAM+O,aAAagZ,eAAY,KAAAf,EAAI,CAAA,CACzD,CAAC,EACHhnB,EAAMsoB,sBAAwBzb,GAAS,CACrC7M,EAAMooB,gBAAgB9rB,GAAO,CAC3BuQ,EACE,OAAOA,EAAU,IAAcA,EAAQ,CAAC7M,EAAMuoB,qBAAoB,EAEpE,IAAMR,EAAe,CAAE,GAAGzrB,GAEpBksB,EAAqBxoB,EAAMyS,sBAAqB,EAAG7F,SAIzD,OAAIC,EACF2b,EAAmBlrB,QAAQ2C,GAAO,CAC3BA,EAAIwoB,aAAY,IAGrBV,EAAa9nB,EAAIS,EAAE,EAAI,GACzB,CAAC,EAED8nB,EAAmBlrB,QAAQ2C,GAAO,CAChC,OAAO8nB,EAAa9nB,EAAIS,EAAE,CAC5B,CAAC,EAGIqnB,CACT,CAAC,GAEH/nB,EAAM0oB,0BAA4B7b,GAChC7M,EAAMooB,gBAAgB9rB,GAAO,CAC3B,IAAMqsB,EACJ,OAAO9b,EAAU,IACbA,EACA,CAAC7M,EAAM4oB,yBAAwB,EAE/Bb,EAAkC,CAAE,GAAGzrB,GAE7C0D,OAAAA,EAAM8gB,YAAW,EAAGqE,KAAK7nB,QAAQ2C,GAAO,CACtC4oB,GAAoBd,EAAc9nB,EAAIS,GAAIioB,EAAe,GAAM3oB,CAAK,CACtE,CAAC,EAEM+nB,CACT,CAAC,EA4DH/nB,EAAM8oB,uBAAyB,IAAM9oB,EAAM2M,gBAAe,EAC1D3M,EAAM+oB,oBAAsBprB,EAC1B,IAAM,CAACqC,EAAM4D,SAAQ,EAAGmkB,aAAc/nB,EAAM2M,gBAAe,CAAE,EAC7D,CAACob,EAAciB,IACR/W,OAAO4O,KAAKkH,CAAY,EAAErqB,OAQxBurB,GAAajpB,EAAOgpB,CAAQ,EAP1B,CACL7D,KAAM,CAAA,EACNvY,SAAU,CAAA,EACVsU,SAAU,CAAA,GAMhBzhB,EAAeO,EAAMQ,QAAS,aAAc,qBAAqB,CACnE,EAEAR,EAAMkpB,4BAA8BvrB,EAClC,IAAM,CAACqC,EAAM4D,SAAQ,EAAGmkB,aAAc/nB,EAAMgP,oBAAmB,CAAE,EACjE,CAAC+Y,EAAciB,IACR/W,OAAO4O,KAAKkH,CAAY,EAAErqB,OAQxBurB,GAAajpB,EAAOgpB,CAAQ,EAP1B,CACL7D,KAAM,CAAA,EACNvY,SAAU,CAAA,EACVsU,SAAU,CAAA,GAMhBzhB,EAAeO,EAAMQ,QAAS,aAAc,6BAA6B,CAC3E,EAEAR,EAAMmpB,2BAA6BxrB,EACjC,IAAM,CAACqC,EAAM4D,SAAQ,EAAGmkB,aAAc/nB,EAAMqhB,kBAAiB,CAAE,EAC/D,CAAC0G,EAAciB,IACR/W,OAAO4O,KAAKkH,CAAY,EAAErqB,OAQxBurB,GAAajpB,EAAOgpB,CAAQ,EAP1B,CACL7D,KAAM,CAAA,EACNvY,SAAU,CAAA,EACVsU,SAAU,CAAA,GAMhBzhB,EAAeO,EAAMQ,QAAS,aAAc,4BAA4B,CAC1E,EAkBAR,EAAMuoB,qBAAuB,IAAM,CACjC,IAAMC,EAAqBxoB,EAAMgP,oBAAmB,EAAGpC,SACjD,CAAEmb,aAAAA,CAAa,EAAI/nB,EAAM4D,SAAQ,EAEnCwlB,EAAoB9kB,GACtBkkB,EAAmB9qB,QAAUuU,OAAO4O,KAAKkH,CAAY,EAAErqB,QAGzD,OAAI0rB,GAEAZ,EAAmBjqB,KACjB0B,GAAOA,EAAIwoB,aAAY,GAAM,CAACV,EAAa9nB,EAAIS,EAAE,CACnD,IAEA0oB,EAAoB,IAIjBA,GAGTppB,EAAM4oB,yBAA2B,IAAM,CACrC,IAAMS,EAAqBrpB,EACxB4kB,sBAAqB,EACrBhY,SAASvI,OAAOpE,GAAOA,EAAIwoB,aAAY,CAAE,EACtC,CAAEV,aAAAA,CAAa,EAAI/nB,EAAM4D,SAAQ,EAEnC0lB,EAAwB,CAAC,CAACD,EAAmB3rB,OAEjD,OACE4rB,GACAD,EAAmB9qB,KAAK0B,GAAO,CAAC8nB,EAAa9nB,EAAIS,EAAE,CAAC,IAEpD4oB,EAAwB,IAGnBA,GAGTtpB,EAAMupB,sBAAwB,IAAM,CAAA,IAAAC,EAClC,IAAMC,EAAgBxX,OAAO4O,MAAI2I,EAC/BxpB,EAAM4D,SAAQ,EAAGmkB,eAAYyB,KAAAA,EAAI,CAAA,CACnC,EAAE9rB,OACF,OACE+rB,EAAgB,GAChBA,EAAgBzpB,EAAMgP,oBAAmB,EAAGpC,SAASlP,QAIzDsC,EAAM0pB,0BAA4B,IAAM,CACtC,IAAML,EAAqBrpB,EAAM4kB,sBAAqB,EAAGhY,SACzD,OAAO5M,EAAM4oB,yBAAwB,EACjC,GACAS,EACGhlB,OAAOpE,GAAOA,EAAIwoB,aAAY,CAAE,EAChClqB,KAAK9B,GAAKA,EAAEktB,cAAa,GAAMltB,EAAEmtB,kBAAiB,CAAE,GAG7D5pB,EAAM6pB,gCAAkC,IAC9B3Q,GAAe,CACrBlZ,EAAMsoB,sBACFpP,EAAiB8D,OAA4BC,OACjD,GAIJjd,EAAM8pB,oCAAsC,IAClC5Q,GAAe,CACrBlZ,EAAM0oB,0BACFxP,EAAiB8D,OAA4BC,OACjD,IAKNpV,UAAWA,CACT5H,EACAD,IACS,CACTC,EAAI8pB,eAAiB,CAACld,EAAO/O,IAAS,CACpC,IAAMksB,EAAa/pB,EAAI0pB,cAAa,EAEpC3pB,EAAMooB,gBAAgB9rB,GAAO,CAAA,IAAA2tB,EAG3B,GAFApd,EAAQ,OAAOA,EAAU,IAAcA,EAAQ,CAACmd,EAE5C/pB,EAAIwoB,aAAY,GAAMuB,IAAend,EACvC,OAAOvQ,EAGT,IAAM4tB,EAAiB,CAAE,GAAG5tB,GAE5BusB,OAAAA,GACEqB,EACAjqB,EAAIS,GACJmM,GAAKod,EACLnsB,GAAMqsB,iBAAc,KAAAF,EAAI,GACxBjqB,CACF,EAEOkqB,CACT,CAAC,GAEHjqB,EAAI0pB,cAAgB,IAAM,CACxB,GAAM,CAAE5B,aAAAA,CAAa,EAAI/nB,EAAM4D,SAAQ,EACvC,OAAOwmB,GAAcnqB,EAAK8nB,CAAY,GAGxC9nB,EAAI2pB,kBAAoB,IAAM,CAC5B,GAAM,CAAE7B,aAAAA,CAAa,EAAI/nB,EAAM4D,SAAQ,EACvC,OAAOymB,GAAiBpqB,EAAK8nB,CAAmB,IAAM,QAGxD9nB,EAAIqqB,wBAA0B,IAAM,CAClC,GAAM,CAAEvC,aAAAA,CAAa,EAAI/nB,EAAM4D,SAAQ,EACvC,OAAOymB,GAAiBpqB,EAAK8nB,CAAmB,IAAM,OAGxD9nB,EAAIwoB,aAAe,IAAM,CAAA,IAAAtb,EACvB,OAAI,OAAOnN,EAAMQ,QAAQynB,oBAAuB,WACvCjoB,EAAMQ,QAAQynB,mBAAmBhoB,CAAG,GAG7CkN,EAAOnN,EAAMQ,QAAQynB,qBAAkB,KAAA9a,EAAI,IAG7ClN,EAAIsqB,oBAAsB,IAAM,CAAA,IAAAnd,EAC9B,OAAI,OAAOpN,EAAMQ,QAAQ2nB,uBAA0B,WAC1CnoB,EAAMQ,QAAQ2nB,sBAAsBloB,CAAG,GAGhDmN,EAAOpN,EAAMQ,QAAQ2nB,wBAAqB,KAAA/a,EAAI,IAGhDnN,EAAIuqB,kBAAoB,IAAM,CAAA,IAAAC,EAC5B,OAAI,OAAOzqB,EAAMQ,QAAQ0nB,yBAA4B,WAC5CloB,EAAMQ,QAAQ0nB,wBAAwBjoB,CAAG,GAGlDwqB,EAAOzqB,EAAMQ,QAAQ0nB,0BAAuB,KAAAuC,EAAI,IAElDxqB,EAAIyqB,yBAA2B,IAAM,CACnC,IAAMC,EAAY1qB,EAAIwoB,aAAY,EAElC,OAAQvP,GAAe,CAAA,IAAAgF,EAChByM,GACL1qB,EAAI8pB,gBAAc7L,EACdhF,EAAiB8D,SAAnBkB,KAAAA,OAAAA,EAAgDjB,OAClD,GAGN,CACF,EAEM4L,GAAsBA,CAC1BqB,EACAxpB,EACAmM,EACA+d,EACA5qB,IACG,CAAA,IAAAiT,EACH,IAAMhT,EAAMD,EAAM0I,OAAOhI,EAAI,EAAI,EAQ7BmM,GACG5M,EAAIuqB,kBAAiB,GACxBvY,OAAO4O,KAAKqJ,CAAc,EAAE5sB,QAAQpB,GAAO,OAAOguB,EAAehuB,CAAG,CAAC,EAEnE+D,EAAIwoB,aAAY,IAClByB,EAAexpB,CAAE,EAAI,KAGvB,OAAOwpB,EAAexpB,CAAE,EAItBkqB,IAAe3X,EAAIhT,EAAI+H,UAAO,MAAXiL,EAAavV,QAAUuC,EAAIsqB,oBAAmB,GACnEtqB,EAAI+H,QAAQ1K,QAAQ2C,GAClB4oB,GAAoBqB,EAAgBjqB,EAAIS,GAAImM,EAAO+d,EAAiB5qB,CAAK,CAC3E,CAEJ,EAEO,SAASipB,GACdjpB,EACAgpB,EACiB,CACjB,IAAMjB,EAAe/nB,EAAM4D,SAAQ,EAAGmkB,aAEhC8C,EAAoC,CAAA,EACpCC,EAAkD,CAAA,EAGlDC,EAAc,SAAC5F,EAAoBlkB,EAA4B,CACnE,OAAOkkB,EACJ7hB,IAAIrD,GAAO,CAAA,IAAA+qB,EACV,IAAMhB,EAAaI,GAAcnqB,EAAK8nB,CAAY,EAclD,GAZIiC,IACFa,EAAoBrtB,KAAKyC,CAAG,EAC5B6qB,EAAoB7qB,EAAIS,EAAE,EAAIT,IAGhC+qB,EAAI/qB,EAAI+H,UAAJgjB,MAAAA,EAAattB,SACfuC,EAAM,CACJ,GAAGA,EACH+H,QAAS+iB,EAAY9qB,EAAI+H,OAAkB,IAI3CgiB,EACF,OAAO/pB,CAEX,CAAC,EACAoE,OAAOC,OAAO,GAGnB,MAAO,CACL6gB,KAAM4F,EAAY/B,EAAS7D,IAAI,EAC/BvY,SAAUie,EACV3J,SAAU4J,EAEd,CAEO,SAASV,GACdnqB,EACAgrB,EACS,CAAA,IAAAC,EACT,OAAAA,EAAOD,EAAUhrB,EAAIS,EAAE,IAAC,KAAAwqB,EAAI,EAC9B,CAEO,SAASb,GACdpqB,EACAgrB,EACAjrB,EAC0B,CAAA,IAAAmrB,EAC1B,GAAI,GAAAA,EAAClrB,EAAI+H,UAAJmjB,MAAAA,EAAaztB,QAAQ,MAAO,GAEjC,IAAI0tB,EAAsB,GACtBC,EAAe,GAEnBprB,OAAAA,EAAI+H,QAAQ1K,QAAQguB,GAAU,CAE5B,GAAID,EAAAA,GAAgB,CAACD,KAIjBE,EAAO7C,aAAY,IACjB2B,GAAckB,EAAQL,CAAS,EACjCI,EAAe,GAEfD,EAAsB,IAKtBE,EAAOtjB,SAAWsjB,EAAOtjB,QAAQtK,QAAQ,CAC3C,IAAM6tB,EAAyBlB,GAAiBiB,EAAQL,CAAgB,EACpEM,IAA2B,MAC7BF,EAAe,IACNE,IAA2B,SACpCF,EAAe,IACfD,EAAsB,GAI1B,CACF,CAAC,EAEMA,EAAsB,MAAQC,EAAe,OAAS,EAC/D,CCzpBO,IAAMG,GAAsB,aAE7BC,GAA+BA,CAACC,EAAMC,EAAMxrB,IACzCyrB,GACLzhB,GAASuhB,EAAKnrB,SAASJ,CAAQ,CAAC,EAAE+J,YAAW,EAC7CC,GAASwhB,EAAKprB,SAASJ,CAAQ,CAAC,EAAE+J,YAAW,CAC/C,EAGI2hB,GAA4CA,CAACH,EAAMC,EAAMxrB,IACtDyrB,GACLzhB,GAASuhB,EAAKnrB,SAASJ,CAAQ,CAAC,EAChCgK,GAASwhB,EAAKprB,SAASJ,CAAQ,CAAC,CAClC,EAKI2rB,GAAuBA,CAACJ,EAAMC,EAAMxrB,IACjC4rB,GACL5hB,GAASuhB,EAAKnrB,SAASJ,CAAQ,CAAC,EAAE+J,YAAW,EAC7CC,GAASwhB,EAAKprB,SAASJ,CAAQ,CAAC,EAAE+J,YAAW,CAC/C,EAKI8hB,GAAoCA,CAACN,EAAMC,EAAMxrB,IAC9C4rB,GACL5hB,GAASuhB,EAAKnrB,SAASJ,CAAQ,CAAC,EAChCgK,GAASwhB,EAAKprB,SAASJ,CAAQ,CAAC,CAClC,EAGI8rB,GAA2BA,CAACP,EAAMC,EAAMxrB,IAAa,CACzD,IAAM+P,EAAIwb,EAAKnrB,SAAeJ,CAAQ,EAChCgQ,EAAIwb,EAAKprB,SAAeJ,CAAQ,EAKtC,OAAO+P,EAAIC,EAAI,EAAID,EAAIC,EAAI,GAAK,CAClC,EAEM+b,GAAwBA,CAACR,EAAMC,EAAMxrB,IAClC4rB,GAAaL,EAAKnrB,SAASJ,CAAQ,EAAGwrB,EAAKprB,SAASJ,CAAQ,CAAC,EAKtE,SAAS4rB,GAAa7b,EAAQC,EAAQ,CACpC,OAAOD,IAAMC,EAAI,EAAID,EAAIC,EAAI,EAAI,EACnC,CAEA,SAAShG,GAAS+F,EAAQ,CACxB,OAAI,OAAOA,GAAM,SACXvE,MAAMuE,CAAC,GAAKA,IAAMtE,KAAYsE,IAAM,KAC/B,GAEF9Q,OAAO8Q,CAAC,EAEb,OAAOA,GAAM,SACRA,EAEF,EACT,CAKA,SAAS0b,GAAoBO,EAAcC,EAAc,CAGvD,IAAMlc,EAAIic,EAAKrqB,MAAM0pB,EAAmB,EAAEnnB,OAAOC,OAAO,EAClD6L,EAAIic,EAAKtqB,MAAM0pB,EAAmB,EAAEnnB,OAAOC,OAAO,EAGxD,KAAO4L,EAAExS,QAAUyS,EAAEzS,QAAQ,CAC3B,IAAM2uB,EAAKnc,EAAEmE,MAAK,EACZiY,EAAKnc,EAAEkE,MAAK,EAEZkY,EAAKC,SAASH,EAAI,EAAE,EACpBI,EAAKD,SAASF,EAAI,EAAE,EAEpBI,EAAQ,CAACH,EAAIE,CAAE,EAAExc,KAAI,EAG3B,GAAItE,MAAM+gB,EAAM,CAAC,CAAE,EAAG,CACpB,GAAIL,EAAKC,EACP,MAAO,GAET,GAAIA,EAAKD,EACP,MAAO,GAET,QACF,CAGA,GAAI1gB,MAAM+gB,EAAM,CAAC,CAAE,EACjB,OAAO/gB,MAAM4gB,CAAE,EAAI,GAAK,EAI1B,GAAIA,EAAKE,EACP,MAAO,GAET,GAAIA,EAAKF,EACP,MAAO,EAEX,CAEA,OAAOrc,EAAExS,OAASyS,EAAEzS,MACtB,CAIO,IAAMivB,GAAa,CACxBlB,aAAAA,GACAI,0BAAAA,GACAC,KAAAA,GACAE,kBAAAA,GACAC,SAAAA,GACAC,MAAAA,EACF,ECwJaU,GAA2B,CACtC1gB,gBAAkBC,IACT,CACL0gB,QAAS,CAAA,EACT,GAAG1gB,IAIPH,oBAAqBA,KACZ,CACL8gB,UAAW,OACXC,cAAe,IAInB1gB,kBACErM,IAEO,CACLgtB,gBAAiB/wB,GAAiB,UAAW+D,CAAK,EAClDitB,iBAAmB/T,GACTA,EAAiBgU,WAK/BnsB,aAAcA,CACZb,EACAF,IACS,CACTE,EAAOitB,iBAAmB,IAAM,CAC9B,IAAMC,EAAYptB,EAAMgP,oBAAmB,EAAGpC,SAASsL,MAAM,EAAE,EAE3DmV,EAAW,GAEf,QAAWptB,KAAOmtB,EAAW,CAC3B,IAAMvgB,EAAQ5M,GAAKM,SAASL,EAAOQ,EAAE,EAErC,GAAIuR,OAAOC,UAAU/H,SAASgI,KAAKtF,CAAK,IAAM,gBAC5C,OAAO8f,GAAWV,SAGpB,GAAI,OAAOpf,GAAU,WACnBwgB,EAAW,GAEPxgB,EAAM/K,MAAM0pB,EAAmB,EAAE9tB,OAAS,GAC5C,OAAOivB,GAAWlB,YAGxB,CAEA,OAAI4B,EACKV,GAAWb,KAGba,GAAWT,OAEpBhsB,EAAOotB,eAAiB,IAAM,CAC5B,IAAM5gB,EAAW1M,EAAMgP,oBAAmB,EAAGpC,SAAS,CAAC,EAIvD,OAAI,OAFUF,GAAUnM,SAASL,EAAOQ,EAAE,GAErB,SACZ,MAGF,QAETR,EAAOqtB,aAAe,IAAM,CAAA,IAAAC,EAAAC,EAC1B,GAAI,CAACvtB,EACH,MAAM,IAAI8B,MAGZ,OAAOxF,GAAW0D,EAAOc,UAAU8rB,SAAS,EACxC5sB,EAAOc,UAAU8rB,UACjB5sB,EAAOc,UAAU8rB,YAAc,OAC7B5sB,EAAOitB,iBAAgB,GAAEK,GAAAC,EACzBztB,EAAMQ,QAAQmsB,aAAU,KAAA,OAAxBc,EAA2BvtB,EAAOc,UAAU8rB,SAAS,IAAWU,KAAAA,EAChEb,GAAWzsB,EAAOc,UAAU8rB,SAAS,GAE7C5sB,EAAOwtB,cAAgB,CAACC,EAAMC,IAAU,CAWtC,IAAMC,EAAmB3tB,EAAO4tB,oBAAmB,EAC7CC,EAAiB,OAAOJ,EAAS,KAAeA,IAAS,KAE/D3tB,EAAMguB,WAAW1xB,GAAO,CAEtB,IAAM2xB,EAAkB3xB,GAAK8H,KAAK3H,GAAKA,EAAEiE,KAAOR,EAAOQ,EAAE,EACnDwtB,EAAgB5xB,GAAKwR,UAAUrR,GAAKA,EAAEiE,KAAOR,EAAOQ,EAAE,EAExDytB,EAA2B,CAAA,EAG3BC,EACAC,EAAWN,EAAiBJ,EAAOE,IAAqB,OA+B5D,GA5BIvxB,GAAG,MAAHA,EAAKoB,QAAUwC,EAAOouB,gBAAe,GAAMV,EACzCK,EACFG,EAAa,SAEbA,EAAa,MAIX9xB,GAAG,MAAHA,EAAKoB,QAAUwwB,IAAkB5xB,EAAIoB,OAAS,EAChD0wB,EAAa,UACJH,EACTG,EAAa,SAEbA,EAAa,UAKbA,IAAe,WAEZL,GAEEF,IACHO,EAAa,WAKfA,IAAe,MAAO,CAAA,IAAAG,EACxBJ,EAAa,CACX,GAAG7xB,EACH,CACEoE,GAAIR,EAAOQ,GACXitB,KAAMU,CACR,CAAC,EAGHF,EAAW5Z,OACT,EACA4Z,EAAWzwB,SAAM6wB,EACdvuB,EAAMQ,QAAQguB,uBAAoBD,KAAAA,EAAI7iB,OAAOoL,iBAClD,CACF,MAAWsX,IAAe,SAExBD,EAAa7xB,EAAIgH,IAAI7G,GACfA,EAAEiE,KAAOR,EAAOQ,GACX,CACL,GAAGjE,EACHkxB,KAAMU,GAGH5xB,CACR,EACQ2xB,IAAe,SACxBD,EAAa7xB,EAAI+H,OAAO5H,GAAKA,EAAEiE,KAAOR,EAAOQ,EAAE,EAE/CytB,EAAa,CACX,CACEztB,GAAIR,EAAOQ,GACXitB,KAAMU,CACR,CAAC,EAIL,OAAOF,CACT,CAAC,GAGHjuB,EAAOuuB,gBAAkB,IAAM,CAAA,IAAAttB,EAAAutB,EAK7B,QAJmBvtB,GAAAutB,EACjBxuB,EAAOc,UAAU2tB,gBAAa,KAAAD,EAC9B1uB,EAAMQ,QAAQmuB,gBAAa,KAAAxtB,EAC3BjB,EAAOotB,eAAc,IAAO,QACP,OAAS,OAGlCptB,EAAO4tB,oBAAuBF,GAAoB,CAAA,IAAAzgB,EAAAC,EAChD,IAAMwhB,EAAqB1uB,EAAOuuB,gBAAe,EAC3CI,EAAW3uB,EAAO4uB,YAAW,EAEnC,OAAKD,EAKHA,IAAaD,KAAkBzhB,EAC9BnN,EAAMQ,QAAQuuB,uBAAoB,MAAA5hB,KAClCygB,EAAAA,IAAKxgB,EAAGpN,EAAMQ,QAAQwuB,oBAAiB,OAAA5hB,GAEjC,GAEFyhB,IAAa,OAAS,MAAQ,OAV5BD,GAaX1uB,EAAO+uB,WAAa,IAAM,CAAA,IAAA/hB,EAAAud,EACxB,QACEvd,EAAChN,EAAOc,UAAUkuB,gBAAahiB,KAAAA,EAAI,OAAIud,EACtCzqB,EAAMQ,QAAQ0uB,gBAAa,KAAAzE,EAAI,KAChC,CAAC,CAACvqB,EAAOyB,YAIbzB,EAAOouB,gBAAkB,IAAM,CAAA,IAAAhW,EAAA6W,EAC7B,OAAA7W,GAAA6W,EACEjvB,EAAOc,UAAUouB,kBAAe,KAAAD,EAChCnvB,EAAMQ,QAAQ4uB,kBAAe9W,KAAAA,EAC7B,CAAC,CAACpY,EAAOyB,YAIbzB,EAAO4uB,YAAc,IAAM,CAAA,IAAAO,EACzB,IAAMC,GAAUD,EAAGrvB,EAAM4D,SAAQ,EAAGipB,UAAO,KAAA,OAAxBwC,EAA0BjrB,KAAK3H,GAAKA,EAAEiE,KAAOR,EAAOQ,EAAE,EAEzE,OAAQ4uB,EAAqBA,EAAW3B,KAAO,OAAS,MAAnC,IAGvBztB,EAAOqvB,aAAe,IAAA,CAAA,IAAAC,EAAAC,EAAA,OAAAD,GAAAC,EACpBzvB,EAAM4D,SAAQ,EAAGipB,UAAO,KAAA,OAAxB4C,EAA0B3hB,UAAUrR,GAAKA,EAAEiE,KAAOR,EAAOQ,EAAE,IAAC,KAAA8uB,EAAI,EAAE,EAEpEtvB,EAAOwvB,aAAe,IAAM,CAE1B1vB,EAAMguB,WAAW1xB,GACfA,GAAG,MAAHA,EAAKoB,OAASpB,EAAI+H,OAAO5H,GAAKA,EAAEiE,KAAOR,EAAOQ,EAAE,EAAI,CAAA,CACtD,GAGFR,EAAOyvB,wBAA0B,IAAM,CACrC,IAAMC,EAAU1vB,EAAO+uB,WAAU,EAEjC,OAAQ/V,GAAe,CAChB0W,IACH1W,EAAUC,SAAO,MAAjBD,EAAUC,QAAO,EACnBjZ,EAAOwtB,eAAPxtB,MAAAA,EAAOwtB,cACLjsB,OACAvB,EAAOouB,gBAAe,EAAKtuB,EAAMQ,QAAQysB,kBAAgB,KAAA,OAA9BjtB,EAAMQ,QAAQysB,iBAAmB/T,CAAC,EAAI,EACnE,MAKN1V,YAAqCxD,GAA8B,CACjEA,EAAMguB,WAAa5xB,GAAW4D,EAAMQ,QAAQwsB,iBAAe,KAAA,OAA7BhtB,EAAMQ,QAAQwsB,gBAAkB5wB,CAAO,EACrE4D,EAAM6vB,aAAejhB,GAAgB,CAAA,IAAAkhB,EAAAhhB,EACnC9O,EAAMguB,WAAWpf,EAAe,CAAA,GAAEkhB,GAAAhhB,EAAG9O,EAAM+O,eAAY,KAAA,OAAlBD,EAAoB+d,UAAOiD,KAAAA,EAAI,CAAA,CAAE,GAExE9vB,EAAM+vB,qBAAuB,IAAM/vB,EAAM0S,mBAAkB,EAC3D1S,EAAMqhB,kBAAoB,KACpB,CAACrhB,EAAMgwB,oBAAsBhwB,EAAMQ,QAAQ6gB,oBAC7CrhB,EAAMgwB,mBAAqBhwB,EAAMQ,QAAQ6gB,kBAAkBrhB,CAAK,GAG9DA,EAAMQ,QAAQyvB,eAAiB,CAACjwB,EAAMgwB,mBACjChwB,EAAM+vB,qBAAoB,EAG5B/vB,EAAMgwB,mBAAkB,EAEnC,CACF,ECrfME,GAAkB,CACtB3sB,GACA+Y,GACAjJ,GACAoB,GACAnL,GACAyC,GACAoS,GACAO,GACAkO,GACAjc,GACA4O,GACAoD,GACA4C,GACAuC,GACAxQ,EAAY,EAmOP,SAAS9T,GACdhD,EACc,CAAA,IAAA2vB,EAAAC,EAQd,IAAMvvB,EAAY,CAAC,GAAGqvB,GAAiB,IAAAC,EAAI3vB,EAAQK,YAAS,KAAAsvB,EAAI,CAAA,CAAE,EAE9DnwB,EAAQ,CAAEa,UAAAA,GAERwvB,EAAiBrwB,EAAMa,UAAUsI,OAAO,CAAC4U,EAAKjd,IAC3CmR,OAAOqe,OAAOvS,EAAKjd,EAAQuL,mBAAiB,KAAA,OAAzBvL,EAAQuL,kBAAoBrM,CAAK,CAAC,EAC3D,CAAA,CAAE,EAECuwB,EAAgB/vB,GAChBR,EAAMQ,QAAQ+vB,aACTvwB,EAAMQ,QAAQ+vB,aAAaF,EAAgB7vB,CAAO,EAGpD,CACL,GAAG6vB,EACH,GAAG7vB,GAMHuO,EAAe,CACjB,GAHuC,CAAA,EAIvC,IAAAqhB,EAAI5vB,EAAQuO,eAAYqhB,KAAAA,EAAI,CAAA,GAG9BpwB,EAAMa,UAAUvD,QAAQwD,GAAW,CAAA,IAAA0vB,EACjCzhB,GAAYyhB,EAAI1vB,EAAQoL,iBAARpL,KAAAA,OAAAA,EAAQoL,gBAAkB6C,CAAY,IAACyhB,KAAAA,EACrDzhB,CACJ,CAAC,EAED,IAAM6Q,EAAyB,CAAA,EAC3B6Q,EAAgB,GAEdC,EAAoC,CACxC7vB,UAAAA,EACAL,QAAS,CACP,GAAG6vB,EACH,GAAG7vB,GAELuO,aAAAA,EACAgR,OAAQ4Q,GAAM,CACZ/Q,EAAOpiB,KAAKmzB,CAAE,EAETF,IACHA,EAAgB,GAIhBG,QAAQC,QAAO,EACZC,KAAK,IAAM,CACV,KAAOlR,EAAOliB,QACZkiB,EAAOvL,MAAK,EAAE,EAEhBoc,EAAgB,GACjB,EACAM,MAAMC,GACLC,WAAW,IAAM,CACf,MAAMD,CACR,CAAC,CACH,IAGNE,MAAOA,IAAM,CACXlxB,EAAM3D,SAAS2D,EAAM+O,YAAY,GAEnCoiB,WAAY/0B,GAAW,CACrB,IAAMg1B,EAAa70B,GAAiBH,EAAS4D,EAAMQ,OAAO,EAC1DR,EAAMQ,QAAU+vB,EAAaa,CAAU,GAMzCxtB,SAAUA,IACD5D,EAAMQ,QAAQ2L,MAGvB9P,SAAWD,GAAiC,CAC1C4D,EAAMQ,QAAQ6wB,eAAdrxB,MAAAA,EAAMQ,QAAQ6wB,cAAgBj1B,CAAO,GAGvCk1B,UAAWA,CAACrxB,EAAYxB,EAAeyC,IAAmB,CAAA,IAAA6gB,EAAA,OAAAA,EACxD/hB,EAAMQ,QAAQ+wB,UAAdvxB,KAAAA,OAAAA,EAAMQ,QAAQ+wB,SAAWtxB,EAAKxB,EAAOyC,CAAM,IAAC6gB,KAAAA,EAC5C,GAAG7gB,EAAS,CAACA,EAAOR,GAAIjC,CAAK,EAAEyI,KAAK,GAAG,EAAIzI,CAAK,EAAE,EAEpDkO,gBAAiBA,KACV3M,EAAMwxB,mBACTxxB,EAAMwxB,iBAAmBxxB,EAAMQ,QAAQmM,gBAAgB3M,CAAK,GAGvDA,EAAMwxB,iBAAgB,GAM/B1Q,YAAaA,IACJ9gB,EAAM4kB,sBAAqB,EAGpClc,OAAQA,CAAChI,EAAY+wB,IAAwB,CAC3C,IAAIxxB,GACFwxB,EAAYzxB,EAAMygB,yBAAwB,EAAKzgB,EAAM8gB,YAAW,GAChEI,SAASxgB,CAAE,EAEb,GAAI,CAACT,IACHA,EAAMD,EAAM2M,gBAAe,EAAGuU,SAASxgB,CAAE,EACrC,CAACT,GAIH,MAAM,IAAI+B,MAId,OAAO/B,GAETqB,qBAAsB3D,EACpB,IAAM,CAACqC,EAAMQ,QAAQkxB,aAAa,EAClCA,GAAiB,CAAA,IAAAC,EACfD,OAAAA,GAAaC,EAAID,IAAa,KAAAC,EAAI,CAAA,EAI3B,CACLjwB,OAAQmP,GAAS,CACf,IAAMxP,EAAoBwP,EAAMnP,OAAOxB,OACpCc,UAEH,OAAIK,EAAkBE,YACbF,EAAkBE,YAGvBF,EAAkBM,WACbN,EAAkBX,GAGpB,MAGTJ,KAAMuQ,GAAK,CAAA,IAAA+gB,EAAAC,EAAA,OAAAD,GAAAC,EAAIhhB,EAAMlQ,YAAW,IAAjBkxB,MAAAA,EAA0B1nB,UAAQ,KAAA,OAAlC0nB,EAA0B1nB,SAAQ,IAAI,KAAAynB,EAAI,IAAI,EAC7D,GAAG5xB,EAAMa,UAAUsI,OAAO,CAAC4U,EAAKjd,IACvBmR,OAAOqe,OAAOvS,EAAKjd,EAAQkL,qBAAmB,KAAA,OAA3BlL,EAAQkL,oBAAmB,CAAI,EACxD,CAAA,CAAE,EACL,GAAG0lB,IAGPjyB,EAAee,EAAS,eAAgB,sBAAsB,CAChE,EAEAsxB,eAAgBA,IAAM9xB,EAAMQ,QAAQyB,QAEpCyB,cAAe/F,EACb,IAAM,CAACqC,EAAM8xB,eAAc,CAAE,EAC7BC,GAAc,CACZ,IAAMC,EAAiB,SACrBD,EACA7wB,EACAD,EAC6B,CAAA,OAD7BA,IAAK,SAALA,EAAQ,GAED8wB,EAAWzuB,IAAItC,GAAa,CACjC,IAAMd,EAASa,GAAaf,EAAOgB,EAAWC,EAAOC,CAAM,EAErD+wB,EAAoBjxB,EAK1Bd,OAAAA,EAAO+B,QAAUgwB,EAAkBhwB,QAC/B+vB,EAAeC,EAAkBhwB,QAAS/B,EAAQe,EAAQ,CAAC,EAC3D,CAAA,EAEGf,CACT,CAAC,GAGH,OAAO8xB,EAAeD,CAAU,GAElCtyB,EAAee,EAAS,eAAgB,eAAe,CACzD,EAEA+c,kBAAmB5f,EACjB,IAAM,CAACqC,EAAM0D,cAAa,CAAE,EAC5BM,GACSA,EAAW5B,QAAQlC,GACjBA,EAAOgC,eAAc,CAC7B,EAEHzC,EAAee,EAAS,eAAgB,mBAAmB,CAC7D,EAEA0xB,uBAAwBv0B,EACtB,IAAM,CAACqC,EAAMud,kBAAiB,CAAE,EAChC4U,GACSA,EAAYhpB,OACjB,CAACC,EAAKlJ,KACJkJ,EAAIlJ,EAAOQ,EAAE,EAAIR,EACVkJ,GAET,CAAA,CACF,EAEF3J,EAAee,EAAS,eAAgB,uBAAuB,CACjE,EAEAwI,kBAAmBrL,EACjB,IAAM,CAACqC,EAAM0D,cAAa,EAAI1D,EAAMsC,mBAAkB,CAAE,EACxD,CAAC0B,EAAYzB,IAAiB,CAC5B,IAAIE,EAAcuB,EAAW5B,QAAQlC,GAAUA,EAAOmC,eAAc,CAAE,EACtE,OAAOE,EAAaE,CAAW,GAEjChD,EAAee,EAAS,eAAgB,mBAAmB,CAC7D,EAEA6H,UAAWlI,GACMH,EAAMkyB,uBAAsB,EAAG/xB,CAAQ,GAU1D8R,OAAOqe,OAAOtwB,EAAO0wB,CAAY,EAEjC,QAASjyB,EAAQ,EAAGA,EAAQuB,EAAMa,UAAUnD,OAAQe,IAAS,CAC3D,IAAMqC,EAAUd,EAAMa,UAAUpC,CAAK,EACrCqC,GAAO,MAAPA,EAAS0C,aAAW,MAApB1C,EAAS0C,YAAcxD,CAAK,CAC9B,CAEA,OAAOA,CACT,CC1gBO,SAAS2M,IAEW,CACzB,OAAO3M,GACLrC,EACE,IAAM,CAACqC,EAAMQ,QAAQ4xB,IAAI,EAEvBA,GAKG,CACH,IAAMpJ,EAA4B,CAChC7D,KAAM,CAAA,EACNvY,SAAU,CAAA,EACVsU,SAAU,CAAA,GAGNmR,EAAa,SACjBC,EACArxB,EACA6H,EACiB,CAFjB7H,IAAK,SAALA,EAAQ,GAGR,IAAMkkB,EAAO,CAAA,EAEb,QAAS9b,EAAI,EAAGA,EAAIipB,EAAa50B,OAAQ2L,IAAK,CAS5C,IAAMpJ,EAAM4H,GACV7H,EACAA,EAAMsxB,UAAUgB,EAAajpB,CAAC,EAAIA,EAAGP,CAAS,EAC9CwpB,EAAajpB,CAAC,EACdA,EACApI,EACAQ,OACAqH,GAAWpI,EACb,EAUA,GAPAsoB,EAASpc,SAASpP,KAAKyC,CAAG,EAE1B+oB,EAAS9H,SAASjhB,EAAIS,EAAE,EAAIT,EAE5BklB,EAAK3nB,KAAKyC,CAAG,EAGTD,EAAMQ,QAAQ+xB,WAAY,CAAA,IAAAC,EAC5BvyB,EAAIwyB,gBAAkBzyB,EAAMQ,QAAQ+xB,WAClCD,EAAajpB,CAAC,EACdA,CACF,GAGAmpB,EAAIvyB,EAAIwyB,kBAAJD,MAAAA,EAAqB90B,SACvBuC,EAAI+H,QAAUqqB,EAAWpyB,EAAIwyB,gBAAiBxxB,EAAQ,EAAGhB,CAAG,EAEhE,CACF,CAEA,OAAOklB,GAGT6D,OAAAA,EAAS7D,KAAOkN,EAAWD,CAAI,EAExBpJ,CACT,EACAvpB,EAAeO,EAAMQ,QAAS,aAAc,cAAe,IACzDR,EAAM8iB,oBAAmB,CAC3B,CACF,CACJ,CE9EO,SAAS4P,IAGwB,CACtC,MAAO,CAACC,EAAOC,IACbC,EACE,IAAA,CAAA,IAAAC,EAAA,MAAM,EAAAA,EAACH,EAAMI,UAAUH,CAAQ,IAAC,KAAA,OAAzBE,EAA2BE,mBAAkB,CAAE,CAAC,EACvDC,GAAmB,CAAA,IAAAC,EACjB,GAAI,CAACD,EAAiB,OAEtB,IAAME,GAAUD,EACdD,EAAgBG,SAAS,CAAC,IAAC,KAAA,OAA3BF,EAA6BG,gBAAgBT,CAAQ,EAEvD,GAAI,OAAOO,EAAe,IACxB,OAGF,IAAIG,EAAkC,CAACH,EAAYA,CAAU,EAE7D,QAASI,EAAI,EAAGA,EAAIN,EAAgBG,SAASI,OAAQD,IAAK,CACxD,IAAME,EACJR,EAAgBG,SAASG,CAAC,EAAGF,gBAAwBT,CAAQ,EAE/D,QAASc,EAAI,EAAGA,EAAID,EAAOD,OAAQE,IAAK,CACtC,IAAMC,EAAQF,EAAOC,CAAC,EAElBC,EAAQL,EAAoB,CAAC,EAC/BA,EAAoB,CAAC,EAAIK,EAChBA,EAAQL,EAAoB,CAAC,IACtCA,EAAoB,CAAC,EAAIK,EAE7B,CACF,CAEA,OAAOL,GAETM,EAAejB,EAAMkB,QAAS,aAAc,wBAAwB,CACtE,CACJ,CCtCO,SAASC,GACdC,EACAC,EACArB,EACA,CACA,OAAIA,EAAMkB,QAAQI,mBACTC,GAAwBH,EAAMC,EAAerB,CAAK,EAGpDwB,GAAuBJ,EAAMC,EAAerB,CAAK,CAC1D,CAEA,SAASuB,GACPE,EACAC,EACA1B,EACiB,CAAA,IAAA2B,EACjB,IAAMC,EAAoC,CAAA,EACpCC,EAAkD,CAAA,EAClDC,GAAQH,EAAG3B,EAAMkB,QAAQa,wBAAqB,KAAAJ,EAAI,IAElDK,EAAoB,SAACP,EAA4BQ,EAAc,CAAdA,IAAK,SAALA,EAAQ,GAC7D,IAAMb,EAAqB,CAAA,EAG3B,QAASR,EAAI,EAAGA,EAAIa,EAAaZ,OAAQD,IAAK,CAAA,IAAAsB,EAC5C,IAAIC,EAAMV,EAAab,CAAC,EAElBwB,EAASC,GACbrC,EACAmC,EAAIG,GACJH,EAAII,SACJJ,EAAIK,MACJL,EAAIF,MACJQ,OACAN,EAAIO,QACN,EAGA,GAFAN,EAAOO,cAAgBR,EAAIQ,eAEvBT,EAAAC,EAAIS,UAAO,MAAXV,EAAarB,QAAUoB,EAAQH,EAAU,CAI3C,GAHAM,EAAOQ,QAAUZ,EAAkBG,EAAIS,QAASX,EAAQ,CAAC,EACzDE,EAAMC,EAEFV,EAAUS,CAAG,GAAK,CAACC,EAAOQ,QAAQ/B,OAAQ,CAC5CO,EAAKyB,KAAKV,CAAG,EACbN,EAAoBM,EAAIG,EAAE,EAAIH,EAC9BP,EAAoBiB,KAAKV,CAAG,EAC5B,QACF,CAEA,GAAIT,EAAUS,CAAG,GAAKC,EAAOQ,QAAQ/B,OAAQ,CAC3CO,EAAKyB,KAAKV,CAAG,EACbN,EAAoBM,EAAIG,EAAE,EAAIH,EAC9BP,EAAoBiB,KAAKV,CAAG,EAC5B,QACF,CACF,MACEA,EAAMC,EACFV,EAAUS,CAAG,IACff,EAAKyB,KAAKV,CAAG,EACbN,EAAoBM,EAAIG,EAAE,EAAIH,EAC9BP,EAAoBiB,KAAKV,CAAG,EAGlC,CAEA,OAAOf,GAGT,MAAO,CACLA,KAAMY,EAAkBP,CAAY,EACpChB,SAAUmB,EACVkB,SAAUjB,EAEd,CAEA,SAASL,GACPC,EACAC,EACA1B,EACiB,CAAA,IAAA+C,EACjB,IAAMnB,EAAoC,CAAA,EACpCC,EAAkD,CAAA,EAClDC,GAAQiB,EAAG/C,EAAMkB,QAAQa,wBAAqB,KAAAgB,EAAI,IAGlDf,EAAoB,SAACP,EAA4BQ,EAAc,CAAdA,IAAK,SAALA,EAAQ,GAG7D,IAAMb,EAAqB,CAAA,EAG3B,QAASR,EAAI,EAAGA,EAAIa,EAAaZ,OAAQD,IAAK,CAC5C,IAAIuB,EAAMV,EAAab,CAAC,EAIxB,GAFac,EAAUS,CAAG,EAEhB,CAAA,IAAAa,EACR,IAAIA,EAAAb,EAAIS,UAAO,MAAXI,EAAanC,QAAUoB,EAAQH,EAAU,CAC3C,IAAMM,EAASC,GACbrC,EACAmC,EAAIG,GACJH,EAAII,SACJJ,EAAIK,MACJL,EAAIF,MACJQ,OACAN,EAAIO,QACN,EACAN,EAAOQ,QAAUZ,EAAkBG,EAAIS,QAASX,EAAQ,CAAC,EACzDE,EAAMC,CACR,CAEAhB,EAAKyB,KAAKV,CAAG,EACbP,EAAoBiB,KAAKV,CAAG,EAC5BN,EAAoBM,EAAIG,EAAE,EAAIH,CAChC,CACF,CAEA,OAAOf,GAGT,MAAO,CACLA,KAAMY,EAAkBP,CAAY,EACpChB,SAAUmB,EACVkB,SAAUjB,EAEd,CC7HO,SAASxB,IAGW,CACzB,MAAO,CAACL,EAAOC,IACbC,EACE,IAAM,CACJF,EAAMiD,uBAAsB,EAC5BjD,EAAMkD,SAAQ,EAAGP,cACjB3C,EAAMkD,SAAQ,EAAGC,aACjBnD,EAAMoD,oBAAmB,CAAE,EAE7B,CAACC,EAAaV,EAAeQ,IAAiB,CAC5C,GACE,CAACE,EAAYjC,KAAKP,QACjB,EAAC8B,GAAa,MAAbA,EAAe9B,SAAU,CAACsC,EAE5B,OAAOE,EAGT,IAAMC,EAAgB,CACpB,GAAGX,EAAcY,IAAIC,GAAKA,EAAElB,EAAE,EAAEmB,OAAOD,GAAKA,IAAMvD,CAAQ,EAC1DkD,EAAe,aAAeV,MAAS,EACvCgB,OAAOC,OAAO,EAEVC,EAAkBxB,GAAoB,CAE1C,QAASvB,EAAI,EAAGA,EAAI0C,EAAczC,OAAQD,IACxC,GAAIuB,EAAIQ,cAAcW,EAAc1C,CAAC,CAAC,IAAO,GAC3C,MAAO,GAGX,MAAO,IAGT,OAAOO,GAAWkC,EAAYjC,KAAMuC,EAAgB3D,CAAK,GAE3DiB,EAAejB,EAAMkB,QAAS,aAAc,oBAAoB,CAClE,CACJ,CCxCO,SAAS0C,IAGY,CAC1B,MAAO,CAAC5D,EAAOC,IACbC,EACE,IAAA,CAAA,IAAAC,EAAA,MAAM,EAAAA,EAACH,EAAMI,UAAUH,CAAQ,IAAC,KAAA,OAAzBE,EAA2BE,mBAAkB,CAAE,CAAC,EACvDC,GAAmB,CACjB,GAAI,CAACA,EAAiB,OAAO,IAAIuD,IAEjC,IAAIC,EAAsB,IAAID,IAE9B,QAASjD,EAAI,EAAGA,EAAIN,EAAgBG,SAASI,OAAQD,IAAK,CACxD,IAAME,EACJR,EAAgBG,SAASG,CAAC,EAAGF,gBAAwBT,CAAQ,EAE/D,QAASc,EAAI,EAAGA,EAAID,EAAOD,OAAQE,IAAK,CACtC,IAAMC,EAAQF,EAAOC,CAAC,EAEtB,GAAI+C,EAAoBC,IAAI/C,CAAK,EAAG,CAAA,IAAAgD,EAClCF,EAAoBG,IAClBjD,IACAgD,EAACF,EAAoBI,IAAIlD,CAAK,IAACgD,KAAAA,EAAI,GAAK,CAC1C,CACF,MACEF,EAAoBG,IAAIjD,EAAO,CAAC,CAEpC,CACF,CAEA,OAAO8C,CACT,EACA7C,EACEjB,EAAMkB,QACN,aACA,0BAA0BjB,CAAQ,EACpC,CACF,CACJ,CCpCO,SAASmD,IAEW,CACzB,OAAOpD,GACLE,EACE,IAAM,CACJF,EAAMiD,uBAAsB,EAC5BjD,EAAMkD,SAAQ,EAAGP,cACjB3C,EAAMkD,SAAQ,EAAGC,YAAY,EAE/B,CAACgB,EAAUxB,EAAeQ,IAAiB,CACzC,GACE,CAACgB,EAAS/C,KAAKP,QACd,EAAC8B,GAAa,MAAbA,EAAe9B,SAAU,CAACsC,EAC5B,CACA,QAASvC,EAAI,EAAGA,EAAIuD,EAAS1D,SAASI,OAAQD,IAC5CuD,EAAS1D,SAASG,CAAC,EAAG+B,cAAgB,CAAA,EACtCwB,EAAS1D,SAASG,CAAC,EAAGwD,kBAAoB,CAAA,EAE5C,OAAOD,CACT,CAEA,IAAME,EAAuD,CAAA,EACvDC,EAAuD,CAAA,GAE3D3B,GAAiB,CAAA,GAAI4B,QAAQf,GAAK,CAAA,IAAAgB,EAClC,IAAMC,EAASzE,EAAMI,UAAUoD,EAAElB,EAAE,EAEnC,GAAI,CAACmC,EACH,OAGF,IAAMC,EAAWD,EAAOE,YAAW,EAE9BD,GASLL,EAAsBxB,KAAK,CACzBP,GAAIkB,EAAElB,GACNoC,SAAAA,EACAE,eAAaJ,EAAEE,EAASG,oBAAkB,KAAA,OAA3BH,EAASG,mBAAqBrB,EAAExC,KAAK,IAAC,KAAAwD,EAAIhB,EAAExC,KAC7D,CAAC,CACH,CAAC,EAED,IAAMsC,GAAiBX,GAAiB,CAAA,GAAIY,IAAIC,GAAKA,EAAElB,EAAE,EAEnDwC,EAAiB9E,EAAM+E,kBAAiB,EAExCC,EAA4BhF,EAC/BiF,kBAAiB,EACjBxB,OAAOgB,GAAUA,EAAOS,mBAAkB,CAAE,EAG7C/B,GACA2B,GACAE,EAA0BnE,SAE1ByC,EAAcT,KAAK,YAAY,EAE/BmC,EAA0BT,QAAQE,GAAU,CAAA,IAAAU,EAC1Cb,EAAsBzB,KAAK,CACzBP,GAAImC,EAAOnC,GACXoC,SAAUI,EACVF,eAAaO,EACXL,EAAeD,oBAAkB,KAAA,OAAjCC,EAAeD,mBAAqB1B,CAAY,IAAC,KAAAgC,EACjDhC,CACJ,CAAC,CACH,CAAC,GAGH,IAAIiC,EACAC,EAGJ,QAAStE,EAAI,EAAGA,EAAIoD,EAAS1D,SAASI,OAAQE,IAAK,CACjD,IAAMoB,EAAMgC,EAAS1D,SAASM,CAAC,EAI/B,GAFAoB,EAAIQ,cAAgB,CAAA,EAEhB0B,EAAsBxD,OACxB,QAASD,EAAI,EAAGA,EAAIyD,EAAsBxD,OAAQD,IAAK,CACrDwE,EAAsBf,EAAsBzD,CAAC,EAC7C,IAAM0B,EAAK8C,EAAoB9C,GAG/BH,EAAIQ,cAAcL,CAAE,EAAI8C,EAAoBV,SAC1CvC,EACAG,EACA8C,EAAoBR,cACpBU,GAAc,CACZnD,EAAIiC,kBAAkB9B,CAAE,EAAIgD,CAC9B,CACF,CACF,CAGF,GAAIhB,EAAsBzD,OAAQ,CAChC,QAASD,EAAI,EAAGA,EAAI0D,EAAsBzD,OAAQD,IAAK,CACrDyE,EAAsBf,EAAsB1D,CAAC,EAC7C,IAAM0B,EAAK+C,EAAoB/C,GAE/B,GACE+C,EAAoBX,SAClBvC,EACAG,EACA+C,EAAoBT,cACpBU,GAAc,CACZnD,EAAIiC,kBAAkB9B,CAAE,EAAIgD,CAC9B,CACF,EACA,CACAnD,EAAIQ,cAAc4C,WAAa,GAC/B,KACF,CACF,CAEIpD,EAAIQ,cAAc4C,aAAe,KACnCpD,EAAIQ,cAAc4C,WAAa,GAEnC,CACF,CAEA,IAAM5B,EAAkBxB,GAAoB,CAE1C,QAASvB,EAAI,EAAGA,EAAI0C,EAAczC,OAAQD,IACxC,GAAIuB,EAAIQ,cAAcW,EAAc1C,CAAC,CAAC,IAAO,GAC3C,MAAO,GAGX,MAAO,IAIT,OAAOO,GAAWgD,EAAS/C,KAAMuC,EAAgB3D,CAAK,CACxD,EACAiB,EAAejB,EAAMkB,QAAS,aAAc,sBAAuB,IACjElB,EAAMwF,oBAAmB,CAC3B,CACF,CACJ,CGlJO,SAASC,IAEW,CACzB,OAAOC,GACLC,EACE,IAAM,CAACD,EAAME,SAAQ,EAAGC,QAASH,EAAMI,qBAAoB,CAAE,EAC7D,CAACD,EAASE,IAAa,CACrB,GAAI,CAACA,EAASC,KAAKC,QAAU,EAACJ,GAAO,MAAPA,EAASI,QACrC,OAAOF,EAGT,IAAMG,EAAeR,EAAME,SAAQ,EAAGC,QAEhCM,EAA+B,CAAA,EAG/BC,EAAmBF,EAAaG,OAAOC,GAAI,CAAA,IAAAC,EAAA,OAAAA,EAC/Cb,EAAMc,UAAUF,EAAKG,EAAE,IAAvBF,KAAAA,OAAAA,EAA0BG,WAAU,CAAE,CACxC,EAEMC,EAOF,CAAA,EAEJP,EAAiBQ,QAAQC,GAAa,CACpC,IAAMC,EAASpB,EAAMc,UAAUK,EAAUJ,EAAE,EACtCK,IAELH,EAAeE,EAAUJ,EAAE,EAAI,CAC7BM,cAAeD,EAAOE,UAAUD,cAChCE,cAAeH,EAAOE,UAAUC,cAChCC,UAAWJ,EAAOK,aAAY,GAElC,CAAC,EAED,IAAMC,EAAYpB,GAAuB,CAGvC,IAAMqB,EAAarB,EAAKsB,IAAIC,IAAQ,CAAE,GAAGA,CAAI,EAAE,EAE/CF,OAAAA,EAAWf,KAAK,CAACkB,EAAMC,IAAS,CAC9B,QAASC,EAAI,EAAGA,EAAItB,EAAiBH,OAAQyB,GAAK,EAAG,CAAA,IAAAC,EACnD,IAAMd,EAAYT,EAAiBsB,CAAC,EAC9BE,EAAajB,EAAeE,EAAUJ,EAAE,EACxCM,EAAgBa,EAAWb,cAC3Bc,GAAMF,EAAGd,GAAWiB,OAAI,KAAAH,EAAI,GAE9BI,EAAU,EAGd,GAAIhB,EAAe,CACjB,IAAMiB,EAASR,EAAKS,SAASpB,EAAUJ,EAAE,EACnCyB,EAAST,EAAKQ,SAASpB,EAAUJ,EAAE,EAEnC0B,EAAaH,IAAWI,OACxBC,EAAaH,IAAWE,OAE9B,GAAID,GAAcE,EAAY,CAC5B,GAAItB,IAAkB,QAAS,OAAOoB,EAAa,GAAK,EACxD,GAAIpB,IAAkB,OAAQ,OAAOoB,EAAa,EAAI,GACtDJ,EACEI,GAAcE,EACV,EACAF,EACEpB,EACA,CAACA,CACX,CACF,CAOA,GALIgB,IAAY,IACdA,EAAUH,EAAWV,UAAUM,EAAMC,EAAMZ,EAAUJ,EAAE,GAIrDsB,IAAY,EACd,OAAIF,IACFE,GAAW,IAGTH,EAAWX,gBACbc,GAAW,IAGNA,CAEX,CAEA,OAAOP,EAAKc,MAAQb,EAAKa,KAC3B,CAAC,EAGDjB,EAAWT,QAAQW,GAAO,CAAA,IAAAgB,EACxBpC,EAAeqC,KAAKjB,CAAG,GACvBgB,EAAIhB,EAAIkB,UAAJF,MAAAA,EAAatC,SACfsB,EAAIkB,QAAUrB,EAASG,EAAIkB,OAAO,EAEtC,CAAC,EAEMpB,GAGT,MAAO,CACLrB,KAAMoB,EAASrB,EAASC,IAAI,EAC5B0C,SAAUvC,EACVwC,SAAU5C,EAAS4C,SAEvB,EACAC,EAAelD,EAAMmD,QAAS,aAAc,oBAAqB,IAC/DnD,EAAMoD,oBAAmB,CAC3B,CACF,CACJ,CCvGO,SAASC,GACdC,EACAC,EAC+B,CAC/B,OAAQD,EAAcE,GAAyBF,CAAI,EACjDG,GAACH,EAASC,CAAQ,EAElBD,EAHa,IAKjB,CAEA,SAASE,GACPE,EAC0C,CAC1C,OACEC,GAAiBD,CAAS,GAC1B,OAAOA,GAAc,YACrBE,GAAkBF,CAAS,CAE/B,CAEA,SAASC,GAAiBD,EAAgB,CACxC,OACE,OAAOA,GAAc,aACpB,IAAM,CACL,IAAMG,EAAQC,OAAOC,eAAeL,CAAS,EAC7C,OAAOG,EAAMG,WAAaH,EAAMG,UAAUR,gBAC5C,GAAC,CAEL,CAEA,SAASI,GAAkBF,EAAgB,CACzC,OACE,OAAOA,GAAc,UACrB,OAAOA,EAAUO,UAAa,UAC9B,CAAC,aAAc,mBAAmB,EAAEC,SAASR,EAAUO,SAASE,WAAW,CAE/E,CAEO,SAASC,GACdC,EACA,CAEA,IAAMC,EAA+C,CACnDC,MAAO,CAAA,EACPC,cAAeA,IAAM,CAAA,EACrBC,oBAAqB,KACrB,GAAGJ,GAIC,CAACK,CAAQ,EAAUC,EAAS,KAAO,CACvCC,QAASC,GAAmBP,CAAe,CAC7C,EAAE,EAGI,CAACC,EAAOO,CAAQ,EAAUH,EAAS,IAAMD,EAASE,QAAQG,YAAY,EAI5EL,OAAAA,EAASE,QAAQI,WAAWC,IAAS,CACnC,GAAGA,EACH,GAAGZ,EACHE,MAAO,CACL,GAAGA,EACH,GAAGF,EAAQE,OAIbC,cAAeU,GAAW,CACxBJ,EAASI,CAAO,EAChBb,EAAQG,eAARH,MAAAA,EAAQG,cAAgBU,CAAO,CACjC,CACF,EAAE,EAEKR,EAASE,OAClB,CCzFgB,SAAAO,GACdC,EACAC,EACAC,EAMA,CACI,IAAAC,EAAOD,EAAK,aAAe,CAAA,EAC3BE,EAEJ,MAAO,IAAe,CAbR,IAAAC,EAAAC,EAAAC,EAAAC,EAcR,IAAAC,EACAP,EAAK,OAAOG,EAAAH,EAAK,QAAL,MAAAG,EAAA,KAAAH,CAAA,KAAgBO,EAAU,KAAK,IAAA,GAE/C,IAAMC,EAAUV,EAAA,EAMhB,GAAI,EAHFU,EAAQ,SAAWP,EAAK,QACxBO,EAAQ,KAAK,CAACC,EAAUC,IAAkBT,EAAKS,CAAK,IAAMD,CAAG,GAGtD,OAAAP,EAGFD,EAAAO,EAEH,IAAAG,EAKJ,GAJIX,EAAK,OAAOI,EAAAJ,EAAK,QAAL,MAAAI,EAAA,KAAAJ,CAAA,KAAgBW,EAAa,KAAK,IAAA,GAEzCT,EAAAH,EAAG,GAAGS,CAAO,EAElBR,EAAK,OAAOK,EAAAL,EAAK,QAAL,MAAAK,EAAA,KAAAL,CAAA,GAAgB,CACxB,IAAAY,EAAa,KAAK,OAAO,KAAK,IAAA,EAAQL,GAAY,GAAG,EAAI,IACzDM,EAAgB,KAAK,OAAO,KAAK,IAAA,EAAQF,GAAe,GAAG,EAAI,IAC/DG,EAAsBD,EAAgB,GAEtCE,EAAM,CAACC,EAAsBC,IAAgB,CAE1C,IADPD,EAAM,OAAOA,CAAG,EACTA,EAAI,OAASC,GAClBD,EAAM,IAAMA,EAEP,OAAAA,CAAA,EAGD,QAAA,KACN,YAAOD,EAAIF,EAAe,CAAC,CAAC,KAAKE,EAAIH,EAAY,CAAC,CAAC,MACnD;;;yBAGiB,KAAK,IAChB,EACA,KAAK,IAAI,IAAM,IAAME,EAAqB,GAAG,CAC9C,CAAA,iBACLd,GAAM,GAAA,CAEV,CAEA,OAAAM,EAAAN,GAAM,WAAN,MAAAM,EAAA,KAAAN,EAAiBE,CAAA,EAEVA,CAAA,CAEX,CAEgB,SAAAgB,GAAgBC,EAAsBC,EAAiB,CACrE,GAAID,IAAU,OACN,MAAA,IAAI,MAAM,uBAAuBC,EAAM,KAAKA,CAAG,GAAK,EAAE,EAAE,EAEvD,OAAAD,CAEX,CAEa,IAAAE,GAAc,CAACC,EAAWC,IAAc,KAAK,IAAID,EAAIC,CAAC,EAAI,EAE1DC,GAAW,CACtBC,EACA1B,EACA2B,IACG,CACC,IAAAC,EACJ,OAAO,YAAwBC,EAAkB,CAC/CH,EAAa,aAAaE,CAAS,EACvBA,EAAAF,EAAa,WAAW,IAAM1B,EAAG,MAAM,KAAM6B,CAAI,EAAGF,CAAE,CAAA,CAEtE,EC3Ca,IAAAG,GAAuBC,GAAkBA,EAEzCC,GAAyBC,GAAiB,CACrD,IAAMC,EAAQ,KAAK,IAAID,EAAM,WAAaA,EAAM,SAAU,CAAC,EACrDE,EAAM,KAAK,IAAIF,EAAM,SAAWA,EAAM,SAAUA,EAAM,MAAQ,CAAC,EAE/DG,EAAM,CAAA,EAEZ,QAASC,EAAIH,EAAOG,GAAKF,EAAKE,IAC5BD,EAAI,KAAKC,CAAC,EAGL,OAAAD,CACT,EAEaE,GAAqB,CAChCC,EACAC,IACG,CACH,IAAMC,EAAUF,EAAS,cACzB,GAAI,CAACE,EACH,OAEF,IAAMC,EAAeH,EAAS,aAC9B,GAAI,CAACG,EACH,OAGI,IAAAC,EAAWC,GAAe,CACxB,GAAA,CAAE,MAAAC,EAAO,OAAAC,CAAW,EAAAF,EACvBJ,EAAA,CAAE,MAAO,KAAK,MAAMK,CAAK,EAAG,OAAQ,KAAK,MAAMC,CAAM,CAAG,CAAA,CAAA,EAKzD,GAFIH,EAAAF,EAAQ,sBAAA,CAAuB,EAEnC,CAACC,EAAa,eAChB,MAAO,IAAM,CAAA,EAGf,IAAMK,EAAW,IAAIL,EAAa,eAAgBM,GAAY,CACtD,IAAAC,EAAQD,EAAQ,CAAC,EACvB,GAAIC,GAAO,cAAe,CAClB,IAAAC,EAAMD,EAAM,cAAc,CAAC,EACjC,GAAIC,EAAK,CACPP,EAAQ,CAAE,MAAOO,EAAI,WAAY,OAAQA,EAAI,SAAA,CAAW,EACxD,MACF,CACF,CACQP,EAAAF,EAAQ,sBAAA,CAAuB,CAAA,CACxC,EAED,OAAAM,EAAS,QAAQN,EAAS,CAAE,IAAK,YAAc,CAAA,EAExC,IAAM,CACXM,EAAS,UAAUN,CAAO,CAAA,CAE9B,EAEMU,GAA0B,CAC9B,QAAS,EACX,EAuBA,IAAMC,GACJ,OAAO,OAAU,IAAc,GAAO,gBAAiB,OAE5CC,GAAuB,CAClCC,EACAC,IACG,CACH,IAAMC,EAAUF,EAAS,cACzB,GAAI,CAACE,EACH,OAEF,IAAMC,EAAeH,EAAS,aAC9B,GAAI,CAACG,EACH,OAGF,IAAIC,EAAS,EACPC,EAAWP,GACb,IAAA,GACAQ,GACEH,EACA,IAAM,CACJF,EAAGG,EAAQ,EAAK,CAClB,EACAJ,EAAS,QAAQ,qBAAA,EAGjBO,EAAiBC,GAAyB,IAAM,CACpDJ,EAASF,EAAQF,EAAS,QAAQ,WAAa,aAAe,WAAW,EAChEK,EAAA,EACTJ,EAAGG,EAAQI,CAAW,CAAA,EAElBC,EAAUF,EAAc,EAAI,EAC5BG,EAAaH,EAAc,EAAK,EAC3B,OAAAG,EAAA,EAEHR,EAAA,iBAAiB,SAAUO,EAASE,EAAuB,EAC3DT,EAAA,iBAAiB,YAAaQ,EAAYC,EAAuB,EAElE,IAAM,CACHT,EAAA,oBAAoB,SAAUO,CAAO,EACrCP,EAAA,oBAAoB,YAAaQ,CAAU,CAAA,CAEvD,EA4CO,IAAME,GAAiB,CAC5BC,EACAC,EACAC,IACG,CACH,GAAID,GAAO,cAAe,CAClB,IAAAE,EAAMF,EAAM,cAAc,CAAC,EACjC,GAAIE,EAIK,OAHM,KAAK,MAChBA,EAAID,EAAS,QAAQ,WAAa,aAAe,WAAW,CAAA,CAIlE,CACA,OAAO,KAAK,MACVF,EAAQ,sBAAsB,EAC5BE,EAAS,QAAQ,WAAa,QAAU,QAC1C,CAAA,CAEJ,EAkBa,IAAAE,GAAgB,CAC3BC,EACA,CACE,YAAAC,EAAc,EACd,SAAAC,CACF,EACAC,IACG,SACH,IAAMC,EAAWJ,EAASC,GAE1BI,GAAAC,EAAAH,EAAS,gBAAT,KAAA,OAAAG,EAAwB,WAAxB,MAAAD,EAAA,KAAAC,EAAmC,CACjC,CAACH,EAAS,QAAQ,WAAa,OAAS,KAAK,EAAGC,EAChD,SAAAF,CAAA,CAAA,CAEJ,EAwDaK,GAAN,KAGL,CAkDA,YAAYC,EAAwD,CAjDpE,KAAQ,OAAqC,CAAA,EAEN,KAAA,cAAA,KACa,KAAA,aAAA,KACtC,KAAA,YAAA,GACd,KAAQ,uBAAwC,KAChD,KAAA,kBAAsD,CAAA,EAC9C,KAAA,cAAA,IAAoB,IAC5B,KAAQ,4BAA6C,CAAA,EAC3B,KAAA,WAAA,KACI,KAAA,aAAA,KACY,KAAA,gBAAA,KAC1C,KAAQ,kBAAoB,EAQ5B,KAAA,cAAA,IAAoB,IACpB,KAAQ,UAAkB,IAAA,CACxB,IAAIC,EAA6B,KAE3BC,EAAM,IACND,IAIA,CAAC,KAAK,cAAgB,CAAC,KAAK,aAAa,eACpC,KAGDA,EAAM,IAAI,KAAK,aAAa,eAAgBE,GAAY,CACtDA,EAAA,QAASC,GAAU,CACpB,KAAA,gBAAgBA,EAAM,OAAwBA,CAAK,CAAA,CACzD,CAAA,CACF,GAGI,MAAA,CACL,WAAY,IAAA,OAAM,OAAAN,EAAAI,EAAI,IAAJ,KAAA,OAAAJ,EAAO,WAAA,CAAA,EACzB,QAAUO,GAAA,OACR,OAAAP,EAAAI,EAAI,IAAJ,KAAA,OAAAJ,EAAO,QAAQO,EAAQ,CAAE,IAAK,YAAA,CAAA,GAChC,UAAYA,GAAA,OAAoB,OAAAP,EAAAI,EAAI,IAAJ,KAAA,OAAAJ,EAAO,UAAUO,CAAA,CAAA,CAAM,CACzD,GAAA,EAEuD,KAAA,MAAA,KAMzD,KAAA,WAAcL,GAA2D,CAChE,OAAA,QAAQA,CAAI,EAAE,QAAQ,CAAC,CAACM,EAAKC,CAAK,IAAM,CACzC,OAAOA,EAAU,KAAa,OAAQP,EAAaM,CAAG,CAAA,CAC3D,EAED,KAAK,QAAU,CACb,MAAO,GACP,cAAe,EACf,SAAU,EACV,aAAc,EACd,WAAY,EACZ,mBAAoB,EACpB,iBAAkB,EAClB,WAAY,GACZ,WAAYE,GACZ,eAAgBC,GAChB,SAAU,IAAM,CAAC,EACjB,eAAAC,GACA,YAAa,CAAE,MAAO,EAAG,OAAQ,CAAE,EACnC,aAAc,EACd,IAAK,EACL,eAAgB,aAChB,yBAA0B,CAAC,EAC3B,MAAO,EACP,sBAAuB,IACvB,QAAS,GACT,GAAGV,CAAA,CACL,EAGM,KAAA,OAAS,CAACW,EAAgBC,IAAkB,SAClD,GAAM,CAAE,WAAAC,EAAY,SAAAC,CAAA,EAAa,KAAK,OAAS,CAC7C,WAAY,OACZ,SAAU,MAAA,EAENC,EAAQ,KAAK,eAAA,GAGjBJ,GACAE,IAAeE,GAAO,YACtBD,IAAaC,GAAO,aAEflB,GAAAC,EAAA,KAAA,SAAQ,WAAR,MAAAD,EAAA,KAAAC,EAAmB,KAAMc,CAAA,EAChC,EAGF,KAAQ,QAAU,IAAM,CACjB,KAAA,OAAO,OAAO,OAAO,EAAE,QAASI,GAAMA,EAAA,CAAI,EAC/C,KAAK,OAAS,CAAA,EACd,KAAK,cAAgB,KACrB,KAAK,aAAe,KACpB,KAAK,SAAS,WAAA,EACd,KAAK,cAAc,MAAA,CAAM,EAG3B,KAAA,UAAY,IACH,IAAM,CACX,KAAK,QAAQ,CAAA,EAIjB,KAAA,YAAc,IAAM,OAClB,IAAMC,EAAgB,KAAK,QAAQ,QAC/B,KAAK,QAAQ,iBACb,EAAA,KAEA,GAAA,KAAK,gBAAkBA,EAAe,CAGxC,GAFA,KAAK,QAAQ,EAET,CAACA,EAAe,CACb,KAAA,OAAO,GAAO,EAAK,EACxB,MACF,CAEA,KAAK,cAAgBA,EAEjB,KAAK,eAAiB,kBAAmB,KAAK,cAC3C,KAAA,aAAe,KAAK,cAAc,cAAc,YAEhD,KAAA,eAAenB,EAAA,KAAK,gBAAL,KAAA,OAAAA,EAAoB,SAAU,KAG/C,KAAA,gBAAgB,KAAK,gBAAA,EAAmB,CAC3C,YAAa,OACb,SAAU,MAAA,CACX,EAED,KAAK,OAAO,KACV,KAAK,QAAQ,mBAAmB,KAAOoB,GAAS,CAC9C,KAAK,WAAaA,EACb,KAAA,OAAO,GAAO,EAAK,CAAA,CACzB,CAAA,EAGH,KAAK,OAAO,KACV,KAAK,QAAQ,qBAAqB,KAAM,CAAC1B,EAAQ2B,IAAgB,CAC/D,KAAK,kBAAoB,EACzB,KAAK,gBAAkBA,EACnB,KAAK,gBAAoB,EAAA3B,EACvB,UACA,WACF,KACJ,KAAK,aAAeA,EAEpB,IAAM4B,EAAkB,KAAK,YAC7B,KAAK,YAAcD,EAEd,KAAA,OAAOC,IAAoBD,EAAaA,CAAW,CAAA,CACzD,CAAA,CAEL,CAAA,EAGF,KAAQ,QAAU,IACX,KAAK,QAAQ,SAKlB,KAAK,WAAa,KAAK,YAAc,KAAK,QAAQ,YAE3C,KAAK,WAAW,KAAK,QAAQ,WAAa,QAAU,QAAQ,IANjE,KAAK,WAAa,KACX,GAQX,KAAQ,gBAAkB,IACnB,KAAK,QAAQ,SAKlB,KAAK,aACH,KAAK,eACJ,OAAO,KAAK,QAAQ,eAAkB,WACnC,KAAK,QAAQ,cAAc,EAC3B,KAAK,QAAQ,eAEZ,KAAK,eAVV,KAAK,aAAe,KACb,GAYH,KAAA,uBAAyB,CAC/BE,EACAC,IACG,CACG,IAAAC,EAAA,IAAgC,IAChCC,EAAA,IAA2B,IACjC,QAASC,EAAIH,EAAQ,EAAGG,GAAK,EAAGA,IAAK,CAC7B,IAAAC,EAAcL,EAAaI,CAAC,EAElC,GAAIF,EAA0B,IAAIG,EAAY,IAAI,EAChD,SAGF,IAAMC,EAA8BH,EAAqB,IACvDE,EAAY,IAAA,EAWd,GAREC,GAA+B,MAC/BD,EAAY,IAAMC,EAA4B,IAEzBH,EAAA,IAAIE,EAAY,KAAMA,CAAW,EAC7CA,EAAY,IAAMC,EAA4B,KAC7BJ,EAAA,IAAIG,EAAY,KAAM,EAAI,EAGlDH,EAA0B,OAAS,KAAK,QAAQ,MAClD,KAEJ,CAEA,OAAOC,EAAqB,OAAS,KAAK,QAAQ,MAC9C,MAAM,KAAKA,EAAqB,OAAA,CAAQ,EAAE,KAAK,CAACI,EAAGC,IAC7CD,EAAE,MAAQC,EAAE,IACPD,EAAE,MAAQC,EAAE,MAGdD,EAAE,IAAMC,EAAE,GAClB,EAAE,CAAC,EACJ,MAAA,EAGN,KAAQ,sBAAwBC,GAC9B,IAAM,CACJ,KAAK,QAAQ,MACb,KAAK,QAAQ,aACb,KAAK,QAAQ,aACb,KAAK,QAAQ,WACb,KAAK,QAAQ,OACf,EACA,CAACC,EAAOC,EAAcC,EAAcC,EAAYC,KAC9C,KAAK,4BAA8B,CAAA,EAC5B,CACL,MAAAJ,EACA,aAAAC,EACA,aAAAC,EACA,WAAAC,EACA,QAAAC,CAAA,GAGJ,CACE,IAAK,EACP,CAAA,EAGF,KAAQ,gBAAkBL,GACxB,IAAM,CAAC,KAAK,sBAAA,EAAyB,KAAK,aAAa,EACvD,CACE,CAAE,MAAAC,EAAO,aAAAC,EAAc,aAAAC,EAAc,WAAAC,EAAY,QAAAC,CAAA,EACjDC,IACG,OACH,GAAI,CAACD,EACH,YAAK,kBAAoB,CAAA,EACzB,KAAK,cAAc,MAAA,EACZ,CAAA,EAGL,KAAK,kBAAkB,SAAW,IAC/B,KAAA,kBAAoB,KAAK,QAAQ,yBACjC,KAAA,kBAAkB,QAASE,GAAS,CACvC,KAAK,cAAc,IAAIA,EAAK,IAAKA,EAAK,IAAI,CAAA,CAC3C,GAGG,IAAAC,EACJ,KAAK,4BAA4B,OAAS,EACtC,KAAK,IAAI,GAAG,KAAK,2BAA2B,EAC5C,EACN,KAAK,4BAA8B,CAAA,EAEnC,IAAMjB,EAAe,KAAK,kBAAkB,MAAM,EAAGiB,CAAG,EAExD,QAASC,EAAID,EAAKC,EAAIR,EAAOQ,IAAK,CAChC,IAAI7B,GAAiBZ,EAAA,KAAK,kBAAkByC,CAAC,IAAxB,KAAA,OAAAzC,EAA2B,eAE3CY,IACHA,EAAkB8B,GAA0C,CACpDlC,IAAAA,EAAM4B,EAAWK,CAAC,EAClBE,EAAW,KAAK,cAAc,IAAInC,CAAG,EAE3C,GAAI,CAACkC,EAAM,CACLC,IACG,KAAA,SAAS,UAAUA,CAAQ,EAC3B,KAAA,cAAc,OAAOnC,CAAG,GAE/B,MACF,CAEImC,IAAaD,IACXC,GACG,KAAA,SAAS,UAAUA,CAAQ,EAE7B,KAAA,SAAS,QAAQD,CAAI,EACrB,KAAA,cAAc,IAAIlC,EAAKkC,CAAI,GAG9BA,EAAK,aACF,KAAA,WACHD,EACA,KAAK,QAAQ,eAAeC,EAAM,OAAW,IAAI,CAAA,CAErD,GAIE,IAAAlC,EAAM4B,EAAWK,CAAC,EAElBG,EACJ,KAAK,QAAQ,QAAU,EACnBrB,EAAakB,EAAI,CAAC,EAClB,KAAK,uBAAuBlB,EAAckB,CAAC,EAE3CI,EAAQD,EACVA,EAAoB,IAAM,KAAK,QAAQ,IACvCV,EAAeC,EAEbW,EAAeR,EAAc,IAAI9B,CAAG,EACpCuC,EACJ,OAAOD,GAAiB,SACpBA,EACA,KAAK,QAAQ,aAAaL,CAAC,EAE3BO,EAAMH,EAAQE,EAEdE,EAAOL,EACTA,EAAoB,KACpBH,EAAI,KAAK,QAAQ,MAErBlB,EAAakB,CAAC,EAAI,CAChB,MAAOA,EACP,MAAAI,EACA,KAAAE,EACA,IAAAC,EACA,IAAAxC,EACA,KAAAyC,EACA,eAAArC,CAAA,CAEJ,CAEA,YAAK,kBAAoBW,EAElBA,CACT,EACA,CACE,IAAK,GACL,MAAO,IAAM,KAAK,QAAQ,KAC5B,CAAA,EAGe,KAAA,eAAAS,GACf,IAAM,CAAC,KAAK,gBAAA,EAAmB,KAAK,QAAA,EAAW,KAAK,gBAAA,CAAiB,EACrE,CAACT,EAAc2B,EAAWC,IAChB,KAAK,MACX5B,EAAa,OAAS,GAAK2B,EAAY,EACnCE,GAAe,CACb,aAAA7B,EACA,UAAA2B,EACA,aAAAC,CACD,CAAA,EACD,KAER,CACE,IAAK,GACL,MAAO,IAAM,KAAK,QAAQ,KAC5B,CAAA,EAGF,KAAQ,WAAanB,GACnB,IAAM,CACJ,KAAK,QAAQ,eACb,KAAK,eAAe,EACpB,KAAK,QAAQ,SACb,KAAK,QAAQ,KACf,EACA,CAACqB,EAAgBpC,EAAOqC,EAAUrB,IACzBhB,IAAU,KACb,CAAC,EACDoC,EAAe,CACb,WAAYpC,EAAM,WAClB,SAAUA,EAAM,SAChB,SAAAqC,EACA,MAAArB,CAAA,CACD,EAEP,CACE,IAAK,GACL,MAAO,IAAM,KAAK,QAAQ,KAC5B,CAAA,EAGF,KAAA,iBAAoBS,GAAuB,CACnC,IAAAa,EAAgB,KAAK,QAAQ,eAC7BC,EAAWd,EAAK,aAAaa,CAAa,EAEhD,OAAKC,EAOE,SAASA,EAAU,EAAE,GANlB,QAAA,KACN,2BAA2BD,CAAa,gCAAA,EAEnC,GAGmB,EAGtB,KAAA,gBAAkB,CACxBb,EACApC,IACG,CACG,IAAAmC,EAAI,KAAK,iBAAiBC,CAAI,EAC9BH,EAAO,KAAK,gBAAgB,EAAEE,CAAC,EAErC,GAAI,CAACF,GAAQ,CAACG,EAAK,YAAa,CAC9B,KAAK,cAAc,QAAQ,CAACe,EAAQjD,IAAQ,CACtCiD,IAAWf,IACR,KAAA,SAAS,UAAUA,CAAI,EACvB,KAAA,cAAc,OAAOlC,CAAG,EAC/B,CACD,EACD,MACF,CAEA,IAAMmC,EAAW,KAAK,cAAc,IAAIJ,EAAK,GAAG,EAE5CI,IAAaD,IACXC,GACG,KAAA,SAAS,UAAUA,CAAQ,EAE7B,KAAA,SAAS,QAAQD,CAAI,EAC1B,KAAK,cAAc,IAAIH,EAAK,IAAKG,CAAI,GAGlC,KAAA,WAAWD,EAAG,KAAK,QAAQ,eAAeC,EAAMpC,EAAO,IAAI,CAAC,CAAA,EAGtD,KAAA,WAAA,CAACkB,EAAeuB,IAAiB,CAC5C,IAAMR,EAAO,KAAK,gBAAgB,EAAEf,CAAK,EACzC,GAAI,CAACe,EACH,OAEF,IAAMmB,EAAW,KAAK,cAAc,IAAInB,EAAK,GAAG,GAAKA,EAAK,KACpDoB,EAAQZ,EAAOW,EAEjBC,IAAU,KAEV,KAAK,6CAA+C,OAChD,KAAK,2CAA2CpB,EAAMoB,EAAO,IAAI,EACjEpB,EAAK,MAAQ,KAAK,gBAAgB,EAAI,KAAK,oBAM1C,KAAA,gBAAgB,KAAK,gBAAA,EAAmB,CAC3C,YAAc,KAAK,mBAAqBoB,EACxC,SAAU,MAAA,CACX,EAGE,KAAA,4BAA4B,KAAKpB,EAAK,KAAK,EAC3C,KAAA,cAAgB,IAAI,IAAI,KAAK,cAAc,IAAIA,EAAK,IAAKQ,CAAI,CAAC,EAE9D,KAAA,OAAO,GAAM,EAAK,EACzB,EAGF,KAAA,eAAkBL,GAA0C,CACrDA,GAIA,KAAA,gBAAgBA,EAAM,MAAS,CAAA,EAGpB,KAAA,gBAAAV,GAChB,IAAM,CAAC,KAAK,WAAc,EAAA,KAAK,gBAAA,CAAiB,EAChD,CAAC4B,EAASrC,IAAiB,CACzB,IAAMsC,EAAiD,CAAA,EAEvD,QAASC,EAAI,EAAGC,EAAMH,EAAQ,OAAQE,EAAIC,EAAKD,IAAK,CAC5C,IAAArB,EAAImB,EAAQE,CAAC,EACblC,EAAcL,EAAakB,CAAC,EAElCoB,EAAa,KAAKjC,CAAW,CAC/B,CAEO,OAAAiC,CACT,EACA,CACE,IAAK,GACL,MAAO,IAAM,KAAK,QAAQ,KAC5B,CAAA,EAGF,KAAA,wBAA2BnE,GAAmB,CACtC,IAAA6B,EAAe,KAAK,gBAAA,EACtB,GAAAA,EAAa,SAAW,EAGrB,OAAAyC,GACLzC,EACE0C,GACE,EACA1C,EAAa,OAAS,EACrBC,GAAkBwC,GAAazC,EAAaC,CAAK,CAAC,EAAE,MACrD9B,CAAA,CAEJ,CAAA,CACF,EAGsB,KAAA,sBAAA,CAACI,EAAkBoE,IAA2B,CAC9D,IAAAnB,EAAO,KAAK,QAAA,EACZI,EAAe,KAAK,gBAAA,EAEtBe,IAAU,SACRpE,GAAYqD,EACNe,EAAA,QACCpE,GAAYqD,EAAeJ,EAC5BmB,EAAA,MAEAA,EAAA,SAIRA,IAAU,QACDpE,EAAAA,EACFoE,IAAU,MACnBpE,EAAWA,EAAWiD,EACbmB,IAAU,WACnBpE,EAAWA,EAAWiD,EAAO,GAG/B,IAAMoB,EAAiB,KAAK,QAAQ,WAChC,cACA,eAOEC,GANa,KAAK,cACpB,aAAc,KAAK,cACjB,KAAK,cAAc,SAAS,gBAAgBD,CAAc,EAC1D,KAAK,cAAcA,CAAc,EACnC,GAE2BpB,EAE/B,OAAO,KAAK,IAAI,KAAK,IAAIqB,EAAWtE,CAAQ,EAAG,CAAC,CAAA,EAG9B,KAAA,kBAAA,CAAC0B,EAAe0C,EAAyB,SAAW,CAC9D1C,EAAA,KAAK,IAAI,EAAG,KAAK,IAAIA,EAAO,KAAK,QAAQ,MAAQ,CAAC,CAAC,EAE3D,IAAMe,EAAO,KAAK,gBAAgB,EAAEf,CAAK,EACzC,GAAI,CAACe,EACI,OAGH,IAAAQ,EAAO,KAAK,QAAA,EACZI,EAAe,KAAK,gBAAA,EAE1B,GAAIe,IAAU,OACZ,GAAI3B,EAAK,KAAOY,EAAeJ,EAAO,KAAK,QAAQ,iBACzCmB,EAAA,cACC3B,EAAK,OAASY,EAAe,KAAK,QAAQ,mBAC3Ce,EAAA,YAED,OAAA,CAACf,EAAce,CAAK,EAIzB,IAAApE,EACJoE,IAAU,MACN3B,EAAK,IAAM,KAAK,QAAQ,iBACxBA,EAAK,MAAQ,KAAK,QAAQ,mBAEhC,MAAO,CAAC,KAAK,sBAAsBzC,EAAUoE,CAAK,EAAGA,CAAK,CAAA,EAG5D,KAAQ,cAAgB,IAAM,KAAK,cAAc,KAAO,EAExD,KAAQ,oBAAsB,IAAM,CAC9B,KAAK,yBAA2B,MAAQ,KAAK,eAC1C,KAAA,aAAa,aAAa,KAAK,sBAAsB,EAC1D,KAAK,uBAAyB,KAChC,EAGe,KAAA,eAAA,CACfpE,EACA,CAAE,MAAAoE,EAAQ,QAAS,SAAAtE,CAAS,EAA2B,CAAA,IACpD,CACH,KAAK,oBAAoB,EAErBA,IAAa,UAAY,KAAK,cAAA,GACxB,QAAA,KACN,wEAAA,EAIJ,KAAK,gBAAgB,KAAK,sBAAsBE,EAAUoE,CAAK,EAAG,CAChE,YAAa,OACb,SAAAtE,CAAA,CACD,CAAA,EAGa,KAAA,cAAA,CACd4B,EACA,CAAE,MAAO6C,EAAe,OAAQ,SAAAzE,CAAmC,EAAA,CAAA,IAChE,CACK4B,EAAA,KAAK,IAAI,EAAG,KAAK,IAAIA,EAAO,KAAK,QAAQ,MAAQ,CAAC,CAAC,EAE3D,KAAK,oBAAoB,EAErB5B,IAAa,UAAY,KAAK,cAAA,GACxB,QAAA,KACN,wEAAA,EAIJ,IAAM0E,EAAiB,KAAK,kBAAkB9C,EAAO6C,CAAY,EACjE,GAAI,CAACC,EAAgB,OAEf,GAAA,CAAC5E,EAAQwE,CAAK,EAAII,EAExB,KAAK,gBAAgB5E,EAAQ,CAAE,YAAa,OAAW,SAAAE,CAAA,CAAU,EAE7DA,IAAa,UAAY,KAAK,cAAc,GAAK,KAAK,eACxD,KAAK,uBAAyB,KAAK,aAAa,WAAW,IAAM,CAO/D,GANA,KAAK,uBAAyB,KAET,KAAK,cAAc,IACtC,KAAK,QAAQ,WAAW4B,CAAK,CAAA,EAGb,CACV,GAAA,CAAC+C,CAAY,EAAIP,GACrB,KAAK,kBAAkBxC,EAAO0C,CAAK,CAAA,EAGhCM,GAAYD,EAAc,KAAK,gBAAiB,CAAA,GACnD,KAAK,cAAc/C,EAAO,CAAE,MAAA0C,EAAO,SAAAtE,CAAU,CAAA,CAC/C,MAEA,KAAK,cAAc4B,EAAO,CAAE,MAAA0C,EAAO,SAAAtE,CAAU,CAAA,CAC/C,CACD,EACH,EAGF,KAAA,SAAW,CAAC+D,EAAe,CAAE,SAAA/D,CAAS,EAA2B,CAAA,IAAO,CACtE,KAAK,oBAAoB,EAErBA,IAAa,UAAY,KAAK,cAAA,GACxB,QAAA,KACN,wEAAA,EAIJ,KAAK,gBAAgB,KAAK,gBAAgB,EAAI+D,EAAO,CACnD,YAAa,OACb,SAAA/D,CAAA,CACD,CAAA,EAGH,KAAA,aAAe,IAAM,OACb,IAAA2B,EAAe,KAAK,gBAAA,EAEtByB,EAEA,OAAAzB,EAAa,SAAW,EAC1ByB,EAAM,KAAK,QAAQ,aAIjBA,EAAA,KAAK,QAAQ,QAAU,IACnBhD,EAAAuB,EAAaA,EAAa,OAAS,CAAC,IAApC,KAAA,OAAAvB,EAAuC,MAAO,EAC9C,KAAK,IACH,GAAGuB,EAAa,MAAM,CAAC,KAAK,QAAQ,KAAK,EAAE,IAAKI,GAAMA,EAAE,GAAG,CAAA,EAI9DqB,EAAM,KAAK,QAAQ,aAAe,KAAK,QAAQ,UAAA,EAGhD,KAAA,gBAAkB,CACxBtD,EACA,CACE,YAAAC,EACA,SAAAC,CAAA,IAKC,CACH,KAAK,QAAQ,WAAWF,EAAQ,CAAE,SAAAE,EAAU,YAAAD,CAAA,EAAe,IAAI,CAAA,EAGjE,KAAA,QAAU,IAAM,SACT,KAAA,cAAA,IAAoB,KACpBI,GAAAC,EAAA,KAAA,SAAQ,WAAR,MAAAD,EAAA,KAAAC,EAAmB,KAAM,EAAA,CAAK,EAjpBnC,KAAK,WAAWE,CAAI,CACtB,CAkpBF,EAEM+D,GAA0B,CAC9BQ,EACAC,EACAC,EACAlE,IACG,CACH,KAAOgE,GAAOC,GAAM,CACZ,IAAAE,GAAWH,EAAMC,GAAQ,EAAK,EAC9BG,EAAeF,EAAgBC,CAAM,EAE3C,GAAIC,EAAepE,EACjBgE,EAAMG,EAAS,UACNC,EAAepE,EACxBiE,EAAOE,EAAS,MAET,QAAAA,CAEX,CAEA,OAAIH,EAAM,EACDA,EAAM,EAEN,CAEX,EAEA,SAASrB,GAA6C,CACpD,aAAA7B,EACA,UAAA2B,EACA,aAAAC,CACF,EAIG,CACK,IAAAlB,EAAQV,EAAa,OAAS,EAG9BR,EAAakD,GAAwB,EAAGhC,EAF3BT,GAAkBD,EAAaC,CAAK,EAAG,MAEM2B,CAAY,EACxEnC,EAAWD,EAEf,KACEC,EAAWiB,GACXV,EAAaP,CAAQ,EAAG,IAAMmC,EAAeD,GAE7ClC,IAGK,MAAA,CAAE,WAAAD,EAAY,SAAAC,CAAA,CACvB,CCjjCA,IAAM8D,GACJ,OAAO,SAAa,IAAoBC,GAAwBC,EAElE,SAASC,GAIPC,EAC2C,CACrC,IAAAC,EAAiBC,GAAW,KAAO,CAAK,GAAA,CAAE,CAAA,EAAE,CAAC,EAE7CC,EAAoE,CACxE,GAAGH,EACH,SAAU,CAACI,EAAUC,IAAS,OACxBA,EACFC,GAAUL,CAAQ,EAETA,EAAA,GAEHM,EAAAP,EAAA,WAAA,MAAAO,EAAA,KAAAP,EAAWI,EAAUC,CAAA,CAC/B,CAAA,EAGI,CAACD,CAAQ,EAAUI,EACvB,IAAM,IAAIC,GAA0CN,CAAe,CAAA,EAGrE,OAAAC,EAAS,WAAWD,CAAe,EAE7BL,EAAU,IACPM,EAAS,UAAA,EACf,CAAE,CAAA,EAELR,GAA0B,IACjBQ,EAAS,YAAA,CACjB,EAEMA,CACT,CAEO,SAASM,GAIdV,EAI2C,CAC3C,OAAOD,GAAiD,CACtD,mBAAAY,GACA,qBAAAC,GACA,WAAYC,GACZ,GAAGb,CAAA,CACJ,CACH,CCpEO,SAASc,GAAWC,EAAW,CACrC,MAAO,CAEN,OAAQ,SAAUC,EAAU,CAC3BC,GAAOD,EAAUD,CAAS,CAC3B,EAEA,QAAS,UAAY,CACpBG,GAAuBH,CAAS,CACjC,CACD,CACD,CCRO,IAAMI,GAAyB,OAAO,IAAI,eAAe,EAUnDC,GAA2B,OAAO,IAAI,iBAAiB,EAEvDC,EAA6B,OAAO,IAAI,aAAa,ECqB3D,SAASC,GAAIC,KAAkBC,EAAoB,CAMzD,MAAM,IAAI,MACT,8BAA8BD,CAAA,yCAC/B,CACD,CClCO,IAAME,GAAiB,OAAO,eAI9B,SAASC,GAAQC,EAAqB,CAC5C,MAAO,CAAC,CAACA,GAAS,CAAC,CAACA,EAAMC,CAAW,CACtC,CAIO,SAASC,GAAYF,EAAqB,CAChD,OAAKA,EAEJG,GAAcH,CAAK,GACnB,MAAM,QAAQA,CAAK,GACnB,CAAC,CAACA,EAAMI,EAAS,GACjB,CAAC,CAACJ,EAAM,cAAcI,EAAS,GAC/BC,GAAML,CAAK,GACXM,GAAMN,CAAK,EAPO,EASpB,CAEA,IAAMO,GAAmB,OAAO,UAAU,YAAY,SAAS,EAExD,SAASJ,GAAcH,EAAqB,CAClD,GAAI,CAACA,GAAS,OAAOA,GAAU,SAAU,MAAO,GAChD,IAAMQ,EAAQV,GAAeE,CAAK,EAClC,GAAIQ,IAAU,KACb,MAAO,GAER,IAAMC,EACL,OAAO,eAAe,KAAKD,EAAO,aAAa,GAAKA,EAAM,YAE3D,OAAIC,IAAS,OAAe,GAG3B,OAAOA,GAAQ,YACf,SAAS,SAAS,KAAKA,CAAI,IAAMF,EAEnC,CAeO,SAASG,GAAKC,EAAUC,EAAW,CACrCC,GAAYF,CAAG,IAAA,EAClB,OAAO,QAAQA,CAAG,EAAE,QAAQ,CAAC,CAACG,EAAKC,CAAK,IAAM,CAC7CH,EAAKE,EAAKC,EAAOJ,CAAG,CACrB,CAAC,EAEDA,EAAI,QAAQ,CAACK,EAAYC,IAAeL,EAAKK,EAAOD,EAAOL,CAAG,CAAC,CAEjE,CAGO,SAASE,GAAYK,EAAsB,CACjD,IAAMC,EAAgCD,EAAME,CAAW,EACvD,OAAOD,EACJA,EAAM,MACN,MAAM,QAAQD,CAAK,EAAA,EAEnBG,GAAMH,CAAK,EAAA,EAEXI,GAAMJ,CAAK,EAAA,EAAA,CAGf,CAGO,SAASK,GAAIL,EAAYM,EAA4B,CAC3D,OAAOX,GAAYK,CAAK,IAAA,EACrBA,EAAM,IAAIM,CAAI,EACd,OAAO,UAAU,eAAe,KAAKN,EAAOM,CAAI,CACpD,CASO,SAASC,GAAIC,EAAYC,EAA6BC,EAAY,CACxE,IAAMC,EAAIC,GAAYJ,CAAK,EACvBG,IAAA,EAAoBH,EAAM,IAAIC,EAAgBC,CAAK,EAC9CC,IAAA,EACRH,EAAM,IAAIE,CAAK,EACTF,EAAMC,CAAc,EAAIC,CAChC,CAGO,SAASG,GAAGC,EAAQC,EAAiB,CAE3C,OAAID,IAAMC,EACFD,IAAM,GAAK,EAAIA,IAAM,EAAIC,EAEzBD,IAAMA,GAAKC,IAAMA,CAE1B,CAGO,SAASC,GAAMC,EAA+B,CACpD,OAAOA,aAAkB,GAC1B,CAGO,SAASC,GAAMD,EAA+B,CACpD,OAAOA,aAAkB,GAC1B,CAEO,SAASE,EAAOC,EAAwB,CAC9C,OAAOA,EAAM,OAASA,EAAM,KAC7B,CAGO,SAASC,GAAYC,EAAWC,EAAiB,CACvD,GAAIP,GAAMM,CAAI,EACb,OAAO,IAAI,IAAIA,CAAI,EAEpB,GAAIJ,GAAMI,CAAI,EACb,OAAO,IAAI,IAAIA,CAAI,EAEpB,GAAI,MAAM,QAAQA,CAAI,EAAG,OAAO,MAAM,UAAU,MAAM,KAAKA,CAAI,EAE/D,GAAI,CAACC,GAAUC,GAAcF,CAAI,EAChC,OAAKG,GAAeH,CAAI,EAIjB,CAAC,GAAGA,CAAI,EAFP,OAAO,OADF,OAAO,OAAO,IAAI,EACJA,CAAI,EAKhC,IAAMI,EAAc,OAAO,0BAA0BJ,CAAI,EACzD,OAAOI,EAAYC,CAAkB,EACrC,IAAIC,EAAO,QAAQ,QAAQF,CAAW,EACtC,QAASG,EAAI,EAAGA,EAAID,EAAK,OAAQC,IAAK,CACrC,IAAMC,EAAWF,EAAKC,CAAC,EACjBE,EAAOL,EAAYI,CAAG,EACxBC,EAAK,WAAa,KACrBA,EAAK,SAAW,GAChBA,EAAK,aAAe,KAKjBA,EAAK,KAAOA,EAAK,OACpBL,EAAYI,CAAG,EAAI,CAClB,aAAc,GACd,SAAU,GACV,WAAYC,EAAK,WACjB,MAAOT,EAAKQ,CAAG,CAChB,EACF,CACA,OAAO,OAAO,OAAOL,GAAeH,CAAI,EAAGI,CAAW,CACvD,CAUO,SAASM,GAAUC,EAAUC,EAAgB,GAAU,CAC7D,OAAIC,GAASF,CAAG,GAAKG,GAAQH,CAAG,GAAK,CAACI,GAAYJ,CAAG,IACjDrB,GAAYqB,CAAG,EAAI,IACtBA,EAAI,IAAMA,EAAI,IAAMA,EAAI,MAAQA,EAAI,OAASK,IAE9C,OAAO,OAAOL,CAAG,EACbC,GAAMK,GAAKN,EAAK,CAACO,EAAM9B,IAAUsB,GAAOtB,EAAO,EAAI,EAAG,EAAI,GACvDuB,CACR,CAEA,SAASK,IAA8B,CACtCG,GAAI,CAAC,CACN,CAEO,SAASN,GAASF,EAAmB,CAC3C,OAAO,OAAO,SAASA,CAAG,CAC3B,CC/LA,IAAMS,GAoBF,CAAC,EAIE,SAASC,GACfC,EACiC,CACjC,IAAMC,EAASH,GAAQE,CAAS,EAChC,OAAKC,GACJJ,GAAI,EAAGG,CAAS,EAGVC,CACR,CAEO,SAASC,GACfF,EACAG,EACO,CACFL,GAAQE,CAAS,IAAGF,GAAQE,CAAS,EAAIG,EAC/C,CC5BA,IAAIC,GAEG,SAASC,IAAkB,CACjC,OAAOD,EACR,CAEA,SAASE,GACRC,EACAC,EACa,CACb,MAAO,CACN,QAAS,CAAC,EACV,QAAAD,EACA,OAAAC,EAGA,eAAgB,GAChB,mBAAoB,CACrB,CACD,CAEO,SAASC,GACfC,EACAC,EACC,CACGA,IACHZ,GAAU,SAAS,EACnBW,EAAM,SAAW,CAAC,EAClBA,EAAM,gBAAkB,CAAC,EACzBA,EAAM,eAAiBC,EAEzB,CAEO,SAASC,GAAYF,EAAmB,CAC9CG,GAAWH,CAAK,EAChBA,EAAM,QAAQ,QAAQI,EAAW,EAEjCJ,EAAM,QAAU,IACjB,CAEO,SAASG,GAAWH,EAAmB,CACzCA,IAAUN,KACbA,GAAeM,EAAM,QAEvB,CAEO,SAASK,GAAWC,EAAc,CACxC,OAAQZ,GAAeE,GAAYF,GAAcY,CAAK,CACvD,CAEA,SAASF,GAAYG,EAAgB,CACpC,IAAMzC,EAAoByC,EAAMlC,CAAW,EACvCP,EAAM,QAAA,GAA6BA,EAAM,QAAA,EAC5CA,EAAM,QAAQ,EACVA,EAAM,SAAW,EACvB,CC3DO,SAAS0C,GAAcC,EAAaT,EAAmB,CAC7DA,EAAM,mBAAqBA,EAAM,QAAQ,OACzC,IAAMU,EAAYV,EAAM,QAAS,CAAC,EAElC,OADmBS,IAAW,QAAaA,IAAWC,GAEjDA,EAAUrC,CAAW,EAAE,YAC1B6B,GAAYF,CAAK,EACjBb,GAAI,CAAC,GAEFJ,GAAY0B,CAAM,IAErBA,EAASE,GAASX,EAAOS,CAAM,EAC1BT,EAAM,SAASY,GAAYZ,EAAOS,CAAM,GAE1CT,EAAM,UACTX,GAAU,SAAS,EAAE,4BACpBqB,EAAUrC,CAAW,EAAE,MACvBoC,EACAT,EAAM,SACNA,EAAM,eACP,GAIDS,EAASE,GAASX,EAAOU,EAAW,CAAC,CAAC,EAEvCR,GAAYF,CAAK,EACbA,EAAM,UACTA,EAAM,eAAgBA,EAAM,SAAUA,EAAM,eAAgB,EAEtDS,IAAWI,GAAUJ,EAAS,MACtC,CAEA,SAASE,GAASG,EAAuB1D,EAAY2D,EAAkB,CAEtE,GAAIlC,GAASzB,CAAK,EAAG,OAAOA,EAE5B,IAAMU,EAAoBV,EAAMiB,CAAW,EAE3C,GAAI,CAACP,EACJ,OAAAmB,GACC7B,EACA,CAACoB,EAAKwC,IACLC,GAAiBH,EAAWhD,EAAOV,EAAOoB,EAAKwC,EAAYD,CAAI,EAChE,EACD,EACO3D,EAGR,GAAIU,EAAM,SAAWgD,EAAW,OAAO1D,EAEvC,GAAI,CAACU,EAAM,UACV,OAAA8C,GAAYE,EAAWhD,EAAM,MAAO,EAAI,EACjCA,EAAM,MAGd,GAAI,CAACA,EAAM,WAAY,CACtBA,EAAM,WAAa,GACnBA,EAAM,OAAO,qBACb,IAAM2C,EAAS3C,EAAM,MAKjBoD,EAAaT,EACb7C,EAAQ,GACRE,EAAM,QAAA,IACToD,EAAa,IAAI,IAAIT,CAAM,EAC3BA,EAAO,MAAM,EACb7C,EAAQ,IAETqB,GAAKiC,EAAY,CAAC1C,EAAKwC,IACtBC,GAAiBH,EAAWhD,EAAO2C,EAAQjC,EAAKwC,EAAYD,EAAMnD,CAAK,CACxE,EAEAgD,GAAYE,EAAWL,EAAQ,EAAK,EAEhCM,GAAQD,EAAU,UACrBzB,GAAU,SAAS,EAAE,iBACpBvB,EACAiD,EACAD,EAAU,SACVA,EAAU,eACX,CAEF,CACA,OAAOhD,EAAM,KACd,CAEA,SAASmD,GACRH,EACAK,EACAC,EACAC,EACAL,EACAM,EACAC,EACC,CAGD,GAAIzC,GAAQkC,CAAU,EAAG,CACxB,IAAMD,EACLO,GACAH,GACAA,EAAa,QAAA,GACb,CAACK,GAAKL,EAA8C,UAAYE,CAAI,EACjEC,EAAU,OAAOD,CAAI,EACrB,OAEEI,EAAMd,GAASG,EAAWE,EAAYD,CAAI,EAIhD,GAHA9D,GAAImE,EAAcC,EAAMI,CAAG,EAGvB3C,GAAQ2C,CAAG,EACdX,EAAU,eAAiB,OACrB,OACR,MAAWS,GACVH,EAAa,IAAIJ,CAAU,EAG5B,GAAIjC,GAAYiC,CAAU,GAAK,CAACnC,GAASmC,CAAU,EAAG,CACrD,GAAI,CAACF,EAAU,OAAO,aAAeA,EAAU,mBAAqB,EAMnE,OAEDH,GAASG,EAAWE,CAAU,GAE1B,CAACG,GAAe,CAACA,EAAY,OAAO,UACvCP,GAAYE,EAAWE,CAAU,CACnC,CACD,CAEA,SAASJ,GAAYZ,EAAmB5C,EAAYwB,EAAO,GAAO,CAE7D,CAACoB,EAAM,SAAWA,EAAM,OAAO,aAAeA,EAAM,gBACvDtB,GAAOtB,EAAOwB,CAAI,CAEpB,CC9GO,SAAS8C,GACf1D,EACA2D,EACyB,CACzB,IAAMC,EAAU,MAAM,QAAQ5D,CAAI,EAC5BF,EAAoB,CACzB,MAAO8D,EAAA,EAAA,EAEP,OAAQD,EAASA,EAAO,OAAShC,GAAgB,EAEjD,UAAW,GAEX,WAAY,GAEZ,UAAW,CAAC,EAEZ,QAASgC,EAET,MAAO3D,EAEP,OAAQ,KAER,MAAO,KAEP,QAAS,KACT,UAAW,EACZ,EAQIL,EAAYG,EACZ+D,EAA2CC,GAC3CF,IACHjE,EAAS,CAACG,CAAK,EACf+D,EAAQE,IAGT,GAAM,CAAC,OAAAC,EAAQ,MAAAC,CAAK,EAAI,MAAM,UAAUtE,EAAQkE,CAAK,EACrD,OAAA/D,EAAM,OAASmE,EACfnE,EAAM,QAAUkE,EACTC,CACR,CAKO,IAAMH,GAAwC,CACpD,IAAIhE,EAAOuD,EAAM,CAChB,GAAIA,IAAShD,EAAa,OAAOP,EAEjC,IAAMoE,EAASrE,EAAOC,CAAK,EAC3B,GAAI,CAAC0D,GAAIU,EAAQb,CAAI,EAEpB,OAAOc,GAAkBrE,EAAOoE,EAAQb,CAAI,EAE7C,IAAMjE,EAAQ8E,EAAOb,CAAI,EACzB,OAAIvD,EAAM,YAAc,CAACiB,GAAY3B,CAAK,EAClCA,EAIJA,IAAUgF,GAAKtE,EAAM,MAAOuD,CAAI,GACnCgB,GAAYvE,CAAK,EACTA,EAAM,MAAOuD,CAAW,EAAIiB,GAAYlF,EAAOU,CAAK,GAEtDV,CACR,EACA,IAAIU,EAAOuD,EAAM,CAChB,OAAOA,KAAQxD,EAAOC,CAAK,CAC5B,EACA,QAAQA,EAAO,CACd,OAAO,QAAQ,QAAQD,EAAOC,CAAK,CAAC,CACrC,EACA,IACCA,EACAuD,EACAjE,EACC,CACD,IAAMqB,EAAO8D,GAAuB1E,EAAOC,CAAK,EAAGuD,CAAI,EACvD,GAAI5C,GAAM,IAGT,OAAAA,EAAK,IAAI,KAAKX,EAAM,OAAQV,CAAK,EAC1B,GAER,GAAI,CAACU,EAAM,UAAW,CAGrB,IAAM0E,EAAUJ,GAAKvE,EAAOC,CAAK,EAAGuD,CAAI,EAElCoB,EAAiCD,IAAUnE,CAAW,EAC5D,GAAIoE,GAAgBA,EAAa,QAAUrF,EAC1C,OAAAU,EAAM,MAAOuD,CAAI,EAAIjE,EACrBU,EAAM,UAAUuD,CAAI,EAAI,GACjB,GAER,GAAI9D,GAAGH,EAAOoF,CAAO,IAAMpF,IAAU,QAAaoE,GAAI1D,EAAM,MAAOuD,CAAI,GACtE,MAAO,GACRgB,GAAYvE,CAAK,EACjB4E,GAAY5E,CAAK,CAClB,CAEA,OACEA,EAAM,MAAOuD,CAAI,IAAMjE,IAEtBA,IAAU,QAAaiE,KAAQvD,EAAM,QAEtC,OAAO,MAAMV,CAAK,GAAK,OAAO,MAAMU,EAAM,MAAOuD,CAAI,CAAC,IAKxDvD,EAAM,MAAOuD,CAAI,EAAIjE,EACrBU,EAAM,UAAUuD,CAAI,EAAI,IACjB,EACR,EACA,eAAevD,EAAOuD,EAAc,CAEnC,OAAIe,GAAKtE,EAAM,MAAOuD,CAAI,IAAM,QAAaA,KAAQvD,EAAM,OAC1DA,EAAM,UAAUuD,CAAI,EAAI,GACxBgB,GAAYvE,CAAK,EACjB4E,GAAY5E,CAAK,GAGjB,OAAOA,EAAM,UAAUuD,CAAI,EAExBvD,EAAM,OACT,OAAOA,EAAM,MAAMuD,CAAI,EAEjB,EACR,EAGA,yBAAyBvD,EAAOuD,EAAM,CACrC,IAAMsB,EAAQ9E,EAAOC,CAAK,EACpBW,EAAO,QAAQ,yBAAyBkE,EAAOtB,CAAI,EACzD,OAAK5C,GACE,CACN,SAAU,GACV,aAAcX,EAAM,QAAA,GAA4BuD,IAAS,SACzD,WAAY5C,EAAK,WACjB,MAAOkE,EAAMtB,CAAI,CAClB,CACD,EACA,gBAAiB,CAChBlC,GAAI,EAAE,CACP,EACA,eAAerB,EAAO,CACrB,OAAOK,GAAeL,EAAM,KAAK,CAClC,EACA,gBAAiB,CAChBqB,GAAI,EAAE,CACP,CACD,EAMM4C,GAA8C,CAAC,EACrD9C,GAAK6C,GAAa,CAACtD,EAAKoE,IAAO,CAE9Bb,GAAWvD,CAAG,EAAI,UAAW,CAC5B,iBAAU,CAAC,EAAI,UAAU,CAAC,EAAE,CAAC,EACtBoE,EAAG,MAAM,KAAM,SAAS,CAChC,CACD,CAAC,EACDb,GAAW,eAAiB,SAASjE,EAAOuD,EAAM,CAIjD,OAAOU,GAAW,IAAK,KAAK,KAAMjE,EAAOuD,EAAM,MAAS,CACzD,EACAU,GAAW,IAAM,SAASjE,EAAOuD,EAAMjE,EAAO,CAO7C,OAAO0E,GAAY,IAAK,KAAK,KAAMhE,EAAM,CAAC,EAAGuD,EAAMjE,EAAOU,EAAM,CAAC,CAAC,CACnE,EAGA,SAASsE,GAAK7B,EAAgBc,EAAmB,CAChD,IAAMvD,EAAQyC,EAAMlC,CAAW,EAE/B,OADeP,EAAQD,EAAOC,CAAK,EAAIyC,GACzBc,CAAI,CACnB,CAEA,SAASc,GAAkBrE,EAAmBoE,EAAab,EAAmB,CAC7E,IAAM5C,EAAO8D,GAAuBL,EAAQb,CAAI,EAChD,OAAO5C,EACJ,UAAWA,EACVA,EAAK,MAGLA,EAAK,KAAK,KAAKX,EAAM,MAAM,EAC5B,MACJ,CAEA,SAASyE,GACRL,EACAb,EACiC,CAEjC,GAAI,EAAEA,KAAQa,GAAS,OACvB,IAAIW,EAAQ1E,GAAe+D,CAAM,EACjC,KAAOW,GAAO,CACb,IAAMpE,EAAO,OAAO,yBAAyBoE,EAAOxB,CAAI,EACxD,GAAI5C,EAAM,OAAOA,EACjBoE,EAAQ1E,GAAe0E,CAAK,CAC7B,CAED,CAEO,SAASH,GAAY5E,EAAmB,CACzCA,EAAM,YACVA,EAAM,UAAY,GACdA,EAAM,SACT4E,GAAY5E,EAAM,OAAO,EAG5B,CAEO,SAASuE,GAAYvE,EAIzB,CACGA,EAAM,QACVA,EAAM,MAAQC,GACbD,EAAM,MACNA,EAAM,OAAO,OAAO,qBACrB,EAEF,CClQO,IAAMgF,GAAN,KAAoC,CAI1C,YAAYC,EAAiE,CAH7E,KAAA,YAAuB,GACvB,KAAA,sBAAiC,GA4BjC,KAAA,QAAoB,CAAC/E,EAAWgF,EAAc/C,IAAwB,CAErE,GAAI,OAAOjC,GAAS,YAAc,OAAOgF,GAAW,WAAY,CAC/D,IAAMC,EAAcD,EACpBA,EAAShF,EAET,IAAMkF,EAAO,KACb,OAAO,SAENlF,EAAOiF,KACJE,EACF,CACD,OAAOD,EAAK,QAAQlF,EAAOuC,GAAmByC,EAAO,KAAK,KAAMzC,EAAO,GAAG4C,CAAI,CAAC,CAChF,CACD,CAEI,OAAOH,GAAW,YAAY7D,GAAI,CAAC,EACnCc,IAAkB,QAAa,OAAOA,GAAkB,YAC3Dd,GAAI,CAAC,EAEN,IAAIsB,EAGJ,GAAI1B,GAAYf,CAAI,EAAG,CACtB,IAAMgC,EAAQK,GAAW,IAAI,EACvB4B,EAAQK,GAAYtE,EAAM,MAAS,EACrCoF,EAAW,GACf,GAAI,CACH3C,EAASuC,EAAOf,CAAK,EACrBmB,EAAW,EACZ,QAAA,CAEKA,EAAUlD,GAAYF,CAAK,EAC1BG,GAAWH,CAAK,CACtB,CACA,OAAAD,GAAkBC,EAAOC,CAAa,EAC/BO,GAAcC,EAAQT,CAAK,CACnC,SAAW,CAAChC,GAAQ,OAAOA,GAAS,SAAU,CAK7C,GAJAyC,EAASuC,EAAOhF,CAAI,EAChByC,IAAW,SAAWA,EAASzC,GAC/ByC,IAAWI,KAASJ,EAAS,QAC7B,KAAK,aAAa/B,GAAO+B,EAAQ,EAAI,EACrCR,EAAe,CAClB,IAAMoD,EAAa,CAAC,EACdC,EAAc,CAAC,EACrBjE,GAAU,SAAS,EAAE,4BAA4BrB,EAAMyC,EAAQ4C,EAAGC,CAAE,EACpErD,EAAcoD,EAAGC,CAAE,CACpB,CACA,OAAO7C,CACR,MAAOtB,GAAI,EAAGnB,CAAI,CACnB,EAEA,KAAA,mBAA0C,CAACA,EAAWgF,IAAsB,CAE3E,GAAI,OAAOhF,GAAS,WACnB,MAAO,CAACF,KAAeqF,IACtB,KAAK,mBAAmBrF,EAAQyC,GAAevC,EAAKuC,EAAO,GAAG4C,CAAI,CAAC,EAGrE,IAAII,EAAkBC,EAKtB,MAAO,CAJQ,KAAK,QAAQxF,EAAMgF,EAAQ,CAACK,EAAYC,IAAgB,CACtEC,EAAUF,EACVG,EAAiBF,CAClB,CAAC,EACeC,EAAUC,CAAe,CAC1C,EA1FK,OAAOT,GAAQ,YAAe,WACjC,KAAK,cAAcA,EAAQ,UAAU,EAClC,OAAOA,GAAQ,sBAAyB,WAC3C,KAAK,wBAAwBA,EAAQ,oBAAoB,CAC3D,CAwFA,YAAiC/E,EAAmB,CAC9Ce,GAAYf,CAAI,GAAGmB,GAAI,CAAC,EACzBL,GAAQd,CAAI,IAAGA,EAAOwE,GAAQxE,CAAI,GACtC,IAAMgC,EAAQK,GAAW,IAAI,EACvB4B,EAAQK,GAAYtE,EAAM,MAAS,EACzC,OAAAiE,EAAM5D,CAAW,EAAE,UAAY,GAC/B8B,GAAWH,CAAK,EACTiC,CACR,CAEA,YACC1B,EACAN,EACuC,CACvC,IAAMnC,EAAoByC,GAAUA,EAAclC,CAAW,GACzD,CAACP,GAAS,CAACA,EAAM,YAAWqB,GAAI,CAAC,EACrC,GAAM,CAAC,OAAQa,CAAK,EAAIlC,EACxB,OAAAiC,GAAkBC,EAAOC,CAAa,EAC/BO,GAAc,OAAWR,CAAK,CACtC,CAOA,cAAc5C,EAAgB,CAC7B,KAAK,YAAcA,CACpB,CAOA,wBAAwBA,EAAgB,CACvC,KAAK,sBAAwBA,CAC9B,CAEA,aAAkCY,EAASuF,EAAqB,CAG/D,IAAIhF,EACJ,IAAKA,EAAIgF,EAAQ,OAAS,EAAGhF,GAAK,EAAGA,IAAK,CACzC,IAAMkF,EAAQF,EAAQhF,CAAC,EACvB,GAAIkF,EAAM,KAAK,SAAW,GAAKA,EAAM,KAAO,UAAW,CACtDzF,EAAOyF,EAAM,MACb,KACD,CACD,CAGIlF,EAAI,KACPgF,EAAUA,EAAQ,MAAMhF,EAAI,CAAC,GAG9B,IAAMmF,EAAmBrE,GAAU,SAAS,EAAE,cAC9C,OAAIP,GAAQd,CAAI,EAER0F,EAAiB1F,EAAMuF,CAAO,EAG/B,KAAK,QAAQvF,EAAOuC,GAC1BmD,EAAiBnD,EAAOgD,CAAO,CAChC,CACD,CACD,EAEO,SAASjB,GACflF,EACAuE,EACyB,CAEzB,IAAMpB,EAAiB7C,GAAMN,CAAK,EAC/BiC,GAAU,QAAQ,EAAE,UAAUjC,EAAOuE,CAAM,EAC3C/D,GAAMR,CAAK,EACXiC,GAAU,QAAQ,EAAE,UAAUjC,EAAOuE,CAAM,EAC3CD,GAAiBtE,EAAOuE,CAAM,EAGjC,OADcA,EAASA,EAAO,OAAShC,GAAgB,GACjD,QAAQ,KAAKY,CAAK,EACjBA,CACR,CCtMO,SAASiC,GAAQpF,EAAiB,CACxC,OAAK0B,GAAQ1B,CAAK,GAAG+B,GAAI,GAAI/B,CAAK,EAC3BuG,GAAYvG,CAAK,CACzB,CAEA,SAASuG,GAAYvG,EAAiB,CACrC,GAAI,CAAC2B,GAAY3B,CAAK,GAAKyB,GAASzB,CAAK,EAAG,OAAOA,EACnD,IAAMU,EAAgCV,EAAMiB,CAAW,EACnDuF,EACJ,GAAI9F,EAAO,CACV,GAAI,CAACA,EAAM,UAAW,OAAOA,EAAM,MAEnCA,EAAM,WAAa,GACnB8F,EAAO7F,GAAYX,EAAOU,EAAM,OAAO,OAAO,qBAAqB,CACpE,MACC8F,EAAO7F,GAAYX,EAAO,EAAI,EAG/B,OAAA6B,GAAK2E,EAAM,CAACpF,EAAKwC,IAAe,CAC/B/D,GAAI2G,EAAMpF,EAAKmF,GAAY3C,CAAU,CAAC,CACvC,CAAC,EACGlD,IACHA,EAAM,WAAa,IAEb8F,CACR,CEpBO,SAASC,IAAe,CAC9B,MAAMC,UAAiB,GAAI,CAG1B,YAAYC,EAAgBC,EAAqB,CAChD,MAAM,EACN,KAAKC,CAAW,EAAI,CACnB,MAAA,EACA,QAASD,EACT,OAAQA,EAASA,EAAO,OAASE,GAAgB,EACjD,UAAW,GACX,WAAY,GACZ,MAAO,OACP,UAAW,OACX,MAAOH,EACP,OAAQ,KACR,UAAW,GACX,SAAU,EACX,CACD,CAEA,IAAI,MAAe,CAClB,OAAOI,EAAO,KAAKF,CAAW,CAAC,EAAE,IAClC,CAEA,IAAIG,EAAmB,CACtB,OAAOD,EAAO,KAAKF,CAAW,CAAC,EAAE,IAAIG,CAAG,CACzC,CAEA,IAAIA,EAAUC,EAAY,CACzB,IAAMC,EAAkB,KAAKL,CAAW,EACxC,OAAAM,EAAgBD,CAAK,GACjB,CAACH,EAAOG,CAAK,EAAE,IAAIF,CAAG,GAAKD,EAAOG,CAAK,EAAE,IAAIF,CAAG,IAAMC,KACzDG,EAAeF,CAAK,EACpBG,GAAYH,CAAK,EACjBA,EAAM,UAAW,IAAIF,EAAK,EAAI,EAC9BE,EAAM,MAAO,IAAIF,EAAKC,CAAK,EAC3BC,EAAM,UAAW,IAAIF,EAAK,EAAI,GAExB,IACR,CAEA,OAAOA,EAAmB,CACzB,GAAI,CAAC,KAAK,IAAIA,CAAG,EAChB,MAAO,GAGR,IAAME,EAAkB,KAAKL,CAAW,EACxC,OAAAM,EAAgBD,CAAK,EACrBE,EAAeF,CAAK,EACpBG,GAAYH,CAAK,EACbA,EAAM,MAAM,IAAIF,CAAG,EACtBE,EAAM,UAAW,IAAIF,EAAK,EAAK,EAE/BE,EAAM,UAAW,OAAOF,CAAG,EAE5BE,EAAM,MAAO,OAAOF,CAAG,EAChB,EACR,CAEA,OAAQ,CACP,IAAME,EAAkB,KAAKL,CAAW,EACxCM,EAAgBD,CAAK,EACjBH,EAAOG,CAAK,EAAE,OACjBE,EAAeF,CAAK,EACpBG,GAAYH,CAAK,EACjBA,EAAM,UAAY,IAAI,IACtBI,GAAKJ,EAAM,MAAOF,GAAO,CACxBE,EAAM,UAAW,IAAIF,EAAK,EAAK,CAChC,CAAC,EACDE,EAAM,MAAO,MAAM,EAErB,CAEA,QAAQK,EAA+CC,EAAe,CACrE,IAAMN,EAAkB,KAAKL,CAAW,EACxCE,EAAOG,CAAK,EAAE,QAAQ,CAACO,EAAaT,EAAUU,IAAc,CAC3DH,EAAG,KAAKC,EAAS,KAAK,IAAIR,CAAG,EAAGA,EAAK,IAAI,CAC1C,CAAC,CACF,CAEA,IAAIA,EAAe,CAClB,IAAME,EAAkB,KAAKL,CAAW,EACxCM,EAAgBD,CAAK,EACrB,IAAMD,EAAQF,EAAOG,CAAK,EAAE,IAAIF,CAAG,EAInC,GAHIE,EAAM,YAAc,CAACS,GAAYV,CAAK,GAGtCA,IAAUC,EAAM,MAAM,IAAIF,CAAG,EAChC,OAAOC,EAGR,IAAMW,EAAQC,GAAYZ,EAAOC,CAAK,EACtC,OAAAE,EAAeF,CAAK,EACpBA,EAAM,MAAO,IAAIF,EAAKY,CAAK,EACpBA,CACR,CAEA,MAA8B,CAC7B,OAAOb,EAAO,KAAKF,CAAW,CAAC,EAAE,KAAK,CACvC,CAEA,QAAgC,CAC/B,IAAMiB,EAAW,KAAK,KAAK,EAC3B,MAAO,CACN,CAAC,OAAO,QAAQ,EAAG,IAAM,KAAK,OAAO,EACrC,KAAM,IAAM,CACX,IAAMC,EAAID,EAAS,KAAK,EAExB,OAAIC,EAAE,KAAaA,EAEZ,CACN,KAAM,GACN,MAHa,KAAK,IAAIA,EAAE,KAAK,CAI9B,CACD,CACD,CACD,CAEA,SAAwC,CACvC,IAAMD,EAAW,KAAK,KAAK,EAC3B,MAAO,CACN,CAAC,OAAO,QAAQ,EAAG,IAAM,KAAK,QAAQ,EACtC,KAAM,IAAM,CACX,IAAMC,EAAID,EAAS,KAAK,EAExB,GAAIC,EAAE,KAAM,OAAOA,EACnB,IAAMd,EAAQ,KAAK,IAAIc,EAAE,KAAK,EAC9B,MAAO,CACN,KAAM,GACN,MAAO,CAACA,EAAE,MAAOd,CAAK,CACvB,CACD,CACD,CACD,CAEA,CAAC,OAAO,QAAQ,GAAI,CACnB,OAAO,KAAK,QAAQ,CACrB,CACD,CAEA,SAASe,EAA4BrB,EAAWC,EAAwB,CAEvE,OAAO,IAAIF,EAASC,EAAQC,CAAM,CACnC,CAEA,SAASQ,EAAeF,EAAiB,CACnCA,EAAM,QACVA,EAAM,UAAY,IAAI,IACtBA,EAAM,MAAQ,IAAI,IAAIA,EAAM,KAAK,EAEnC,CAEA,MAAMe,UAAiB,GAAI,CAE1B,YAAYtB,EAAgBC,EAAqB,CAChD,MAAM,EACN,KAAKC,CAAW,EAAI,CACnB,MAAA,EACA,QAASD,EACT,OAAQA,EAASA,EAAO,OAASE,GAAgB,EACjD,UAAW,GACX,WAAY,GACZ,MAAO,OACP,MAAOH,EACP,OAAQ,KACR,QAAS,IAAI,IACb,SAAU,GACV,UAAW,EACZ,CACD,CAEA,IAAI,MAAe,CAClB,OAAOI,EAAO,KAAKF,CAAW,CAAC,EAAE,IAClC,CAEA,IAAII,EAAqB,CACxB,IAAMC,EAAkB,KAAKL,CAAW,EAGxC,OAFAM,EAAgBD,CAAK,EAEhBA,EAAM,MAGP,GAAAA,EAAM,MAAM,IAAID,CAAK,GACrBC,EAAM,QAAQ,IAAID,CAAK,GAAKC,EAAM,MAAM,IAAIA,EAAM,QAAQ,IAAID,CAAK,CAAC,GAHhEC,EAAM,MAAM,IAAID,CAAK,CAM9B,CAEA,IAAIA,EAAiB,CACpB,IAAMC,EAAkB,KAAKL,CAAW,EACxC,OAAAM,EAAgBD,CAAK,EAChB,KAAK,IAAID,CAAK,IAClBiB,EAAehB,CAAK,EACpBG,GAAYH,CAAK,EACjBA,EAAM,MAAO,IAAID,CAAK,GAEhB,IACR,CAEA,OAAOA,EAAiB,CACvB,GAAI,CAAC,KAAK,IAAIA,CAAK,EAClB,MAAO,GAGR,IAAMC,EAAkB,KAAKL,CAAW,EACxC,OAAAM,EAAgBD,CAAK,EACrBgB,EAAehB,CAAK,EACpBG,GAAYH,CAAK,EAEhBA,EAAM,MAAO,OAAOD,CAAK,IACxBC,EAAM,QAAQ,IAAID,CAAK,EACrBC,EAAM,MAAO,OAAOA,EAAM,QAAQ,IAAID,CAAK,CAAC,EACjB,GAEhC,CAEA,OAAQ,CACP,IAAMC,EAAkB,KAAKL,CAAW,EACxCM,EAAgBD,CAAK,EACjBH,EAAOG,CAAK,EAAE,OACjBgB,EAAehB,CAAK,EACpBG,GAAYH,CAAK,EACjBA,EAAM,MAAO,MAAM,EAErB,CAEA,QAAgC,CAC/B,IAAMA,EAAkB,KAAKL,CAAW,EACxC,OAAAM,EAAgBD,CAAK,EACrBgB,EAAehB,CAAK,EACbA,EAAM,MAAO,OAAO,CAC5B,CAEA,SAAwC,CACvC,IAAMA,EAAkB,KAAKL,CAAW,EACxC,OAAAM,EAAgBD,CAAK,EACrBgB,EAAehB,CAAK,EACbA,EAAM,MAAO,QAAQ,CAC7B,CAEA,MAA8B,CAC7B,OAAO,KAAK,OAAO,CACpB,CAEA,CAAC,OAAO,QAAQ,GAAI,CACnB,OAAO,KAAK,OAAO,CACpB,CAEA,QAAQK,EAASC,EAAe,CAC/B,IAAMM,EAAW,KAAK,OAAO,EACzBK,EAASL,EAAS,KAAK,EAC3B,KAAO,CAACK,EAAO,MACdZ,EAAG,KAAKC,EAASW,EAAO,MAAOA,EAAO,MAAO,IAAI,EACjDA,EAASL,EAAS,KAAK,CAEzB,CACD,CACA,SAASM,EAA4BzB,EAAWC,EAAwB,CAEvE,OAAO,IAAIqB,EAAStB,EAAQC,CAAM,CACnC,CAEA,SAASsB,EAAehB,EAAiB,CACnCA,EAAM,QAEVA,EAAM,MAAQ,IAAI,IAClBA,EAAM,MAAM,QAAQD,GAAS,CAC5B,GAAIU,GAAYV,CAAK,EAAG,CACvB,IAAMW,EAAQC,GAAYZ,EAAOC,CAAK,EACtCA,EAAM,QAAQ,IAAID,EAAOW,CAAK,EAC9BV,EAAM,MAAO,IAAIU,CAAK,CACvB,MACCV,EAAM,MAAO,IAAID,CAAK,CAExB,CAAC,EAEH,CAEA,SAASE,EAAgBD,EAA+C,CACnEA,EAAM,UAAUmB,GAAI,EAAG,KAAK,UAAUtB,EAAOG,CAAK,CAAC,CAAC,CACzD,CAEAoB,GAAW,SAAU,CAAC,UAAAN,EAAW,UAAAI,CAAS,CAAC,CAC5C,CCxRA,IAAMG,GAAQ,IAAIC,GAqBLC,GAAoBF,GAAM,QAM1BG,GAA0CH,GAAM,mBAAmB,KAC/EA,EACD,EAOaI,GAAgBJ,GAAM,cAAc,KAAKA,EAAK,EAO9CK,GAA0BL,GAAM,wBAAwB,KAAKA,EAAK,EAOlEM,GAAeN,GAAM,aAAa,KAAKA,EAAK,EAM5CO,GAAcP,GAAM,YAAY,KAAKA,EAAK,EAU1CQ,GAAcR,GAAM,YAAY,KAAKA,EAAK,EChFjD,SAAUS,GAASC,EAAAA,CACvB,IAAAC,EAA2BC,EAAS,UAAA,CAAA,OAClCC,GAC0B,OAAjBH,GAAiB,WAAaA,EAAAA,EAAiBA,EAAAA,EACtD,CACD,CAAA,EAJSI,EAAWH,EAMvB,CAAA,EAAA,MAAO,CANGA,EAAA,CAAA,EAQRI,EAAY,SAACC,EAAAA,CACwBF,EAAZ,OAAZE,GAAY,WAAwBC,GAAQD,CAAAA,EACtCH,GAAOG,CAAAA,CAAAA,CAC1B,EAAG,CAAA,CAAA,CAAA,CAEP,CCQO,SAASE,GACdC,EACAC,EACAC,EACAC,EACAC,EACA,CACA,OAAO,MAAM,SAAU,YAAYJ,EAAQC,EAAMC,EAAWC,EAASC,CAAK,CAC5E,CAEO,SAASC,GAAmB,CACjC,OAAAL,EACA,KAAAC,EACA,MAAAG,CACF,EAIG,CACD,OAAO,IAAI,QAAQ,CAACE,EAASC,IAAW,CACtCR,GACEC,EACAC,EACCO,GAAyB,CACxBF,EAAQE,CAAK,CACf,EACCC,GAAgB,CACfF,EAAOE,CAAG,CACZ,EACAL,CACF,CACF,CAAC,CACH,CC1CO,SAASM,GAAe,CAC7B,QAAAC,EACA,WAAAC,EACA,oBAAAC,CACF,EAIS,CAEPF,EAASG,GAAU,CACjBF,EAAW,QAAQ,CAAC,CAAE,SAAAG,EAAU,YAAAC,EAAa,MAAAC,CAAM,IAAM,CACvDH,EAAMC,CAAQ,EAAGC,CAAW,EAAIC,CAClC,CAAC,CACH,CAAC,EAEDL,EAAW,QAAQ,CAAC,CAAE,SAAAG,EAAU,YAAAC,EAAa,MAAAC,CAAM,IAAM,CACvDJ,EAAoBE,EAAUC,EAAcE,GAAc,CACxDA,EAAU,MAAQD,EAClBC,EAAU,MAAQC,GAAc,YAEhCD,EAAU,WAAa,MACzB,CAAC,CACH,CAAC,CACH,CAEO,SAASE,GACdC,EACa,CAUb,OAT6BA,EAAU,IACpCC,IACQ,CACL,SAAUA,EAAM,UAChB,YAAaA,EAAM,aACnB,MAAOA,EAAM,KACf,EAEJ,CAEF,CAEO,SAASC,GACdC,EACe,CAQf,OAPiCA,EAAQ,IAAKF,IACrC,CACL,UAAWA,EAAM,SACjB,aAAcA,EAAM,YACpB,MAAOA,EAAM,KACf,EACD,CAEH,CAEO,SAASG,GAAgB,CAC9B,UAAAC,EACA,QAAAF,EACA,UAAAG,EACA,QAAAC,EACA,QAAAC,EACA,QAAAlB,EACA,oBAAAE,CACF,EAQG,CAID,IAAMQ,EAAYE,GAA6BC,CAAO,EAEtDM,GAAmB,CACjB,OAAQJ,EAAU,IAClB,KAAM,CAEJL,CACF,CACF,CAAC,EACE,KAAMU,GAAgC,CAErC,GAAI,CAAC,MAAM,QAAQA,CAAY,EAC7B,MAAM,IAAI,MAAM,0CAA0C,EAG5D,QAAWT,KAASS,EAClB,GACE,EAAE,cAAeT,GAAS,iBAAkBA,GAAS,UAAWA,GAEhE,MAAM,IAAI,MACR,8EACF,EAGJS,EAAeA,EAEf,IAAMnB,EAAaQ,GAA6BW,CAAY,EAI5DP,EAAQ,QAAQ,CAAC,CAAE,SAAAT,EAAU,YAAAC,EAAa,MAAAC,CAAM,IAAM,CACpDJ,EAAoBE,EAAUC,EAAcE,GAAc,CAGpDA,EAAU,QAAUC,GAAc,aAEtCD,EAAU,MAAQC,GAAc,MAChCD,EAAU,MAAQD,EAClBC,EAAU,WAAa,OACzB,CAAC,CACH,CAAC,EAGDR,GAAe,CAAE,QAAAC,EAAS,WAAAC,EAAY,oBAAAC,CAAoB,CAAC,EAE3Dc,EAAUf,CAAU,CACtB,CAAC,EACA,MAAOoB,GAAgB,CACtBR,EAAQ,QAAQ,CAAC,CAAE,SAAAT,EAAU,YAAAC,EAAa,MAAAC,CAAM,IAAM,CACpDJ,EAAoBE,EAAUC,EAAcE,GAAc,CACxDA,EAAU,MAAQ,OAAOD,CAAK,EAE9BC,EAAU,MAAQC,GAAc,YAChCD,EAAU,WAAa,OAAOc,CAAG,CACnC,CAAC,CACH,CAAC,EACDJ,EAAQI,CAAG,CACb,CAAC,CACL,CCzHO,IAAMC,GAAgB,CAC3B,WAAY,aACZ,YAAa,cACb,YAAa,cACb,QAAS,UACT,MAAO,OACT,EACaC,GAAqB,CAChC,WAAY,mBACZ,YAAa,oBACb,YAAa,oBACb,QAAS,oBACT,MAAO,MACT,EASMC,GAAeC,GAEjBA,IAAM,MACN,OAAOA,GAAM,UACb,OAAO,UAAU,eAAe,KAAKA,EAAG,aAAa,GACrDA,EAAE,cAAgB,GAIhBC,GAAoBC,GACpBA,IAAc,KAAa,GAC3BH,GAAYG,CAAS,EAAUA,EAAU,IAAI,KAC1CA,EAuBIC,GAAwC,CAAC,CACpD,aAAAC,EACA,MAAAC,EACA,KAAAC,EACA,UAAAC,EACA,QAAAC,EACA,QAAAC,EACA,SAAAC,EACA,YAAAC,EACA,mBAAAC,EACA,kBAAAC,EACA,aAAAC,EACA,UAAAC,EACA,cAAAC,EACA,QAAAC,EACA,oBAAAC,EACA,UAAAC,CACF,IAAM,CACJ,IAAMC,EAAed,EAAK,SAAS,EAK7Be,EAAef,EAAK,OAAO,UAAU,KAAM,aAE3CJ,EAAYY,GAAc,OAASM,EAEnCE,EAAYR,GAAc,OAASjB,GAAc,MACjD0B,EAAaT,GAAc,WAE3BU,EAAYV,GAAc,WAAa,GACvCW,EAAYX,GAAc,WAAab,GAAiBC,CAAS,EAEjEwB,EAAQC,EAAoC,IAAI,EAChDC,EAAWD,EAAmC,IAAI,EA+BlDE,EAAeC,EACnB,CACE,CACE,eAAAC,EAAiB,GACjB,eAAAC,EAAiB,EACnB,EAA4D,CAC1D,eAAgB,GAChB,eAAgB,EAClB,IACG,CACHd,EAAoBR,EAAUC,EAAcsB,GAAc,CACpDF,IAAgBE,EAAU,UAAY,IACtCD,IAAgBC,EAAU,UAAY,OAC5C,CAAC,CACH,EACA,CAACvB,EAAUC,EAAaO,CAAmB,CAC7C,EAEMgB,EAAaC,GAA+C,CAC5DA,EAAE,MAAQ,WAEdA,EAAE,eAAe,EACjBA,EAAE,gBAAgB,EAGlBN,EAAa,EACbV,EAAU,YAAYd,EAAO,CAAC,EAChC,EACM+B,EAAaD,GAA+C,CAChE,GAAIA,EAAE,MAAQ,MAAO,OAErBA,EAAE,eAAe,EACjBA,EAAE,gBAAgB,EAElB,IAAME,EAAWF,EAAE,SAEfG,EAAkB3B,EAEtB,OAAa,CACX,IAAM4B,EAAiBD,GAAmBD,EAAW,GAAK,GAE1D,GAAIE,EAAiB,GAAKA,GAAkB9B,EAAQ,OAElD,OAKF,GAFA6B,EAAkBC,EAEd9B,EAAQ8B,CAAc,EAAG,KAAM,eAAiB,GAClD,KAEJ,CAGAC,GAAc,EAGdtB,EAAoBR,EAAU4B,EAAkBL,GAAc,CAC5DA,EAAU,UAAY,EACxB,CAAC,CACH,EAEMQ,GAAeN,GAA+C,CAClE,GAAIA,EAAE,MAAQ,QAAS,OAEvBA,EAAE,eAAe,EACjBA,EAAE,gBAAgB,EAElB,IAAME,EAAWF,EAAE,SAEbO,EAAW7B,EAAkB,EAC7B8B,EAAiBD,EAAS,KAAK,UAAWE,IAAQA,GAAI,KAAOvC,CAAK,EAExE,GAAIsC,EAAiB,EACnB,OAEF,IAAME,GAAqBF,GAAmBN,EAAW,GAAK,GAE9D,GAAIQ,GAAqB,GAAKA,IAAsBH,EAAS,KAAK,OAEhE,OAIFF,GAAc,EAId,IAAMM,GAAiBJ,EAAS,KAAKG,EAAkB,EAAG,MAC1D3B,EAAoB4B,GAAgBnC,EAAcsB,IAAc,CAC9DA,GAAU,UAAY,EACxB,CAAC,CACH,EAEMc,GAAkBZ,GAA+C,CACrE,CAACD,EAAWO,GAAaL,CAAS,EAAE,QAASY,GAAOA,EAAGb,CAAC,CAAC,CAC3D,EAEMK,GAAgBV,EAAY,IAAM,CAOtC,GALAZ,EAAoBR,EAAUC,EAAcsB,GAAc,CACxDA,EAAU,WAAa,MACzB,CAAC,EAGG,GAAGhC,GAAiBC,CAAS,CAAC,IAAO,GAAGuB,CAAS,GAAI,CAEvDI,EAAa,EAEbX,EAAoBR,EAAUC,EAAcsB,GAAc,CACxDA,EAAU,MAAQX,CACpB,CAAC,EACD,MACF,CAGAO,EAAa,CAAE,eAAgB,EAAK,CAAC,EAGrCX,EAAoBR,EAAUC,EAAcsB,GAAc,CACxDA,EAAU,MAAQpC,GAAc,UAClC,CAAC,EAIDoD,GAAgB,CACd,UAAW1C,EACX,QAAS,CAAC,CAAE,SAAAG,EAAU,YAAAC,EAAa,MAAOc,CAAU,CAAC,EACrD,UAAYyB,GAAa,CAEvBrB,EAAa,CAAE,eAAgB,EAAK,CAAC,CAGvC,EACA,QAAUsB,GAAS,CAInB,EACA,QAAA3C,EACA,QAAAS,EACA,oBAAAC,CACF,CAAC,CACH,EAAG,CACDA,EACAR,EACAC,EACAT,EACAuB,EACAI,EACAtB,EACAC,EACAS,EACAK,CACF,CAAC,EAGD8B,EAAU,IAAM,CACT5B,GACAI,EAAS,UAEdA,EAAS,QAAQ,MAAM,EACvBA,EAAS,QAAQ,OAAO,EAC1B,EAAG,CAACJ,CAAS,CAAC,EAKd4B,EAAU,IAAM,CAGd,GAFI,CAAC5B,GACD,CAACE,EAAM,SACP,CAACE,EAAS,QAAS,OAIvB,IAAMyB,EAAyBlB,GAAkB,CAC1CT,EAAM,SAAS,SAASS,EAAE,MAAc,GAE7CA,EAAE,gBAAgB,CAIpB,EACMmB,EAAS5B,EAAM,QACrB4B,EAAO,iBAAiB,YAAaD,CAAqB,EAG1D,IAAME,EAAmBpB,GAAkB,CACrCA,EAAE,SAAWP,EAAS,UAE1BY,GAAc,EAEdX,EAAa,EACf,EACA,gBAAS,KAAK,iBAAiB,YAAa0B,CAAe,EAGpD,IAAM,CACXD,EAAO,oBAAoB,YAAaD,CAAqB,EAC7D,SAAS,KAAK,oBAAoB,YAAaE,CAAe,CAChE,CACF,EAAG,CACDjC,EACAkB,GACA9B,EACAC,EACAa,EACAK,CACF,CAAC,EAID,SAAS2B,GAAQrB,EAAyC,CACpDX,GACFW,EAAE,OAAO,OAAO,CAEpB,CAEA,SAASsB,GAAStB,EAA0C,CAE1DjB,EAAoBR,EAAUC,EAAcsB,GAAc,CACxDA,EAAU,UAAYE,EAAE,OAAO,KACjC,CAAC,CACH,CAsBA,IAAIuB,GAGAC,GAEEC,GAAYrC,EACdsC,GAAqC7C,EACnC8C,GAAuB9D,GAA0B,CAChDA,IACD6D,IACFA,IAAkB,IAClBA,IAAkB7D,GAElB6D,GAAiB7D,EAErB,EACA8D,GACEhE,GAAmB0B,EAAY3B,GAAc,QAAUyB,CAAS,CAClE,EACA,IAAIyC,GAAqB,GAErBC,GAAmC,KACvC,OAAI1C,IAAczB,GAAc,WAE9B8D,GAAUlC,GAEND,EACFwC,GACEC,EAAA,cAAC,YACC,MAAO,OAAOxC,CAAS,EACvB,SAAUgC,GAEV,QAASD,GACT,UAAWT,GACX,IAAKnB,EAEP,EAEOP,EACTyC,GAAoB,WAAW,EAK3BlD,IACFkD,GAAoB,eAAe,EACnCJ,GAAqBvB,GAA6C,CAOhEjB,EAAoBR,EAAUC,EAAcsB,GAAc,CACxDA,EAAU,UAAY,GACtBA,EAAU,UAAYhC,GAAiBC,CAAS,CAClD,CAAC,CACH,GAGAH,GAAYG,CAAS,EACvB6D,GAAqB,GAGrBJ,GAAUO,GAAW5D,EAAK,OAAO,UAAU,KAAMA,EAAK,WAAW,CAAC,GAItE8C,EAAU,IAAM,CAGd,GAFI,CAAC1B,EAAM,SACP,CAACqC,IACD,CAAChE,GAAYG,CAAS,EAAG,OAG7B,IAAMiE,EAAuB,KAAK,MAAM,KAAK,UAAUjE,EAAU,GAAG,CAAC,EAErE,OAAO,MAAM,mBAAmBwB,EAAM,QAASyC,CAAoB,EAEnE,IAAMC,EAAW1C,EAAM,QAEvB,MAAO,IAAM,CAEX,OAAO,MAAM,UAAW0C,CAAQ,EAEhCA,EAAS,gBAAgB,EAAE,CAC7B,CACF,EAAG,CAAC1C,EAAOxB,EAAWQ,EAAUC,EAAaoD,EAAkB,CAAC,EAG9DE,EAAA,cAAC,MACC,IAAKvC,EACL,cAAegC,GACf,MAAOE,GACP,UAAWC,GACX,MAAO,CAAE,GAAG9C,CAAU,GAErBiD,GACAL,EACH,CAEJ,ECxdO,IAAMU,GAAiB,IAAM,CAClC,GAAM,CAACC,EAAaC,CAAc,EAAIC,GACpC,IAAI,GACN,EACA,OAAAC,GAAa,EAeN,CACL,YAAAH,EAEA,oBAjB+C,CAC/CI,EACAC,EACAC,IACG,CACHL,EAAgBM,GAAU,CACxB,IAAMC,EAAMC,GAAmBL,EAAUC,CAAW,EAC9CK,EAAMH,EAAM,IAAIC,CAAG,GAAM,CAAC,EAChCF,EAAOI,CAAG,EAGVH,EAAM,IAAIC,EAAKE,CAAG,CACpB,CAAC,CACH,EAKE,iBAAkB,IAAM,CACtBT,EAAe,IAAI,GAAuB,CAC5C,CACF,CACF,EAEaQ,GAAqB,CAACL,EAAkBC,IAC5C,IAAID,CAAQ,KAAKC,CAAW,IAU9B,IAAMM,GAAoB,CAC/BC,EACAC,EACAC,IACuB,CACvB,IAAMC,EAAMC,GAAmBH,EAAUC,CAAW,EACpD,MAAO,CAACF,EAAE,IAAIG,CAAG,GAAM,CAAC,EAAgBA,CAAG,CAC7C,ECxEO,SAASE,GACdC,EACAC,EACAC,EAMA,CACA,IAAMC,EAAM,OAAO,OACjB,CAAE,IAAK,EAAG,MAAO,EAAG,OAAQ,EAAG,KAAM,CAAE,EACvCD,CACF,EACME,EAAYJ,EACZK,EAAMD,EAAU,UAAYD,EAAI,IAChCG,EAAOF,EAAU,WAAaD,EAAI,KAClCI,EAASF,EAAMD,EAAU,aAAeD,EAAI,IAAMA,EAAI,OACtDK,EAAQF,EAAOF,EAAU,YAAcD,EAAI,KAAOA,EAAI,MAE5D,QAASM,EAAI,EAAGA,EAAIR,EAAM,OAAQQ,IAAK,CACrC,IAAMC,EAAKT,EAAMQ,CAAC,EACZE,EAAID,EAAG,UACXE,EAAIF,EAAG,WACT,GAAIC,GAAKN,GAAOM,GAAKJ,GAAUK,GAAKN,GAAQM,GAAKJ,EAC/C,OAAOE,CAEX,CACA,OAAO,IACT,CAEO,SAASG,GAASH,EAAaI,EAAuC,CAI3E,OAAO,UAAU,aACb,iBAAiBJ,EAAI,IAAI,GACzB,iBAAiBI,CAAS,CAChC,CC1BO,IAAMC,GAAyCC,GAAU,CAC9D,GAAM,CAACC,EAASC,CAAU,EAAIC,EAAS,EAAK,EACtC,CAAE,MAAAC,EAAO,KAAAC,EAAM,GAAAC,EAAI,cAAAC,CAAc,EAAIP,EAE3C,OACEQ,EAAA,cAACC,GAAA,CACC,MAAOL,EACP,MAAO,CAACC,EAAMC,CAAE,EAChB,QAASL,EACT,cAAgBS,GAAMH,EAAc,GAAGG,CAAC,EACxC,QAAS,IAAMR,EAAW,EAAI,EAC9B,OAAQ,IAAMA,EAAW,EAAK,EAChC,CAEJ,EAuBA,IAAMS,GAAuDC,GAAU,CACrE,GAAM,CAACC,EAAKC,CAAG,EAAIF,EAAM,MACnB,CAAE,QAAAG,EAAS,QAAAC,CAAQ,EAAIJ,EACvB,CAACK,EAAUC,CAAQ,EAAIN,EAAM,MAAM,EAEnCO,EAAcC,EAAyB,IAAI,EAC3CC,EAAcD,EAAyB,IAAI,EAEjD,OACEE,EAAA,cAAC,OACC,OAASC,GAAM,CACb,GAAI,CAAAA,EAAE,cAAc,SAASA,EAAE,aAAa,EAG5C,OAAOX,EAAM,OAAO,CACtB,EACA,QAAS,IAAMI,EAAQ,EACvB,MAAO,CACL,QAAS,OACT,IAAK,QACP,GAEAM,EAAA,cAAC,SACC,IAAKH,EACL,UAAW,gCACTA,EAAY,SAAS,cAAc,EAAI,GAAK,YAC9C,GACA,MAAO,CAAE,KAAM,QAAS,MAAO,GAAI,EACnC,KAAK,SACL,YAAaK,GAAkBT,EAAS,MAAOE,CAAQ,EACvD,aAAcJ,EAGd,KAAK,MACL,SAAWU,GAAM,CACf,IAAME,EAAQC,GAAYH,EAAE,OAAO,KAAK,EACnCJ,EAAY,UACjBA,EAAY,QAAQ,UAAU,OAC5B,aACA,CAACI,EAAE,OAAO,cAAc,CAC1B,EACAX,EAAM,cAAc,CAACa,EAAOX,CAAG,CAAC,EAClC,EACF,EACAQ,EAAA,cAAC,SACC,IAAKD,EACL,UAAW,gCACTA,EAAY,SAAS,cAAc,EAAI,GAAK,YAC9C,GACA,MAAO,CAAE,KAAM,QAAS,MAAO,GAAI,EACnC,KAAK,SACL,YAAaG,GAAkBT,EAAS,MAAOG,CAAQ,EACvD,aAAcJ,EAGd,KAAK,MACL,SAAWS,GAAM,CACf,IAAME,EAAQC,GAAYH,EAAE,OAAO,KAAK,EACnCF,EAAY,UACjBA,EAAY,QAAQ,UAAU,OAC5B,aACA,CAACE,EAAE,OAAO,cAAc,CAC1B,EACAX,EAAM,cAAc,CAACC,EAAKY,CAAK,CAAC,EAClC,EACF,CACF,CAEJ,EAEA,SAASD,GACPT,EACAY,EACAF,EACA,CACA,GAAKV,EAEE,OAAI,OAAOU,EAAU,IACnBE,EAEA,GAAGA,CAAK,KAAKF,CAAK,GAE7B,CAEA,SAASC,GAAYD,EAAmC,CACtD,GAAIA,IAAU,GAGd,MAAO,CAACA,CACV,CCrHO,SAASG,GAAkBC,EAKhC,CACA,GAAM,CAACC,EAAeC,CAAgB,EAAIC,EAA6B,CAAC,CAAC,EAEnEC,EAAsBJ,EACxB,CACE,oBAAqBK,GAA2B,EAChD,mBAAoBC,GAA0B,EAC9C,uBAAwBC,GAA8B,EACtD,uBAAwBC,GAA8B,EACtD,UAAW,CACT,UAAW,CACTC,EACAC,EACAC,EACAC,IAEOH,EAAI,SAASC,CAAQ,GAAG,SAAS,EAAE,SAASC,CAAK,GAAK,EAEjE,EACA,sBAAuBT,CACzB,EACA,CAAC,EAEL,MAAO,CACL,cAAAD,EACA,mBAAoB,CAClB,cAAAA,CACF,EACA,oBAAAG,EACA,iBAAAF,CACF,CACF,CAOO,IAAMW,GAA0B,CAAC,CAAE,OAAAC,EAAQ,UAAAC,EAAW,GAAGC,CAAM,IAAM,CAC1E,IAAMC,EAAWH,EAAO,OAAO,UAAU,MAAM,SAM/C,GAHI,CAACG,GAGDA,EAAS,OAAS,OAAQ,OAAO,KAErC,GAAIA,EAAS,OAAS,UAAW,CAC/B,GAAM,CAACC,EAAMC,CAAE,EAAKL,EAAO,OAAO,eAAe,GAG/B,CAAC,OAAW,MAAS,EAMvC,OAAOM,GAAc,CACnB,KAAAF,EACA,GAAAC,EACA,MAPY,IACLL,EAAO,OAAO,uBAAuB,GAAK,CAAC,OAAW,MAAS,EAOtE,cAAe,CAACI,EAAMC,IAAOL,EAAO,OAAO,eAAe,CAACI,EAAMC,CAAE,CAAC,CACtE,CAAC,CACH,CAEA,OACEE,EAAA,cAAC,SACE,GAAGL,EAIJ,MAAQF,EAAO,OAAO,eAAe,GAAgB,GACrD,UAAW,gCAAgCC,CAAS,GACpD,KAAK,OACL,SAAWO,GAAMR,EAAO,OAAO,eAAeQ,EAAE,OAAO,KAAK,EAC9D,CAEJ,ECzGO,IAAMC,GAAN,MAAMC,CAAgB,CAE3B,YAAe,OAAgC,IAAIA,EAAa,IAAI,GAAK,EAEjE,YAAYC,EAAa,CAC/B,KAAK,KAAOA,CACd,CAEA,OAAO,OAA4B,CACjC,OAAO,KAAK,MACd,CAEA,OAAO,QAAWC,EAA8B,CAC9C,OAAO,KAAK,MAAS,EAAE,IAAI,GAAGA,CAAM,CACtC,CAEA,IAAIC,EAAmB,CACrB,OAAO,KAAK,KAAK,IAAIA,CAAK,CAC5B,CAEA,OAAOD,EAA8B,CACnC,IAAME,EAAS,IAAI,IAAI,KAAK,KAAK,KAAK,CAAC,EACvC,QAAWD,KAASD,EAClBE,EAAO,IAAID,CAAK,EAElB,OAAO,IAAIH,EAAaI,CAAM,CAChC,CAEA,OAAOD,EAA2B,CAChC,OAAI,KAAK,IAAIA,CAAK,EACT,KAAK,OAAOA,CAAK,EAEjB,KAAK,IAAIA,CAAK,CAEzB,CAEA,OAAOA,EAA2B,CAChC,IAAMC,EAAS,IAAI,IAAI,KAAK,KAAK,KAAK,CAAC,EACvC,OAAAA,EAAO,OAAOD,CAAK,EACZ,IAAIH,EAAaI,CAAM,CAChC,CAEA,OAAyB,CACvB,OAAOJ,EAAa,MAAM,CAC5B,CAEA,CAAC,OAAO,QAAQ,GAAI,CAClB,OAAO,KAAK,KAAK,OAAO,QAAQ,EAAE,CACpC,CAEA,QAAc,CACZ,MAAO,CAAC,GAAG,KAAK,KAAK,KAAK,CAAC,CAC7B,CACF,ECXO,IAAMK,GAAN,MAAMC,CAAe,CAC1B,YAAgB,MAAQ,OACxB,YAAgB,YAAc,SAC9B,YAAgB,cAAgB,WAChC,YAAgB,YAAc,SAC9B,YAAgB,cAAgB,WAChC,YAAgB,WAAa,OAC7B,YAAgB,aAAe,SAE/B,YAAgB,SAAW,CACzB,KAAMA,EAAe,MACrB,OAAQA,EAAe,YACvB,SAAUA,EAAe,aAC3B,EACA,YAAgB,SAAW,CACzB,KAAMA,EAAe,MACrB,OAAQA,EAAe,YACvB,SAAUA,EAAe,aAC3B,EACA,YAAgB,UAAY,CAC1B,KAAMA,EAAe,MACrB,OAAQA,EAAe,aACvB,KAAMA,EAAe,UACvB,EAMA,YAAY,CACV,IAAAC,EACA,IAAAC,EACA,KAAAC,CACF,EAIG,CACD,GAAI,CAAC,OAAO,OAAOH,EAAe,QAAQ,EAAE,SAASC,CAAG,EACtD,MAAM,IAAI,MAAM,+BAA+BA,CAAG,EAAE,EAEtD,GAAI,CAAC,OAAO,OAAOD,EAAe,QAAQ,EAAE,SAASE,CAAG,EACtD,MAAM,IAAI,MAAM,+BAA+BA,CAAG,EAAE,EAEtD,GAAI,CAAC,OAAO,OAAOF,EAAe,SAAS,EAAE,SAASG,CAAI,EACxD,MAAM,IAAI,MAAM,gCAAgCA,CAAI,EAAE,EAExD,KAAK,IAAMF,EACX,KAAK,IAAMC,EACX,KAAK,KAAOC,CACd,CAEA,QAAkB,CAChB,OACE,KAAK,MAAQH,EAAe,SAAS,MACrC,KAAK,MAAQA,EAAe,SAAS,MACrC,KAAK,OAASA,EAAe,UAAU,IAE3C,CACF,EAEO,SAASI,GACdC,EACgB,CAEhB,OAAKA,IACHA,EAAuB,CAAE,IAAK,WAAY,IAAK,OAAQ,KAAM,MAAO,GAE/D,IAAIN,GAAe,CACxB,IAAKM,EAAqB,IAC1B,IAAKA,EAAqB,IAC1B,KAAMA,EAAqB,IAC7B,CAAC,CACH,CAEO,SAASC,GAAiD,CAC/D,cAAAC,EACA,mBAAAC,EACA,eAAAC,EACA,YAAAC,EACA,YAAAC,EACA,YAAAC,EACA,eAAAC,EACA,QAAAC,CACF,EAUiC,CAC/B,GAAM,CAACC,EAAcC,CAAe,EAAIC,EACtCC,GAAa,MAAM,CACrB,EAIM,CAACC,EAAQC,CAAS,EAAIH,EAAsB,IAAI,EAEhDI,EAAeC,GAAwD,CAC3E,GAAIb,EAAe,OAAO,EACxB,OAGF,IAAMc,EAAKD,EAAM,cACXE,EAAMd,EAAYa,CAAE,EAC1B,GAAIhB,GAEEgB,EAAG,UAAU,SAASE,GAAmBC,GAAc,OAAO,CAAC,EACjE,OAIJ,IAAMC,EAASC,GACbnB,EACAK,EACAC,EACAO,EACAE,EACAL,CACF,EACIQ,IACFX,EAAgBW,EAAO,SAAS,EAC5BA,EAAO,SACTP,EAAUI,CAAG,EACbD,EAAG,MAAM,GAEXD,EAAM,eAAe,EAEzB,EAEMO,EAAaP,GAA+C,CAIhE,GAHIf,GAGAE,EAAe,OAAO,EACxB,OAGF,IAAMc,EAAKD,EAAM,cACXE,EAAMd,EAAYa,CAAE,EACpBO,EAAWf,EAAa,IAAIS,CAAG,EAErC,GAAIF,EAAM,MAAQ,SAAU,CAC1BV,EAAYW,CAAE,EACdD,EAAM,eAAe,EACrB,MACF,CAOA,GAAIb,EAAe,MAAQV,GAAe,SAAS,QACjD,GAAIuB,EAAM,MAAQ,KAAOA,EAAM,MAAQ,QACrCA,EAAM,eAAe,EACjBd,GAAsBc,EAAM,MAAQ,QACtCT,EAAeU,CAAE,EAEbR,EAAa,IAAIS,CAAG,EACtBR,EAAgBE,GAAa,MAAM,CAAC,EAEpCF,EAAgBE,GAAa,KAAKM,CAAG,CAAC,UAGjCF,EAAM,MAAQ,WAAaA,EAAM,MAAQ,YAAa,CAC/D,IAAMS,EAAYpB,EAAYa,EAAKF,EAAM,MAAQ,UAAY,GAAK,CAAC,EAC/DS,IACFT,EAAM,eAAe,EACjBQ,GACFd,EAAgBE,GAAa,KAAKa,CAAS,CAAC,EAGlD,OACStB,EAAe,MAAQV,GAAe,SAAS,WACpDuB,EAAM,MAAQ,KAAOA,EAAM,MAAQ,SACrCA,EAAM,eAAe,EACjBd,GAAsBc,EAAM,MAAQ,QACtCT,EAAeU,CAAE,EAEjBP,EAAgBD,EAAa,OAAOS,CAAG,CAAC,IAEjCF,EAAM,MAAQ,WAAaA,EAAM,MAAQ,cAC9CX,EAAYa,EAAKF,EAAM,MAAQ,UAAY,GAAK,CAAC,GACnDA,EAAM,eAAe,EAI7B,EAkCA,MAhCkB,CAChB,IAAIE,EAAoB,CACtB,OAAOT,EAAa,IAAIS,CAAG,CAC7B,EAEA,IAAIA,EAAWM,EAAmB,CAE9Bd,EADEc,EACcf,EAAa,IAAIS,CAAG,EAEpBT,EAAa,OAAOS,CAAG,CAFF,CAIzC,EAEA,YAAYQ,EAAgB,CAC1BhB,EAAgBE,GAAa,KAAK,GAAGc,CAAM,CAAC,CAC9C,EAEA,OAAQ,CACNhB,EAAgBD,EAAa,MAAM,CAAC,CACtC,EAEA,MAAO,CACL,OAAOA,CACT,EAEA,cAAe,CACb,MAAO,CAAE,YAAAM,EAAa,UAAAQ,CAAU,CAClC,EAEA,YAAAlB,CACF,CAGF,CAaA,IAAMsB,GAAQ,QAAQ,KACpB,OAAO,UAAU,eAAe,UAAY,OAAO,UAAU,QAC/D,EAEA,SAASL,GACPnB,EACAK,EACAC,EACAO,EACAE,EACAL,EACyD,CACzD,GAAM,CAAE,SAAAe,EAAU,OAAAC,CAAO,EAAIb,EACvBc,EAAUH,GAAQX,EAAM,QAAUA,EAAM,QAO9C,IANgBW,GAAQX,EAAM,QAAUA,EAAM,UAE/Ba,GAIX1B,EAAe,MAAQV,GAAe,SAAS,KACjD,OAAO,KACF,GAAIU,EAAe,MAAQV,GAAe,SAAS,OACxD,OAAIqC,GAAW,CAACF,EAGVnB,EAAa,IAAIS,CAAG,EACf,CAAE,UAAWN,GAAa,MAAM,EAAG,OAAQ,EAAK,EAEhD,CAAE,UAAWA,GAAa,KAAKM,CAAG,EAAG,OAAQ,EAAK,EAIpD,CAAE,UAAWN,GAAa,KAAKM,CAAG,EAAG,OAAQ,EAAK,EAGtD,GAAIf,EAAe,MAAQV,GAAe,SAAS,SACxD,GAAImC,GAAYE,GAEd,GAAIjB,IAAW,MAAQL,EAAS,CAC9B,IAAMuB,EAAWvB,EAAQK,EAAQK,CAAG,EACpC,MAAO,CAAE,UAAWT,EAAa,IAAI,GAAGsB,CAAQ,CAAE,CACpD,MACK,IAAID,EAET,MAAO,CAAE,UAAWrB,EAAa,OAAOS,CAAG,EAAG,OAAQ,EAAK,EACtD,GAAIU,GAET,GAAIf,IAAW,MAAQL,EAAS,CAC9B,IAAMuB,EAAWvB,EAAQK,EAAQK,CAAG,EACpC,MAAO,CAAE,UAAWN,GAAa,KAAK,GAAGmB,CAAQ,CAAE,CACrD,MAGA,OAAO,CAAE,UAAWnB,GAAa,KAAKM,CAAG,EAAG,OAAQ,EAAK,MAG3D,OAAM,IAAI,MAAM,mCAAmCf,EAAe,GAAG,EAAE,EAEzE,OAAO,IACT,CC5UO,SAAS6B,GAAe,CAC7B,WAAAC,CACF,EAOE,CACA,GAAM,CAACC,EAASC,CAAU,EAAIC,EAAuB,CAAC,CAAC,EAEvD,MAAO,CACL,QAAAF,EACA,sBAAuB,CACrB,QAAAA,CACF,EACA,iBAAkB,CAChB,gBAAkBG,GAAuC,CACvD,IAAMC,EACJ,OAAOD,GAAgB,WACnBA,EAAYH,CAAO,EACnBG,EACAE,EAAUN,EAAW,EACrBO,EAAiB,IAAI,IACzBD,EACG,OAAQE,GAAQA,EAAI,KAAM,YAAY,EACtC,IAAKA,GAAQA,EAAI,MAAO,CAC7B,EAEMC,EACJF,EAAe,MAAQ,EACnBF,EACAA,EAAW,OAAQK,GACV,CAACH,EAAe,IAAIG,EAAK,EAAE,CACnC,EAEPR,EAAWO,CAAY,CACzB,EACA,kBAAmBE,GAAkB,CACvC,EACA,WAAAT,CACF,CACF,CCnDA,IAAMU,GAAgB,aAChBC,GAAkB,CACtB,QAAS,CAAC,GAAI,GAAI,EAAG,CAAC,EAAE,IAAKC,GAAMA,EAAI,GAAG,EAAE,KAAK,GAAG,EACpD,MAAO,OACP,OAAQ,OACR,MAAO,CAAE,YAAa,KAAM,CAC9B,EAEMC,GAAsB,CAC1B,OAAQ,UACR,YAAa,MACb,KAAM,aACR,EAEMC,GACJC,EAAA,cAAC,OACC,MAAM,6BACA,GAAGJ,GAAiB,UAAW,GAAGD,EAAa,kBAErDK,EAAA,cAAC,QACC,EAAE,4BACD,GAAGF,GACJ,cAAc,QAChB,CACF,EAGIG,GACJD,EAAA,cAAC,OACC,MAAM,6BACA,GAAGJ,GAAiB,UAAW,GAAGD,EAAa,oBAErDK,EAAA,cAAC,QACC,EAAE,6BACD,GAAGF,GACJ,cAAc,QAChB,CACF,EAOWI,GAAgC,CAAC,CAAE,UAAAC,CAAU,IAAM,CAC9D,GAAI,CAACA,EACH,OAAO,KAET,GAAIA,IAAc,MAChB,OAAOJ,GAET,GAAII,IAAc,OAChB,OAAOF,GAET,MAAM,IAAI,MAAM,+BAA+BE,CAAS,GAAG,CAC7D,ECpDAC,GAAa,EA2BN,IAAMC,GAAsB,CAAC,CAClC,SAAAC,EACA,SAAAC,EACA,YAAAC,CACF,IAKS,IAAIF,CAAQ,KAAKC,CAAQ,KAAKC,CAAW,IAYrCC,GAAkB,CAAC,CAC9B,eAAAC,EACA,KAAAC,EACA,KAAAC,CACF,IASK,CACH,GAAM,CAACC,EAAcC,CAAe,EAAIC,GACtC,IAAI,GACN,EACMC,EAA6BC,EAChCC,GAAyB,CACxB,GAAM,CAAE,SAAAZ,EAAU,KAAAa,EAAM,KAAAC,CAAK,EAAIF,EAEjCJ,EAAiBO,GAAU,CACzB,IAAMC,EAASH,GAAQ,MAAM,KAAK,CAAE,OAAQR,CAAK,EAAG,CAACY,EAAGR,IAAMA,CAAC,EACzDS,EAASJ,GAAQ,MAAM,KAAK,CAAE,OAAQR,CAAK,EAAG,CAACW,EAAGE,IAAMA,CAAC,EAC/D,QAAWlB,KAAYe,EACrB,QAAWd,KAAegB,EAAQ,CAChC,IAAME,EAAMrB,GAAoB,CAC9B,SAAAC,EACA,SAAAC,EACA,YAAAC,CACF,CAAC,EACKmB,EAAUN,EAAM,IAAIK,CAAG,GAAK,CAAE,MAAO,CAAC,EAAG,MAAO,MAAU,EAC5DE,EACAD,EAAQ,MACNT,EAAU,MACZU,EAAW,GAAGD,EAAQ,KAAK,IAAIT,EAAU,KAAK,GAE9CU,EAAWD,EAAQ,MAGjBT,EAAU,MACZU,EAAWV,EAAU,MAErBU,EAAW,OAGfP,EAAM,IAAIK,EAAK,CACb,SAAApB,EACA,SAAAC,EACA,YAAAC,EACA,MAAO,CACL,GAAGmB,EAAQ,MACX,GAAGT,EAAU,KACf,EACA,MAAOU,CACT,CAAC,CACH,CAEJ,CAAC,CACH,EACA,CAAChB,EAAMD,EAAMG,CAAe,CAC9B,EAEMe,EAAkBZ,EAAY,IAAM,CACxCH,EAAiBO,GAAU,CACzBA,EAAM,MAAM,CACd,CAAC,CACH,EAAG,CAACP,CAAe,CAAC,EAEdgB,EAAgBb,EACnBc,GAA4B,CAE3BF,EAAgB,EAChB,QAAWX,KAAaa,EACtBf,EAAaE,CAAS,CAE1B,EACA,CAACF,EAAca,CAAe,CAChC,EAGA,OAAAG,EAAU,IAAM,CACdF,EAAcpB,CAAc,CAC9B,EAAG,CAACA,EAAgBoB,CAAa,CAAC,EAE3B,CACL,aAAAjB,EACA,aAAAG,EACA,cAAAc,EACA,gBAAAD,CACF,CACF,EAUO,IAAMI,GAAe,CAC1BC,EACAC,EACAC,EACAC,IAC4E,CAC5E,IAAMC,EAAMC,GAAoB,CAAE,SAAAJ,EAAU,SAAAC,EAAU,YAAAC,CAAY,CAAC,EAC7DG,EAAMN,EAAE,IAAII,CAAG,EACrB,MAAO,CACL,UAAWE,GAAK,MAChB,cAAeA,GAAK,KACtB,CACF,EAGMC,GAA2B,SAAS,cAAc,gBAAgB,EC1KxE,IAAOC,GAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;GCWR,SAASC,GACdC,EACAC,EACAC,EAMkC,CAClC,GAAM,CAACC,EAAUC,CAAW,EAAIC,EAAS,CAAC,EAEpCC,EAAUC,EAAM,YACnBC,GAA+C,CAM9CJ,EAAY,EAAE,EAEVI,EAAM,SAAWA,EAAM,eAK3BC,GAAoBT,EAAYC,EAAe,EAAGC,CAAY,GAAG,MAAM,CACzE,EACA,CAACF,EAAWC,EAAgBC,CAAY,CAC1C,EAEMQ,EAASH,EAAM,YAClBC,GAA+C,CAC9CJ,EAAY,CAAC,CACf,EACA,CAAC,CACH,EAEA,MAAO,CACL,kBAAmBD,EACnB,kBAAmB,CACjB,QAAAG,EACA,OAAAI,CACF,CACF,CACF,CC5CO,SAASC,GACdC,EACAC,EACAC,EACAC,EACAC,EACoB,CACpB,OAAOC,GAAQ,IAAM,CACnB,IAAMC,EAAgBN,GAAmB,GACzC,GAAI,CAACM,EACH,OAAO,KAGT,IAAMC,EACJ,OAAOD,GAAkB,SACrBA,EACA,gDASN,GAPI,CAACL,GAGDC,EAAY,SAAW,GAIvB,CAACC,EAAO,OAAO,KAEnB,IAAMK,EAAMP,EAAgB,UAAYE,EAAM,aACxCM,EAAMR,EAAgB,UAAYA,EAAgB,aAElD,CAACS,EAAYC,CAAS,EAAIC,GAC9BJ,EACAC,EACAP,EACA,CAACW,EAAMC,IAAUD,EAAK,MAAQA,EAAK,KAAO,CAC5C,EAEA,GAAIH,IAAe,MAAQC,IAAc,KAGvC,OAAO,KAGT,IAAMI,EAAWb,EAAYQ,CAAU,EACjCM,EAAUd,EAAYS,CAAS,EAOrC,GALII,IAAa,QAAaC,IAAY,QAKtCD,EAAS,QAAU,GAAKC,EAAQ,QAAUZ,EAAQ,EAEpD,OAAO,KAGT,IAAMa,EAAiBC,GACrBX,EACAQ,EAAS,MAAQ,EACjBC,EAAQ,MAAQ,EAChBZ,CACF,EAEA,OAAOe,EAAA,cAAC,OAAI,UAAU,2BAA2BF,CAAe,CAClE,EAAG,CAACjB,EAAiBC,EAAiBC,EAAaC,EAAOC,CAAK,CAAC,CAClE,CAgBA,SAASQ,GACPE,EACAM,EACAC,EACAC,EAC6C,CAC7C,IAAIC,EAAuB,KACvBC,EAAsB,KAE1B,QAASC,EAAI,EAAGA,EAAIJ,EAAM,OAAQI,IAAK,CACrC,IAAMC,EAAcL,EAAMI,CAAC,EAC3B,GAAIF,IAAU,KACRD,EAAII,EAAM,EAAI,GAAKZ,IACrBS,EAAQE,EACRD,EAAOC,WAGLH,EAAII,EAAM,EAAK,GAAKN,EACtBI,EAAOC,MAEP,MAGN,CAEA,MAAO,CAACF,EAAOC,CAAI,CACrB,CAEA,SAASN,GACPX,EACAO,EACAM,EACAO,EACA,CACA,OAAOpB,EAAS,QAAQ,yBAA0B,CAACqB,EAAQC,IACrDA,IAAU,QACLf,EAAQ,GACNe,IAAU,MACZT,EAAM,GACJS,IAAU,QACZF,EAAQ,GAERC,CAEV,CACH,CC7BA,IAAME,GAAiD,CAAC,CACtD,GAAAC,EACA,SAAU,CAAE,QAAAC,EAAS,UAAAC,EAAW,eAAgBC,CAAmB,EACnE,QAAAC,CACF,IAAM,CACJ,GAAM,CACJ,QAASC,EACT,UAAWC,EACX,KAAMC,EACN,QAASC,EAAiB,CACxB,MAAO,OACP,OAAQ,OACR,KAAM,GACN,OAAQ,CAAC,CACX,EACA,SAAAC,CACF,EAAIR,EACE,CACJ,MAAAS,EACA,OAAAC,EACA,KAAAC,EACA,QAASC,EACT,OAAQC,CACV,EAAIN,EAEEO,EAAeC,EAAuB,IAAI,EAC1CC,EAAWD,EAAgC,IAAI,EAC/CE,EAAWF,EAAgC,IAAI,EAE/C,CAACG,EAASC,CAAU,EAAIC,GAAShB,CAAW,EAC5C,CAACiB,EAAWC,CAAY,EAAIF,GAASf,CAAa,EAElDkB,EAAgBC,GAAgB,CACpC,eAAgBX,GAAkB,CAAC,EACnC,KAAMP,EAAc,OACpB,KAAMY,EAAQ,MAChB,CAAC,EAMKO,EAAeF,EAAc,aAC7B,CAAE,cAAAG,CAAc,EAAIH,EAEpBI,EAAeC,GAAe,EAM9BC,EAAcF,EAAa,YAI3BG,EAAsBH,EAAa,oBAInCI,GAAmBJ,EAAa,iBAKhCK,GAAqBzB,EAAe,WAAgB,GAOpD0B,GAAgBC,GAAiB,IAAM,CAC3C,QAAWC,KAAYN,EAAY,OAAO,EACxC,GAAIM,EAAS,UACX,MAAO,GAGX,MAAO,EACT,EAAG,CAACN,CAAW,CAAC,EAKVO,GAAUF,GACd,IACEhB,EAAQ,IAAI,CAACmB,EAASC,IAAa,CACjC,IAAMC,EAAWlB,IAAYiB,CAAQ,EAE/BE,EAAeD,GAAU,OAAS,OAClCE,EAAgBD,EAAe,GAAQ,OAE7C,MAAO,CACL,WAAY,CAACE,EAAKC,IACTD,EAAIJ,CAAQ,EAGrB,SACEC,GAAU,OAAS,UAAY,gBAAkB,iBACnD,OAAQF,EACR,KAAM,CACJ,SAAAC,EACA,aAAAE,EACA,SAAAD,CACF,EACA,KAAM,CAAC,CAAE,SAAAK,CAAS,IAAM,CACtB,IAAMC,EAAMD,EAAS,EAIrB,GAAIC,GAAQ,KACV,MAAO,GAET,OAAQN,GAAU,KAAM,CAEtB,IAAK,UACL,IAAK,OACL,IAAK,WACL,IAAK,WACL,IAAK,cACL,IAAK,OACH,OAAOM,EAET,IAAK,SACL,IAAK,UACH,OAAO,OAAOA,CAAG,EAEnB,IAAK,UACL,IAAK,SACH,OAAI,OAAOA,GAAQ,SACVA,EAEF,KAAK,UAAUA,CAAG,EAC3B,QACE,OAAOA,CACX,CACF,EACA,cAAAJ,CACF,CACF,CAAC,EACH,CAACvB,EAASG,CAAS,CACrB,EAuBMyB,GAAeZ,GAAQ,IAAM5B,EAAe,CAACA,CAAa,CAAC,EAE3DyC,GAAa3B,GAASd,CAAa,EAEnC0C,GAAYD,GAAW,CAAC,EAExBE,GAAeF,GAAW,CAAC,EAM3BG,GAAQC,GAAQ,CAAE,WAJL,IACVf,EAG0B,CAAC,EAE9BgB,GAAUF,GAAM,QAEhBG,GAAwBH,GAAM,sBAE9BI,EAAmBJ,GAAM,iBAEzBK,EAAaL,GAAM,WAEnB,CACJ,cAAAM,EACA,mBAAAC,EACA,oBAAAC,GACA,iBAAAC,EACF,EAAIC,GAAsBhD,CAAW,EAE/BiD,GAAaC,EACjB,CAAC,CACC,KAAAC,EACA,QAAA7C,EACA,UAAAG,CACF,IAIM,CACJF,EAAWD,CAAO,EAClB+B,GAAac,CAAI,EACjBzC,EAAaD,CAAS,EACtBU,GAAiB,EAGjB,IAAMiC,EAAiB,IAAI,IAC3B3C,GAAW,QAAQ,CAAC4C,EAAM7C,KAAM,CAC9B4C,EAAe,IAAI9C,EAAQE,EAAC,EAAI6C,CAAI,CACtC,CAAC,EAED,IAAMC,EAAUd,GAAQ,OAAQe,GAASH,EAAe,IAAIG,EAAK,EAAE,CAAC,EAC9DC,EAAkBZ,EAAc,OAAQa,GAAW,CACvD,IAAM9B,GAAWyB,EAAe,IAAIK,EAAO,EAAE,EAC7C,OAAK9B,GAGDA,GAAS,OAAS,UAElB8B,EAAO,QAAU,MAChB,MAAM,QAAQA,EAAO,KAAK,GACzBA,EAAO,MAAM,MAAOC,IAAMA,KAAM,IAAI,EAInC,OAAOD,EAAO,OAAU,SAXT,EAYxB,CAAC,EAEDV,GAAiBS,CAAe,EAChCb,EAAWW,CAAO,CACpB,EACA,CACEV,EACAzB,GACA4B,GACAxC,EACAoC,EACAN,GACA3B,EACA8B,EACF,CACF,EAEMmB,GAAmC,CACvC,KAAMvB,GACN,QAASZ,GACT,MAAO,CACL,GAAGiB,GACH,GAAGI,CACL,EACA,gBAAiBe,GAAgB,EACjC,GAAGlB,EACH,GAAGI,EAOL,EACMe,EAAQC,GAAcH,EAAO,EAE7BI,GAAiBC,GAAe,CACpC,MAAOH,EAAM,oBAAoB,EAAE,KAAK,OACxC,iBAAkB,IAAM3D,EAAa,QACrC,aAAc,IAAM,GACpB,SAAU,GACV,aAAcE,EAAS,SAAS,cAAgB,EAGhD,sBAAuB,EACzB,CAAC,EAGD6D,GAAgB,IAAM,CACpBF,GAAe,eAAe,CAAC,CACjC,EAAG,CAAC3E,EAAS2E,EAAc,CAAC,EAE5B,IAAMG,GAAYH,GAAe,aAAa,EACxCI,GAAcJ,GAAe,gBAAgB,EAM7CK,IACHD,GAAY,OAAS,GAAIA,KAAc,CAAC,GAAG,OAAS,IAClD/D,EAAS,SAAS,cAAgB,GACjCiE,GACJF,GAAY,OAAS,EACjBD,IAAaC,KAAcA,GAAY,OAAS,CAAC,GAAG,KAAO,GAC3D,EAEAG,GAAUC,GACd5E,EAAe,QACfO,GAAc,QACdiE,GACA/D,EAAS,QACT2D,GAAe,QAAQ,KACzB,EAEMS,GAAa7E,EAAe,OAAY,OACxC8E,GACJD,KAAe,OAAS,uBAAyB,wBAC7CE,GAAaF,KAAe,QAAU,iBAAmB,KAIzDG,GAAiBC,GAAmBtF,CAAkB,EAEtDuF,GAAY,CAACF,GAAe,OAAO,EACnCG,GAAoBH,GAAe,MAAQI,GAAe,SAAS,KAEnEC,GAAYC,GAA0C,CAC1D,cAAA5D,GACA,mBAAAD,GACA,eAAAuD,GACA,YAAcO,GACLA,EAAG,QAAQ,IAEpB,YAAcA,GAAO,CACnB,WAAW,IAAM,CACfA,GAAI,KAAK,EACThF,EAAa,SAAS,MAAM,CAC9B,EAAG,CAAC,CACN,EACA,YAAa,CAACiF,EAAKC,EAAS,IAAM,CAChC,IAAMC,EAAWxB,EAAM,kBAAkB,EACrC9B,EAAQsD,EAAS,KAAK,UAAWvD,GAAQA,EAAI,KAAOqD,CAAG,EAK3D,GAJIpD,EAAQ,IAGZA,GAASqD,EACLrD,EAAQ,GAAKA,GAASsD,EAAS,KAAK,QACtC,OAAO,KAET,IAAMC,EAAYD,EAAS,KAAKtD,CAAK,EAAG,GACxC,OAAAgC,GAAe,cAAchC,CAAK,EAClC,WAAW,IAAM,CACE7B,EAAa,SAAS,cACrC,cAAcoF,CAAS,IACzB,GACU,MAAM,CAClB,EAAG,CAAC,EACGA,CACT,EACA,QAAS,CAACC,EAASC,IACjBC,GAAgB5B,EAAM,kBAAkB,EAAG0B,EAASC,CAAK,EAC3D,eAAiBN,GAAO,CAEtB,IAAMQ,EAAgB,MAAM,GAAGR,EAAG,WAAW,OAAO,CAAC,EAAE,OAAQS,GAE3DA,aAAgB,aAChBA,EAAK,UAAU,SAAS,eAAe,CAE1C,EACD,GAAID,EAAc,SAAW,EAAG,OAGhC,IAAME,EAAYC,GAChB3F,EAAa,QACbwF,CACF,EACA,GAAI,CAACE,EAAW,OAGhB,IAAME,EAAmB,IAAI,WAAW,WAAY,CAClD,QAAS,GACT,WAAY,EACd,CAAC,EACDF,EAAU,cAAcE,CAAgB,CAC1C,CACF,CAAC,EAEDC,EAAU,IAAM,CACd,IAAMC,EACJC,GACG,CAIH,IAAMC,EAAgBD,EAAM,OAAO,cAEnC,GAAIC,EAAc,OAAS,OAAQ,CACjClB,GAAU,MAAM,EAChB,MAIF,SAAWkB,EAAc,OAAS,MAAO,CACvClB,GAAU,YAAYkB,EAAc,KAAK,IAAI,MAAM,CAAC,EACpD,MACF,MACE,QAAQ,MAAM,mCAAoCA,CAAa,CAEnE,EAEA,GAAI,CAAC/G,EAAI,OAET,IAAMgH,EAAU,SAAS,eAAehH,CAAE,EAC1C,GAAKgH,EAEL,OAAAA,EAAQ,iBACN,sBACAH,CACF,EAEO,IAAM,CACXG,EAAQ,oBACN,sBACAH,CACF,CACF,CACF,EAAG,CAAC7G,EAAI6F,GAAW5C,EAAS,CAAC,EAE7B2D,EAAU,IAAM,CACTnG,GAEL,OAAO,MAAM,wBAAwB,CAAC,GAAGA,CAAQ,CAAC,CACpD,EAAG,CAACA,CAAQ,CAAC,EAEbmG,EAAU,IAAM,CACd,IAAMK,EACJH,GAGG,CACH,IAAMI,EAAaJ,EAAM,OAAO,QAC1BK,EAAaC,GAA6BF,CAAU,EAG1DG,GAAe,CACb,QAASnE,GACT,WAAAiE,EACA,oBAAApF,CACF,CAAC,CACH,EAEA,GAAI,CAAC/B,EAAI,OAET,IAAMgH,EAAU,SAAS,eAAehH,CAAE,EAC1C,GAAKgH,EAEL,OAAAA,EAAQ,iBAAiB,aAAcC,CAAiC,EAEjE,IAAM,CACXD,EAAQ,oBACN,aACAC,CACF,CACF,CACF,EAAG,CAAC9F,EAASnB,EAAI+B,EAAqByB,EAAYN,EAAY,CAAC,EAE/D0D,EAAU,IAAM,CACd,IAAMU,EACJR,GAKG,CACH,IAAMS,EAAUT,EAAM,OAEtBhD,GAAWyD,CAAO,CACpB,EAEA,GAAI,CAACvH,EAAI,OAET,IAAMgH,EAAU,SAAS,eAAehH,CAAE,EAC1C,GAAKgH,EAEL,OAAAA,EAAQ,iBAAiB,aAAcM,CAAiC,EAEjE,IAAM,CACXN,EAAQ,oBACN,aACAM,CACF,CACF,CACF,EAAG,CAACnG,EAASnB,EAAIgC,GAAkBkB,GAAcY,EAAU,CAAC,EAE5D8C,EAAU,IAAM,CACd,IAAMY,EACJV,GACG,CACH,IAAMW,EAAeX,EAAM,OAAO,KAC5BY,EAA8B,CAAC,EAErCD,EAAa,IAAKrD,GAAS,CACzBsD,EAAc,KAAK,CACjB,GAAIvG,EAAQiD,EAAK,GAAG,EACpB,KAAMA,EAAK,IACb,CAAC,CACH,CAAC,EACDZ,EAAWkE,CAAa,CAC1B,EAEA,GAAI,CAAC1H,EAAI,OAET,IAAMgH,EAAU,SAAS,eAAehH,CAAE,EAC1C,GAAKgH,EAEL,OAAAA,EAAQ,iBACN,mBACAQ,CACF,EAEO,IAAM,CACXR,EAAQ,oBACN,mBACAQ,CACF,CACF,CACF,EAAG,CAACrG,EAASnB,EAAIwD,CAAU,CAAC,EAE5BoD,EAAU,IAAM,CACd,IAAMe,EACJb,GACG,CACH,IAAMc,EAAed,EAAM,OAAO,OAE5BrD,EAAoC,CAAC,EAC3CmE,EAAa,IAAKtD,GAAW,CAC3Bb,EAAc,KAAK,CACjB,GAAItC,EAAQmD,EAAO,GAAG,EACtB,MAAOA,EAAO,KAChB,CAAC,CACH,CAAC,EACDV,GAAiBH,CAAa,CAChC,EAEA,GAAI,CAACzD,EAAI,OAET,IAAMgH,EAAU,SAAS,eAAehH,CAAE,EAC1C,GAAKgH,EAEL,OAAAA,EAAQ,iBACN,qBACAW,CACF,EAEO,IAAM,CACXX,EAAQ,oBACN,qBACAW,CACF,CACF,CACF,EAAG,CAACxG,EAASnB,EAAI4D,EAAgB,CAAC,EAElCgD,EAAU,IAAM,CACd,IAAMiB,EAAgBf,GAAgD,CACpE,IAAMgB,EAAShB,EAAM,OAAO,OAC5BnF,EAAcmG,CAAM,CACtB,EAEA,GAAI,CAAC9H,EAAI,OAET,IAAMgH,EAAU,SAAS,eAAehH,CAAE,EAC1C,GAAKgH,EAEL,OAAAA,EAAQ,iBAAiB,eAAgBa,CAA6B,EAE/D,IAAM,CACXb,EAAQ,oBACN,eACAa,CACF,CACF,CACF,EAAG,CAAC7H,EAAI2B,CAAa,CAAC,EAEtBiF,EAAU,IAAM,CACd,GAAI,CAAC5G,EAAI,OACT,IAAI+H,EAAmC,KACvC,GAAIvC,GAAe,OAAO,EACxBuC,EAAa,aACJvC,GAAe,MAAQI,GAAe,SAAS,KAAM,CAC9D,IAAMoC,EAAmBnC,GAAU,KAAK,EAAE,OAAO,EAC3CoC,EAAWvD,EAAM,kBAAkB,EAAE,SAC3CqD,EAAa,CACX,KAAM,MACN,KAAMC,EACH,IAAKhC,GACEA,KAAOiC,EAGNA,EAASjC,CAAG,EAAG,MAFb,IAGV,EACA,OAAQkC,GAAmBA,IAAM,IAAI,CAC1C,CACF,MACE,QAAQ,MAAM,gCAAiC1C,EAAc,EAE/D,OAAO,MAAM,cAAe,GAAGxF,CAAE,kBAAmB+H,CAAU,CAChE,EAAG,CAAC/H,EAAI6F,GAAWL,GAAgBd,EAAOA,EAAM,iBAAiB,CAAC,EAElEkC,EAAU,IAAM,CACd,GAAI,CAAC5G,EAAI,OACT,IAAMmI,EAA8C,CAAC,EACrD9E,GAAQ,IAAK+E,GAAY,CACvB,IAAMC,EAAYlH,EAAQ,QAAQiH,EAAQ,EAAE,EAC5CD,EAAU,KAAK,CACb,IAAKE,EACL,KAAMD,EAAQ,IAChB,CAAC,CACH,CAAC,EACD,OAAO,MAAM,cAAe,GAAGpI,CAAE,QAASmI,CAAS,EAGnD,OAAO,MAAM,cAAe,GAAGnI,CAAE,eAAgBmI,CAAS,CAC5D,EAAG,CAAChH,EAASnB,EAAIqD,EAAO,CAAC,EACzBuD,EAAU,IAAM,CACd,GAAI,CAAC5G,EAAI,OACT,IAAMsI,EAGA,CAAC,EACP7E,EAAc,IAAK8E,GAAc,CAC/B,IAAMF,EAAYlH,EAAQ,QAAQoH,EAAU,EAAE,EAC9CD,EAAY,KAAK,CACf,IAAKD,EACL,MAAOE,EAAU,KACnB,CAAC,CACH,CAAC,EACD,OAAO,MAAM,cAAe,GAAGvI,CAAE,UAAWsI,CAAW,EAGvD,OAAO,MAAM,cAAe,GAAGtI,CAAE,iBAAkBsI,CAAW,CAChE,EAAG,CAACtI,EAAIyD,EAAetC,CAAO,CAAC,EAC/ByF,EAAU,IAAM,CACd,GAAI,CAAC5G,EAAI,OAET,IAAMwI,EAAsB9D,EAEzB,kBAAkB,EAClB,KAAK,IAAK/B,GAAQA,EAAI,KAAK,EAC9B,OAAO,MAAM,cAAe,GAAG3C,CAAE,kBAAmBwI,CAAS,EAG7D,OAAO,MAAM,cAAe,GAAGxI,CAAE,qBAAsBwI,CAAS,CAClE,EAAG,CACDxI,EACA0E,EAEArB,GACAI,CACF,CAAC,EAGDmD,EAAU,IAAM,CACd,GAAI,CAAC5G,EAAI,OACT,IAAI+H,EAA8B,KAClC,GAAIvC,GAAe,MAAQI,GAAe,SAAS,KAAM,CACvD,IAAMoC,EAAmBnC,GAAU,KAAK,EAAE,OAAO,EAC3CoC,EAAWvD,EAAM,kBAAkB,EAAE,SAC3CqD,EAAaC,EACV,IAAKhC,GACEA,KAAOiC,EAGNA,EAASjC,CAAG,EAAG,MAFb,IAGV,EACA,OAAQkC,GAAmBA,IAAM,IAAI,EACrC,KAAK,CACV,CACA,OAAO,MAAM,cAAe,GAAGlI,CAAE,iBAAkB+H,CAAU,CAC/D,EAAG,CAAC/H,EAAI6F,GAAWL,GAAgBd,CAAK,CAAC,EAgBzC,IAAM+D,GAAgBC,EAAM,YAC1B,IAAMxH,EAAS,QAAS,iBAAiB,iBAAiB,EAE1D,CAACA,EAAS,OAAO,CACnB,EACMyH,GAAgBC,GAAiB7H,EAAa,QAAS0H,GAAe,CAC1E,IAAKxH,EAAS,SAAS,cAAgB,CACzC,CAAC,EAID2F,EAAU,IACD,IAAM,CACXlC,EAAM,aAAa,EACnBmB,GAAU,MAAM,CAClB,EAEC,CAAC5F,CAAO,CAAC,EAEZ,IAAM4I,GAAiBnE,EAAM,gBAAgB,EAAE,OAI/CI,GAAgB,IAAM,CAEpB,IAAIgE,EAAY7F,GAAU,OAAS,EACnC,GAAI6F,EAAW,CAKb/H,EAAa,SAAS,UAAU,IAAI,WAAW,EAC/C,IAAMgI,EAAehI,EAAa,SAAS,aACrCiI,EAAejI,EAAa,SAAS,aACvCgI,GAAgBC,GAAgBD,GAAgBC,IAClDF,EAAY,GAEhB,CACA/H,EAAa,SAAS,UAAU,OAAO,YAAa+H,CAAS,CAC/D,EAAG,CACD7F,GAAU,OACVlC,EAAa,SAAS,aACtBA,EAAa,SAAS,YACxB,CAAC,EAED,IAAMkI,GACHC,GAAwCpC,GAA+B,EAClEA,EAAM,MAAQ,KAAOA,EAAM,MAAQ,UACrCoC,EAAO,cAAc,OAAWpC,EAAM,QAAQ,CAElD,EAEIqC,GAAYC,GAAgCxE,EAAc,EAE5DyE,GAAY,mBAAmB/D,EAAc,GAC7C1E,IACFyI,IAAa,mBAGf,IAAMC,GACJ,GAEF,OACEZ,EAAA,cAAAA,EAAA,cACEA,EAAA,cAAC,OACC,UAAWW,GACX,IAAKtI,EACL,MAAO,CAAE,MAAAL,EAAO,OAAAC,EAAQ,SAAU,MAAO,GAEzC+H,EAAA,cAAC,SACC,UAAWnD,IAAc1E,EAAc,aAAe,IACtD,gBAAe6D,EAAM,YAAY,EACjC,uBAAsBiB,GACtB,MAAO,CACL,MAAOjF,IAAU,MAAQA,IAAU,OAAS,OAAY,MAC1D,GAEAgI,EAAA,cAAC,SAAM,IAAKzH,EAAU,MAAO,CAAE,gBAAiBb,CAAQ,GACrDsE,EAAM,gBAAgB,EAAE,IAAI,CAAC6E,EAAalI,IACzCqH,EAAA,cAAC,MAGC,IAAKa,EAAY,GACjB,gBAAelI,EAAI,GAElBiI,IAAqBZ,EAAA,cAAC,MAAG,UAAU,eAAe,EAElDa,EAAY,QAAQ,IAAKC,GAAW,CACnC,IAAMC,EAAgBD,EAAO,cAAgB,OAC3Cd,EAAA,cAAC,OACC,MAAO,CACL,OAAQc,EAAO,OAAO,WAAW,EAC7B,UACA,OACJ,WAAYA,EAAO,OAAO,WAAW,EACjC,OACA,MACN,GAECE,GACCF,EAAO,OAAO,UAAU,OACxBA,EAAO,WAAW,CACpB,EACAd,EAAA,cAACiB,GAAA,CAAU,UAAWH,EAAO,OAAO,YAAY,EAAG,CACrD,EAGF,OACEd,EAAA,cAAC,MAGC,IAAKc,EAAO,GACZ,QAASA,EAAO,QAChB,MAAO,CACL,MAAOA,EAAO,QAAQ,CAGxB,EACA,MAAM,MACN,SAAU,EACV,QAASA,EAAO,OAAO,wBAAwB,EAC/C,UAAWP,GAAkBO,EAAO,MAAM,EAC1C,UACEA,EAAO,OAAO,WAAW,EAAI,OAAY,eAG1CC,CACH,CAEJ,CAAC,CACH,CACD,EACA5I,GACC6H,EAAA,cAAC,MAAG,UAAU,WACXY,IAAqBZ,EAAA,cAAC,MAAG,UAAU,eAAe,EAClDhE,EAAM,eAAe,EAAE,IAAK8E,GAAW,CACtC,IAAMI,EAAQ,UAAUJ,EAAO,EAAE,GACjC,OACEd,EAAA,cAAC,MAGC,IAAKkB,GAELlB,EAAA,cAACmB,GAAA,CAAO,OAAQL,EAAQ,CAC1B,CAEJ,CAAC,CACH,CAEJ,EACAd,EAAA,cAAC,SACC,IAAKxH,EACL,SAAUyH,GAAc,kBACvB,GAAGA,GAAc,mBAEjB1D,GAAa,GAAKyD,EAAA,cAAC,MAAG,MAAO,CAAE,OAAQ,GAAGzD,EAAU,IAAK,EAAG,EAC5DD,GAAY,IAAK8E,GAAe,CAC/B,IAAMnH,EAAM+B,EAAM,YAAY,EAAE,KAAKoF,EAAW,KAAK,EACrD,OACEnH,GACE+F,EAAA,cAAC,MAGC,IAAKoB,EAAW,IAChB,aAAYA,EAAW,MACvB,gBAAeA,EAAW,MAAQjB,GAClC,WAAUlG,EAAI,GACd,IAAKwG,GACL,gBAAetD,GAAU,IAAIlD,EAAI,EAAE,EACnC,SAAU,GACT,GAAGkD,GAAU,aAAa,GAE1ByD,IACCZ,EAAA,cAAC,MAAG,UAAU,cAAc/F,EAAI,MAAQ,CAAE,EAE3CA,EAAI,gBAAgB,EAAE,IAAKoH,GAAS,CAEnC,IAAMC,EAAWD,EAAK,IAAI,MACpBE,EAAcF,EAAK,OAAO,UAAU,KAAM,SAC1C,CAACG,EAAcC,CAAI,EAAIC,GAC3BtI,EACAkI,EACAC,CACF,EACM,CAAE,UAAAI,GAAW,cAAAC,EAAc,EAAIC,GACnC7I,EACA,OACAsI,EACAC,CACF,EAEA,OACEvB,EAAA,cAAC8B,GAAA,CACC,IAAKT,EAAK,GACV,MAAOA,EAAK,IAAI,GAChB,aAAchJ,EACd,KAAMgJ,EACN,UAAW7J,EACX,mBAAoB+B,GACpB,QAASd,EACT,QAASkB,GACT,SAAU2H,EACV,YAAaC,EACb,kBAAmBvF,EAAM,kBACzB,aAAcwF,EACd,UAAWG,GACX,cAAeC,GACf,QAASpH,GACT,oBAAqBnB,EACrB,UAAW8D,GACZ,CAEL,CAAC,CACH,CAGN,CAAC,EACAX,GAAgB,GACfwD,EAAA,cAAC,MAAG,MAAO,CAAE,OAAQ,GAAGxD,EAAa,IAAK,EAAG,CAEjD,CACF,CACF,EACCC,EACH,CAEJ,EAEA,SAASmB,GACPJ,EACAE,EACAC,EACmB,CACnB,IAAIoE,EAAUvE,EAAS,KAAK,UAAWvD,GAAQA,EAAI,KAAOyD,CAAO,EAC7DsE,EAAQxE,EAAS,KAAK,UAAWvD,GAAQA,EAAI,KAAO0D,CAAK,EAC7D,GAAIoE,EAAU,GAAKC,EAAQ,EACzB,MAAO,CAAC,EAEND,EAAUC,IAEZ,CAACD,EAASC,CAAK,EAAI,CAACA,EAAOD,CAAO,GAEpC,IAAME,EAAO,CAAC,EACd,QAAStJ,EAAIoJ,EAASpJ,GAAKqJ,EAAOrJ,IAChCsJ,EAAK,KAAKzE,EAAS,KAAK7E,CAAC,EAAG,EAAE,EAEhC,OAAOsJ,CACT,CAUA,SAASvB,GACPxE,EACA,CAEA,IAAMgG,EAAmB5J,EAAsB,CAAC,CAAC,EAI3C6J,EAA0B9G,EAC7BgC,GAAuB,CACjBA,IAIDA,EAAG,YACLnB,EAAe,eAAemB,CAAE,EAEhC6E,EAAiB,QAAQ,KAAK7E,CAAiB,EAEnD,EACA,CAACnB,CAAc,CACjB,EAGA,OAAAE,GAAgB,IAAM,CAChB8F,EAAiB,QAAQ,OAAS,GACvBA,EAAiB,QAAQ,OAAO,CAAC,EAGzC,QAAQhG,EAAe,cAAc,CAE9C,CAAC,EAEMiG,CACT,CAEA,IAAMC,GAAN,cAA0C,OAAO,MAAM,aAAc,CACnE,KAAKC,EAA+D,CAClE,OAAO,EAAEA,CAAK,EAAE,KAAK,kBAAkB,CACzC,CAGA,YAAYhF,EAA0B/B,EAAiB,CACrD+B,EAAG,YAAY/B,CAAI,CACrB,CAEA,YAAY+B,EAA0BiF,EAA+B,CACnEjF,EAAG,UAAU,IAAI,oBAAoB,EACrCA,EAAG,YAAYiF,CAAG,CACpB,CAEA,WAAWjF,EAAgC,CACzCA,EAAG,UAAU,OAAO,oBAAoB,EACxCA,EAAG,WAAW,CAChB,CACF,EACA,OAAO,MAAM,eAAe,SAC1B,IAAI+E,GACJ,gBACF,EAEA,SAASG,GAAmBlF,EAA4C,CACtE,GAAI,CAACA,EAEH,OAGF,IAAMmF,EAAUC,GAASpF,EAAI,kBAAkB,EAE/C,GAAI,CAACmF,EAAS,OAAOA,EACrB,IAAME,EAAIF,EAAQ,MAChB,uEACF,EAEA,GAAIA,IAAY,eAAkBE,GAAK,WAAWA,EAAE,CAAC,CAAE,IAAM,EAAI,CAE/D,IAAMC,EAAUF,GAASpF,EAAI,kBAAkB,EAE/C,OAAIsF,GAAWA,IAAY,OAEzB,OAGOJ,GAAmBlF,EAAG,aAAa,CAE9C,CACA,OAAOmF,CACT,CAEA,IAAMI,GAAc,SAAS,cAAc,UAAU,EACrDA,GAAY,UAAY,UAAUC,EAAG,WAE9B,IAAMC,GAAN,cAAmC,WAAY,CAIpD,mBAAoB,CAMlB,GAAM,CAACC,CAAM,EAAI,CAAC,IAAI,EAEtBA,EAAO,YAAYH,GAAY,QAAQ,UAAU,EAAI,CAAC,EAKtD,KAAK,UAAY,SAAS,cAAc,MAAM,EAC9CG,EAAO,YAAY,KAAK,SAAS,EAEjC,IAAMC,EAAQ,SAAS,cAAc,KAAK,EAC1CA,EAAM,UAAU,IAAI,sBAAuB,gBAAgB,EAC3DD,EAAO,YAAYC,CAAK,EAExB,KAAK,UAAYC,GAAWD,CAAK,EAIjC,IAAME,EAAS,KAAK,cAClB,aACF,EACA,GAAIA,EAAQ,CACV,IAAM5H,EAAO,KAAK,MAAM4H,EAAO,SAAS,EACxC,KAAK,YAAY5H,CAAI,CACvB,CACF,CAEA,YAAY6H,EAAgD,CAG1D,GAFA,KAAK,WAAW,EAEZ,CAACA,EAAO,CACV,KAAK,UAAW,OAAO,IAAI,EAC3B,MACF,CAEA,KAAK,UAAW,OACdnD,EAAA,cAACoD,GAAA,KACCpD,EAAA,cAAC3I,GAAA,CACC,GAAI,KAAK,GACT,SAAU8L,EACV,QAASZ,GAAmB,IAAI,EACjC,CACH,CACF,CACF,CAEA,YAAYD,EAAyB,CACnC,KAAK,UAAW,OAAO,IAAI,EAC3B,KAAK,UAAU,UAAYA,EAAI,OACjC,CAEA,YAAa,CACX,KAAK,UAAW,OAAO,IAAI,EAC3B,KAAK,UAAU,UAAY,EAC7B,CACF,EAEA,eAAe,OAAO,mBAAoBQ,EAAoB,EAQ9D,OAAO,MAAM,wBACX,wBACA,SAAUO,EAAS,CACjB,IAAMC,EAAM,IAAI,YAAYD,EAAQ,QAAS,CAC3C,OAAQA,EAAQ,GAClB,CAAC,EACU,SAAS,eAAeA,EAAQ,EAAE,GACzC,cAAcC,CAAG,CACvB,CACF",
  "names": ["MODE_HYDRATE", "slice", "options", "vnodeId", "isValidElement", "rerenderQueue", "prevDebounce", "defer", "depthSort", "eventClock", "eventProxy", "eventProxyCapture", "i", "EMPTY_OBJ", "EMPTY_ARR", "IS_NON_DIMENSIONAL", "isArray", "Array", "assign", "obj", "props", "removeNode", "node", "parentNode", "removeChild", "createElement", "type", "children", "key", "ref", "normalizedProps", "arguments", "length", "call", "defaultProps", "createVNode", "original", "vnode", "__k", "__", "__b", "__e", "__d", "__c", "constructor", "__v", "__i", "__u", "createRef", "current", "Fragment", "BaseComponent", "context", "this", "getDomSibling", "childIndex", "sibling", "updateParentDomPointers", "child", "base", "enqueueRender", "c", "push", "process", "debounceRendering", "renderQueueLength", "component", "newVNode", "oldVNode", "oldDom", "commitQueue", "refQueue", "sort", "shift", "diff", "__P", "namespaceURI", "commitRoot", "diffChildren", "parentDom", "renderResult", "newParentVNode", "oldParentVNode", "globalContext", "namespace", "excessDomChildren", "isHydrating", "childVNode", "newDom", "firstChildDom", "oldChildren", "newChildrenLength", "constructNewChildrenArray", "applyRef", "contains", "insert", "nextSibling", "skewedIndex", "matchingIndex", "oldChildrenLength", "remainingOldChildren", "skew", "String", "findMatchingIndex", "unmount", "parentVNode", "insertBefore", "nodeType", "toChildArray", "out", "some", "x", "y", "setStyle", "style", "value", "setProperty", "test", "dom", "name", "oldValue", "useCapture", "o", "cssText", "replace", "toLowerCase", "l", "_attached", "addEventListener", "removeEventListener", "e", "removeAttribute", "setAttribute", "createEventProxy", "eventHandler", "_dispatched", "event", "tmp", "isNew", "oldProps", "oldState", "snapshot", "clearProcessingException", "newProps", "isClassComponent", "provider", "componentContext", "renderHook", "count", "newType", "outer", "prototype", "render", "contextType", "__E", "doRender", "sub", "state", "__n", "__h", "_sb", "__s", "getDerivedStateFromProps", "componentWillMount", "componentDidMount", "componentWillReceiveProps", "shouldComponentUpdate", "forEach", "componentWillUpdate", "componentDidUpdate", "__r", "getChildContext", "getSnapshotBeforeUpdate", "indexOf", "diffElementNodes", "diffed", "root", "cb", "newHtml", "oldHtml", "newChildren", "inputValue", "checked", "localName", "document", "createTextNode", "createElementNS", "is", "data", "childNodes", "attributes", "__html", "innerHTML", "skipRemove", "r", "componentWillUnmount", "replaceNode", "firstChild", "hydrate", "cloneElement", "createContext", "defaultValue", "contextId", "Consumer", "contextValue", "Provider", "subs", "ctx", "_props", "old", "splice", "error", "errorInfo", "ctor", "handled", "getDerivedStateFromError", "setState", "componentDidCatch", "undefined", "update", "callback", "s", "forceUpdate", "Promise", "then", "bind", "resolve", "setTimeout", "a", "b", "currentIndex", "currentComponent", "previousComponent", "prevRaf", "currentHook", "afterPaintEffects", "options", "_options", "oldBeforeDiff", "__b", "oldBeforeRender", "__r", "oldAfterDiff", "diffed", "oldCommit", "__c", "oldBeforeUnmount", "unmount", "oldRoot", "__", "getHookState", "index", "type", "__h", "hooks", "__H", "length", "push", "useState", "initialState", "useReducer", "invokeOrReturn", "reducer", "init", "hookState", "_reducer", "action", "currentValue", "__N", "nextValue", "setState", "_hasScuFromHooks", "updateHookState", "p", "s", "c", "stateHooks", "filter", "x", "every", "prevScu", "call", "this", "shouldUpdate", "forEach", "hookItem", "props", "shouldComponentUpdate", "prevCWU", "componentWillUpdate", "__e", "tmp", "useEffect", "callback", "args", "state", "__s", "argsChanged", "_pendingArgs", "useLayoutEffect", "useRef", "initialValue", "useMemo", "current", "useImperativeHandle", "ref", "createHandle", "concat", "factory", "useCallback", "useContext", "context", "provider", "sub", "value", "useDebugValue", "formatter", "useId", "state", "getHookState", "currentIndex", "root", "currentComponent", "__v", "__m", "__", "mask", "flushAfterPaintEffects", "component", "afterPaintEffects", "shift", "__P", "__H", "__h", "forEach", "invokeCleanup", "invokeEffect", "e", "options", "__e", "__b", "vnode", "oldBeforeDiff", "parentDom", "__k", "oldRoot", "__r", "oldBeforeRender", "hooks", "__c", "previousComponent", "hookItem", "__N", "_pendingArgs", "diffed", "oldAfterDiff", "c", "length", "push", "prevRaf", "requestAnimationFrame", "afterNextFrame", "commitQueue", "some", "filter", "cb", "oldCommit", "unmount", "oldBeforeUnmount", "hasErrored", "s", "HAS_RAF", "callback", "raf", "done", "clearTimeout", "timeout", "cancelAnimationFrame", "setTimeout", "hook", "comp", "cleanup", "argsChanged", "oldArgs", "newArgs", "arg", "index", "invokeOrReturn", "f", "assign", "obj", "props", "i", "shallowDiffers", "a", "b", "PureComponent", "p", "c", "this", "context", "memo", "comparer", "shouldUpdate", "nextProps", "ref", "updateRef", "call", "current", "Memoed", "shouldComponentUpdate", "createElement", "displayName", "name", "prototype", "isReactComponent", "Component", "isPureReactComponent", "state", "oldDiffHook", "options", "__b", "vnode", "type", "__f", "REACT_FORWARD_SYMBOL", "Symbol", "for", "forwardRef", "fn", "Forwarded", "clone", "$$typeof", "render", "mapFn", "children", "toChildArray", "map", "Children", "forEach", "count", "length", "only", "normalized", "toArray", "oldCatchError", "error", "newVNode", "oldVNode", "errorInfo", "then", "component", "__", "__c", "__e", "__k", "oldUnmount", "unmount", "detachedClone", "detachedParent", "parentDom", "__H", "effect", "__P", "child", "removeOriginal", "originalParent", "__v", "appendChild", "Suspense", "__u", "_suspenders", "suspended", "__a", "lazy", "loader", "prom", "Lazy", "exports", "default", "e", "SuspenseList", "_next", "_map", "__R", "promise", "suspendingVNode", "suspendingComponent", "push", "resolve", "resolved", "onResolved", "onSuspensionComplete", "suspendedVNode", "__O", "setState", "pop", "forceUpdate", "componentWillUnmount", "document", "detachedComponent", "fallback", "Fragment", "list", "node", "delete", "revealOrder", "size", "ContextProvider", "getChildContext", "Portal", "_this", "container", "_container", "_temp", "nodeType", "parentNode", "childNodes", "contains", "insertBefore", "before", "removeChild", "splice", "indexOf", "createPortal", "el", "containerInfo", "delegated", "get", "unsuspend", "wrappedUnsuspend", "Map", "reverse", "set", "componentDidUpdate", "componentDidMount", "REACT_ELEMENT_TYPE", "CAMEL_PROPS", "ON_ANI", "CAMEL_REPLACE", "IS_DOM", "onChangeInputType", "test", "parent", "callback", "textContent", "preactRender", "hydrate", "preactHydrate", "key", "Object", "defineProperty", "configurable", "v", "writable", "value", "oldEventHook", "event", "empty", "isPropagationStopped", "cancelBubble", "isDefaultPrevented", "defaultPrevented", "persist", "nativeEvent", "currentComponent", "classNameDescriptorNonEnumberable", "enumerable", "class", "oldVNodeHook", "normalizedProps", "lowerCased", "toLowerCase", "replace", "multiple", "Array", "isArray", "selected", "defaultValue", "className", "oldBeforeRender", "__r", "oldDiffed", "diffed", "dom", "__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED", "ReactCurrentDispatcher", "readContext", "__n", "useCallback", "useContext", "useDebugValue", "useDeferredValue", "useEffect", "useId", "useImperativeHandle", "useInsertionEffect", "useLayoutEffect", "useMemo", "useReducer", "useRef", "useState", "useSyncExternalStore", "useTransition", "createFactory", "type", "createElement", "bind", "isValidElement", "element", "$$typeof", "REACT_ELEMENT_TYPE", "isFragment", "Fragment", "isMemo", "displayName", "String", "startsWith", "cloneElement", "preactCloneElement", "apply", "arguments", "unmountComponentAtNode", "container", "__k", "preactRender", "findDOMNode", "component", "base", "nodeType", "unstable_batchedUpdates", "callback", "arg", "flushSync", "StrictMode", "startTransition", "cb", "useDeferredValue", "val", "useTransition", "useInsertionEffect", "useLayoutEffect", "isElement", "useSyncExternalStore", "subscribe", "getSnapshot", "value", "useState", "_instance", "__", "_getSnapshot", "_useState", "forceUpdate", "didSnapshotChange", "useEffect", "inst", "x", "y", "latestGetSnapshot", "prevValue", "nextValue", "error", "index", "useId", "useReducer", "useRef", "useImperativeHandle", "useMemo", "useCallback", "useContext", "useDebugValue", "version", "Children", "render", "hydrate", "createPortal", "createContext", "createRef", "Component", "PureComponent", "memo", "forwardRef", "Suspense", "SuspenseList", "lazy", "__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED", "functionalUpdate", "updater", "input", "makeStateUpdater", "key", "instance", "updater", "setState", "old", "functionalUpdate", "isFunction", "d", "Function", "isNumberArray", "Array", "isArray", "every", "val", "flattenBy", "arr", "getChildren", "flat", "recurse", "subArr", "forEach", "item", "push", "children", "length", "memo", "getDeps", "fn", "opts", "deps", "result", "depArgs", "depTime", "debug", "Date", "now", "newDeps", "some", "dep", "index", "resultTime", "onChange", "depEndTime", "Math", "round", "resultEndTime", "resultFpsPercentage", "pad", "str", "num", "String", "console", "info", "max", "min", "getMemoOptions", "tableOptions", "debugLevel", "_tableOptions$debugAl", "debugAll", "process", "createCell", "table", "row", "column", "columnId", "getRenderValue", "_cell$getValue", "cell", "getValue", "options", "renderFallbackValue", "id", "renderValue", "getContext", "_features", "feature", "createColumn", "columnDef", "depth", "parent", "_ref", "_resolvedColumnDef$id", "resolvedColumnDef", "_getDefaultColumnDef", "accessorKey", "replace", "undefined", "header", "accessorFn", "includes", "originalRow", "split", "_result", "Error", "columns", "getFlatColumns", "_column$columns", "flatMap", "getLeafColumns", "_getOrderColumnsFn", "orderColumns", "_column$columns2", "leafColumns", "createHeader", "_options$id", "isPlaceholder", "placeholderId", "subHeaders", "colSpan", "rowSpan", "headerGroup", "getLeafHeaders", "leafHeaders", "recurseHeader", "h", "map", "Headers", "createTable", "getHeaderGroups", "getAllColumns", "getVisibleLeafColumns", "getState", "columnPinning", "left", "right", "allColumns", "_left$map$filter", "_right$map$filter", "leftColumns", "find", "filter", "Boolean", "rightColumns", "centerColumns", "buildHeaderGroups", "getCenterHeaderGroups", "getLeftHeaderGroups", "_left$map$filter2", "orderedLeafColumns", "getRightHeaderGroups", "_right$map$filter2", "getFooterGroups", "headerGroups", "reverse", "getLeftFooterGroups", "getCenterFooterGroups", "getRightFooterGroups", "getFlatHeaders", "headers", "getLeftFlatHeaders", "getCenterFlatHeaders", "getRightFlatHeaders", "getCenterLeafHeaders", "flatHeaders", "_header$subHeaders", "getLeftLeafHeaders", "_header$subHeaders2", "getRightLeafHeaders", "_header$subHeaders3", "center", "_left$0$headers", "_left$", "_center$0$headers", "_center$", "_right$0$headers", "_right$", "columnsToGroup", "headerFamily", "_headerGroups$0$heade", "_headerGroups$", "maxDepth", "findMaxDepth", "getIsVisible", "createHeaderGroup", "headersToGroup", "join", "pendingParentHeaders", "headerToGroup", "latestPendingParentHeader", "isLeafHeader", "bottomHeaders", "recurseHeadersForSpans", "childRowSpans", "childColSpan", "childRowSpan", "minChildRowSpan", "createRow", "original", "rowIndex", "subRows", "parentId", "_valuesCache", "_uniqueValuesCache", "hasOwnProperty", "getColumn", "getUniqueValues", "_row$getValue", "getLeafRows", "getParentRow", "getRow", "getParentRows", "parentRows", "currentRow", "parentRow", "getAllCells", "getAllLeafColumns", "_getAllCellsByColumnId", "allCells", "reduce", "acc", "i", "ColumnFaceting", "_getFacetedRowModel", "getFacetedRowModel", "getPreFilteredRowModel", "_getFacetedUniqueValues", "getFacetedUniqueValues", "Map", "_getFacetedMinMaxValues", "getFacetedMinMaxValues", "includesString", "filterValue", "search", "toLowerCase", "toString", "autoRemove", "testFalsey", "includesStringSensitive", "_row$getValue2", "equalsString", "_row$getValue3", "arrIncludes", "_row$getValue4", "arrIncludesAll", "_row$getValue5", "arrIncludesSome", "_row$getValue6", "equals", "weakEquals", "inNumberRange", "rowValue", "resolveFilterValue", "unsafeMin", "unsafeMax", "parsedMin", "parseFloat", "parsedMax", "Number", "isNaN", "Infinity", "temp", "filterFns", "ColumnFiltering", "getDefaultColumnDef", "filterFn", "getInitialState", "state", "columnFilters", "getDefaultOptions", "onColumnFiltersChange", "filterFromLeafRows", "maxLeafRowFilterDepth", "getAutoFilterFn", "firstRow", "getCoreRowModel", "flatRows", "value", "getFilterFn", "_table$options$filter", "_table$options$filter2", "getCanFilter", "_column$columnDef$ena", "_table$options$enable", "_table$options$enable2", "enableColumnFilter", "enableColumnFilters", "enableFilters", "getIsFiltered", "getFilterIndex", "getFilterValue", "_table$getState$colum", "_table$getState$colum2", "_table$getState$colum3", "findIndex", "setFilterValue", "setColumnFilters", "previousFilter", "newFilter", "shouldAutoRemoveFilter", "_old$filter", "newFilterObj", "_old$map", "_table", "columnFiltersMeta", "updateFn", "_functionalUpdate", "resetColumnFilters", "defaultState", "_table$initialState$c", "_table$initialState", "initialState", "getFilteredRowModel", "_getFilteredRowModel", "manualFiltering", "sum", "_leafRows", "childRows", "next", "nextValue", "extent", "mean", "leafRows", "count", "median", "values", "mid", "floor", "nums", "sort", "a", "b", "unique", "from", "Set", "uniqueCount", "size", "_columnId", "aggregationFns", "ColumnGrouping", "aggregatedCell", "props", "_toString", "_props$getValue", "aggregationFn", "grouping", "onGroupingChange", "groupedColumnMode", "toggleGrouping", "setGrouping", "getCanGroup", "enableGrouping", "getGroupingValue", "getIsGrouped", "_table$getState$group", "getGroupedIndex", "_table$getState$group2", "indexOf", "getToggleGroupingHandler", "canGroup", "getAutoAggregationFn", "Object", "prototype", "call", "getAggregationFn", "_table$options$aggreg", "_table$options$aggreg2", "resetGrouping", "_table$initialState$g", "getPreGroupedRowModel", "getGroupedRowModel", "_getGroupedRowModel", "manualGrouping", "groupingColumnId", "_groupingValuesCache", "getIsPlaceholder", "getIsAggregated", "_row$subRows", "nonGroupingColumns", "col", "g", "ColumnOrdering", "columnOrder", "onColumnOrderChange", "getIndex", "position", "_getVisibleLeafColumns", "getIsFirstColumn", "_columns$", "getIsLastColumn", "_columns", "setColumnOrder", "resetColumnOrder", "orderedColumns", "columnOrderCopy", "columnsCopy", "targetColumnId", "shift", "foundIndex", "splice", "getDefaultColumnPinningState", "ColumnPinning", "onColumnPinningChange", "pin", "columnIds", "setColumnPinning", "_old$left3", "_old$right3", "_old$left", "_old$right", "_old$left2", "_old$right2", "getCanPin", "_d$columnDef$enablePi", "enablePinning", "enableColumnPinning", "getIsPinned", "leafColumnIds", "isLeft", "isRight", "getPinnedIndex", "getCenterVisibleCells", "_getAllVisibleCells", "leftAndRight", "getLeftVisibleCells", "getRightVisibleCells", "resetColumnPinning", "getIsSomeColumnsPinned", "_pinningState$positio", "pinningState", "_pinningState$left", "_pinningState$right", "getLeftLeafColumns", "getRightLeafColumns", "getCenterLeafColumns", "defaultColumnSizing", "minSize", "maxSize", "MAX_SAFE_INTEGER", "getDefaultColumnSizingInfoState", "startOffset", "startSize", "deltaOffset", "deltaPercentage", "isResizingColumn", "columnSizingStart", "ColumnSizing", "columnSizing", "columnSizingInfo", "columnResizeMode", "columnResizeDirection", "onColumnSizingChange", "onColumnSizingInfoChange", "getSize", "_column$columnDef$min", "_column$columnDef$max", "columnSize", "getStart", "slice", "getAfter", "resetSize", "setColumnSizing", "_ref2", "_", "rest", "getCanResize", "enableResizing", "enableColumnResizing", "getIsResizing", "_header$column$getSiz", "prevSiblingHeader", "getResizeHandler", "_contextDocument", "canResize", "e", "persist", "isTouchStartEvent", "touches", "clientX", "newColumnSizing", "updateOffset", "eventType", "clientXPos", "setColumnSizingInfo", "_old$startOffset", "_old$startSize", "deltaDirection", "_ref3", "headerSize", "onMove", "onEnd", "contextDocument", "document", "mouseEvents", "moveHandler", "upHandler", "removeEventListener", "touchEvents", "cancelable", "preventDefault", "stopPropagation", "_e$touches$", "passiveIfSupported", "passiveEventSupported", "passive", "addEventListener", "resetColumnSizing", "resetHeaderSizeInfo", "_table$initialState$c2", "getTotalSize", "_table$getHeaderGroup", "_table$getHeaderGroup2", "getLeftTotalSize", "_table$getLeftHeaderG", "_table$getLeftHeaderG2", "getCenterTotalSize", "_table$getCenterHeade", "_table$getCenterHeade2", "getRightTotalSize", "_table$getRightHeader", "_table$getRightHeader2", "passiveSupported", "supported", "noop", "window", "type", "ColumnVisibility", "columnVisibility", "onColumnVisibilityChange", "toggleVisibility", "getCanHide", "setColumnVisibility", "childColumns", "c", "enableHiding", "getToggleVisibilityHandler", "target", "checked", "cells", "getVisibleCells", "makeVisibleColumnsMethod", "getColumns", "getVisibleFlatColumns", "getAllFlatColumns", "getLeftVisibleLeafColumns", "getRightVisibleLeafColumns", "getCenterVisibleLeafColumns", "resetColumnVisibility", "toggleAllColumnsVisible", "_value", "getIsAllColumnsVisible", "obj", "getIsSomeColumnsVisible", "getToggleAllColumnsVisibilityHandler", "_target", "GlobalFaceting", "_getGlobalFacetedRowModel", "getGlobalFacetedRowModel", "_getGlobalFacetedUniqueValues", "getGlobalFacetedUniqueValues", "_getGlobalFacetedMinMaxValues", "getGlobalFacetedMinMaxValues", "GlobalFiltering", "globalFilter", "onGlobalFilterChange", "globalFilterFn", "getColumnCanGlobalFilter", "_table$getCoreRowMode", "getCanGlobalFilter", "_table$options$getCol", "enableGlobalFilter", "getGlobalAutoFilterFn", "getGlobalFilterFn", "setGlobalFilter", "resetGlobalFilter", "RowExpanding", "expanded", "onExpandedChange", "paginateExpandedRows", "registered", "queued", "_autoResetExpanded", "_table$options$autoRe", "_queue", "autoResetAll", "autoResetExpanded", "manualExpanding", "resetExpanded", "setExpanded", "toggleAllRowsExpanded", "getIsAllRowsExpanded", "_table$initialState$e", "getCanSomeRowsExpand", "getPrePaginationRowModel", "getCanExpand", "getToggleAllRowsExpandedHandler", "getIsSomeRowsExpanded", "keys", "getRowModel", "getIsExpanded", "getExpandedDepth", "rowIds", "rowsById", "splitId", "getPreExpandedRowModel", "getSortedRowModel", "getExpandedRowModel", "_getExpandedRowModel", "toggleExpanded", "_expanded", "exists", "oldExpanded", "rowId", "_table$options$getIsR", "getIsRowExpanded", "_table$options$getRow", "getRowCanExpand", "enableExpanding", "getIsAllParentsExpanded", "isFullyExpanded", "getToggleExpandedHandler", "canExpand", "defaultPageIndex", "defaultPageSize", "getDefaultPaginationState", "pageIndex", "pageSize", "RowPagination", "pagination", "onPaginationChange", "_autoResetPageIndex", "autoResetPageIndex", "manualPagination", "resetPageIndex", "setPagination", "safeUpdater", "resetPagination", "_table$initialState$p", "setPageIndex", "maxPageIndex", "pageCount", "_table$initialState$p2", "resetPageSize", "_table$initialState$p3", "_table$initialState2", "setPageSize", "topRowIndex", "setPageCount", "_table$options$pageCo", "newPageCount", "getPageOptions", "getPageCount", "pageOptions", "fill", "getCanPreviousPage", "getCanNextPage", "previousPage", "nextPage", "firstPage", "lastPage", "getPaginationRowModel", "_getPaginationRowModel", "_table$options$pageCo2", "ceil", "getRowCount", "_table$options$rowCou", "rowCount", "rows", "getDefaultRowPinningState", "top", "bottom", "RowPinning", "rowPinning", "onRowPinningChange", "includeLeafRows", "includeParentRows", "leafRowIds", "parentRowIds", "setRowPinning", "_old$top3", "_old$bottom3", "_old$top", "_old$bottom", "has", "_old$top2", "_old$bottom2", "enableRowPinning", "isTop", "isBottom", "_ref4", "_visiblePinnedRowIds$", "visiblePinnedRowIds", "getTopRows", "getBottomRows", "_ref5", "resetRowPinning", "_table$initialState$r", "getIsSomeRowsPinned", "_pinningState$top", "_pinningState$bottom", "_getPinnedRows", "visibleRows", "pinnedRowIds", "_table$options$keepPi", "keepPinnedRows", "allRows", "topPinnedRowIds", "bottomPinnedRowIds", "getCenterRows", "topAndBottom", "RowSelection", "rowSelection", "onRowSelectionChange", "enableRowSelection", "enableMultiRowSelection", "enableSubRowSelection", "setRowSelection", "resetRowSelection", "toggleAllRowsSelected", "getIsAllRowsSelected", "preGroupedFlatRows", "getCanSelect", "toggleAllPageRowsSelected", "resolvedValue", "getIsAllPageRowsSelected", "mutateRowIsSelected", "getPreSelectedRowModel", "getSelectedRowModel", "rowModel", "selectRowsFn", "getFilteredSelectedRowModel", "getGroupedSelectedRowModel", "isAllRowsSelected", "paginationFlatRows", "isAllPageRowsSelected", "getIsSomeRowsSelected", "_table$getState$rowSe", "totalSelected", "getIsSomePageRowsSelected", "getIsSelected", "getIsSomeSelected", "getToggleAllRowsSelectedHandler", "getToggleAllPageRowsSelectedHandler", "toggleSelected", "isSelected", "_opts$selectChildren", "selectedRowIds", "selectChildren", "isRowSelected", "isSubRowSelected", "getIsAllSubRowsSelected", "getCanSelectSubRows", "getCanMultiSelect", "_table$options$enable3", "getToggleSelectedHandler", "canSelect", "includeChildren", "newSelectedFlatRows", "newSelectedRowsById", "recurseRows", "_row$subRows2", "selection", "_selection$row$id", "_row$subRows3", "allChildrenSelected", "someSelected", "subRow", "subRowChildrenSelected", "reSplitAlphaNumeric", "alphanumeric", "rowA", "rowB", "compareAlphanumeric", "alphanumericCaseSensitive", "text", "compareBasic", "textCaseSensitive", "datetime", "basic", "aStr", "bStr", "aa", "bb", "an", "parseInt", "bn", "combo", "sortingFns", "RowSorting", "sorting", "sortingFn", "sortUndefined", "onSortingChange", "isMultiSortEvent", "shiftKey", "getAutoSortingFn", "firstRows", "isString", "getAutoSortDir", "getSortingFn", "_table$options$sortin", "_table$options$sortin2", "toggleSorting", "desc", "multi", "nextSortingOrder", "getNextSortingOrder", "hasManualValue", "setSorting", "existingSorting", "existingIndex", "newSorting", "sortAction", "nextDesc", "getCanMultiSort", "_table$options$maxMul", "maxMultiSortColCount", "getFirstSortDir", "_column$columnDef$sor", "sortDescFirst", "firstSortDirection", "isSorted", "getIsSorted", "enableSortingRemoval", "enableMultiRemove", "getCanSort", "enableSorting", "_column$columnDef$ena2", "enableMultiSort", "_table$getState$sorti", "columnSort", "getSortIndex", "_table$getState$sorti2", "_table$getState$sorti3", "clearSorting", "getToggleSortingHandler", "canSort", "resetSorting", "_table$initialState$s", "getPreSortedRowModel", "_getSortedRowModel", "manualSorting", "builtInFeatures", "_options$_features", "_options$initialState", "defaultOptions", "assign", "mergeOptions", "_feature$getInitialSt", "queuedTimeout", "coreInstance", "cb", "Promise", "resolve", "then", "catch", "error", "setTimeout", "reset", "setOptions", "newOptions", "onStateChange", "_getRowId", "getRowId", "_getCoreRowModel", "searchAll", "defaultColumn", "_defaultColumn", "_props$renderValue$to", "_props$renderValue", "_getColumnDefs", "columnDefs", "recurseColumns", "groupingColumnDef", "_getAllFlatColumnsById", "flatColumns", "data", "accessRows", "originalRows", "getSubRows", "_row$originalSubRows", "originalSubRows", "getFacetedMinMaxValues", "table", "columnId", "memo", "_table$getColumn", "getColumn", "getFacetedRowModel", "facetedRowModel", "_facetedRowModel$flat", "firstValue", "flatRows", "getUniqueValues", "facetedMinMaxValues", "i", "length", "values", "j", "value", "getMemoOptions", "options", "filterRows", "rows", "filterRowImpl", "filterFromLeafRows", "filterRowModelFromLeafs", "filterRowModelFromRoot", "rowsToFilter", "filterRow", "_table$options$maxLea", "newFilteredFlatRows", "newFilteredRowsById", "maxDepth", "maxLeafRowFilterDepth", "recurseFilterRows", "depth", "_row$subRows", "row", "newRow", "createRow", "id", "original", "index", "undefined", "parentId", "columnFilters", "subRows", "push", "rowsById", "_table$options$maxLea2", "_row$subRows2", "getPreFilteredRowModel", "getState", "globalFilter", "getFilteredRowModel", "preRowModel", "filterableIds", "map", "d", "filter", "Boolean", "filterRowsImpl", "getFacetedUniqueValues", "Map", "facetedUniqueValues", "has", "_facetedUniqueValues$", "set", "get", "rowModel", "columnFiltersMeta", "resolvedColumnFilters", "resolvedGlobalFilters", "forEach", "_filterFn$resolveFilt", "column", "filterFn", "getFilterFn", "resolvedValue", "resolveFilterValue", "globalFilterFn", "getGlobalFilterFn", "globallyFilterableColumns", "getAllLeafColumns", "getCanGlobalFilter", "_globalFilterFn$resol", "currentColumnFilter", "currentGlobalFilter", "filterMeta", "__global__", "_autoResetPageIndex", "getSortedRowModel", "table", "memo", "getState", "sorting", "getPreSortedRowModel", "rowModel", "rows", "length", "sortingState", "sortedFlatRows", "availableSorting", "filter", "sort", "_table$getColumn", "getColumn", "id", "getCanSort", "columnInfoById", "forEach", "sortEntry", "column", "sortUndefined", "columnDef", "invertSorting", "sortingFn", "getSortingFn", "sortData", "sortedData", "map", "row", "rowA", "rowB", "i", "_sortEntry$desc", "columnInfo", "isDesc", "desc", "sortInt", "aValue", "getValue", "bValue", "aUndefined", "undefined", "bUndefined", "index", "_row$subRows", "push", "subRows", "flatRows", "rowsById", "getMemoOptions", "options", "_autoResetPageIndex", "flexRender", "Comp", "props", "isReactComponent", "createElement", "component", "isClassComponent", "isExoticComponent", "proto", "Object", "getPrototypeOf", "prototype", "$$typeof", "includes", "description", "useReactTable", "options", "resolvedOptions", "state", "onStateChange", "renderFallbackValue", "tableRef", "useState", "current", "createTable", "setState", "initialState", "setOptions", "prev", "updater", "memo", "getDeps", "fn", "opts", "deps", "result", "_a", "_b", "_c", "_d", "depTime", "newDeps", "dep", "index", "resultTime", "depEndTime", "resultEndTime", "resultFpsPercentage", "pad", "str", "num", "notUndefined", "value", "msg", "approxEqual", "a", "b", "debounce", "targetWindow", "ms", "timeoutId", "args", "defaultKeyExtractor", "index", "defaultRangeExtractor", "range", "start", "end", "arr", "i", "observeElementRect", "instance", "cb", "element", "targetWindow", "handler", "rect", "width", "height", "observer", "entries", "entry", "box", "addEventListenerOptions", "supportsScrollend", "observeElementOffset", "instance", "cb", "element", "targetWindow", "offset", "fallback", "debounce", "createHandler", "isScrolling", "handler", "endHandler", "addEventListenerOptions", "measureElement", "element", "entry", "instance", "box", "elementScroll", "offset", "adjustments", "behavior", "instance", "toOffset", "_b", "_a", "Virtualizer", "opts", "_ro", "get", "entries", "entry", "target", "key", "value", "defaultKeyExtractor", "defaultRangeExtractor", "measureElement", "force", "sync", "startIndex", "endIndex", "range", "d", "scrollElement", "rect", "isScrolling", "prevIsScrolling", "measurements", "index", "furthestMeasurementsFound", "furthestMeasurements", "m", "measurement", "previousFurthestMeasurement", "a", "b", "memo", "count", "paddingStart", "scrollMargin", "getItemKey", "enabled", "itemSizeCache", "item", "min", "i", "node", "prevNode", "furthestMeasurement", "start", "measuredSize", "size", "end", "lane", "outerSize", "scrollOffset", "calculateRange", "rangeExtractor", "overscan", "attributeName", "indexStr", "cached", "itemSize", "delta", "indexes", "virtualItems", "k", "len", "notUndefined", "findNearestBinarySearch", "align", "scrollSizeProp", "maxOffset", "initialAlign", "offsetAndAlign", "latestOffset", "approxEqual", "low", "high", "getCurrentValue", "middle", "currentValue", "useIsomorphicLayoutEffect", "_", "y", "useVirtualizerBase", "options", "rerender", "p", "resolvedOptions", "instance", "sync", "mn", "_a", "h", "Virtualizer", "useVirtualizer", "observeElementRect", "observeElementOffset", "elementScroll", "createRoot", "container", "children", "q", "vn", "NOTHING", "DRAFTABLE", "DRAFT_STATE", "die", "error", "args", "getPrototypeOf", "isDraft", "value", "DRAFT_STATE", "isDraftable", "isPlainObject", "DRAFTABLE", "isMap", "isSet", "objectCtorString", "proto", "Ctor", "each", "obj", "iter", "getArchtype", "key", "value", "entry", "index", "thing", "state", "DRAFT_STATE", "isMap", "isSet", "has", "prop", "set", "thing", "propOrOldValue", "value", "t", "getArchtype", "is", "x", "y", "isMap", "target", "isSet", "latest", "state", "shallowCopy", "base", "strict", "isPlainObject", "getPrototypeOf", "descriptors", "DRAFT_STATE", "keys", "i", "key", "desc", "freeze", "obj", "deep", "isFrozen", "isDraft", "isDraftable", "dontMutateFrozenCollections", "each", "_key", "die", "plugins", "getPlugin", "pluginKey", "plugin", "loadPlugin", "implementation", "currentScope", "getCurrentScope", "createScope", "parent_", "immer_", "usePatchesInScope", "scope", "patchListener", "revokeScope", "leaveScope", "revokeDraft", "enterScope", "immer", "draft", "processResult", "result", "baseDraft", "finalize", "maybeFreeze", "NOTHING", "rootScope", "path", "childValue", "finalizeProperty", "resultEach", "parentState", "targetObject", "prop", "rootPath", "targetIsSet", "has", "res", "createProxyProxy", "parent", "isArray", "traps", "objectTraps", "arrayTraps", "revoke", "proxy", "source", "readPropFromProto", "peek", "prepareCopy", "createProxy", "getDescriptorFromProto", "current", "currentState", "markChanged", "owner", "fn", "proto", "Immer", "config", "recipe", "defaultBase", "self", "args", "hasError", "p", "ip", "patches", "inversePatches", "patch", "applyPatchesImpl", "currentImpl", "copy", "enableMapSet", "DraftMap", "target", "parent", "DRAFT_STATE", "getCurrentScope", "latest", "key", "value", "state", "assertUnrevoked", "prepareMapCopy", "markChanged", "each", "cb", "thisArg", "_value", "_map", "isDraftable", "draft", "createProxy", "iterator", "r", "proxyMap_", "DraftSet", "prepareSetCopy", "result", "proxySet_", "die", "loadPlugin", "immer", "Immer", "produce", "produceWithPatches", "setAutoFreeze", "setUseStrictShallowCopy", "applyPatches", "createDraft", "finishDraft", "useImmer", "initialValue", "_useState", "useState", "freeze", "updateValue", "useCallback", "updater", "produce", "makeRequest", "method", "args", "onSuccess", "onError", "blobs", "makeRequestPromise", "resolve", "reject", "value", "err", "addPatchToData", "setData", "newPatches", "setCellEditMapAtLoc", "draft", "rowIndex", "columnIndex", "value", "obj_draft", "CellStateEnum", "cellPatchPyArrToCellPatchArr", "patchesPy", "patch", "cellPatchArrToCellPatchPyArr", "patches", "updateCellsData", "patchInfo", "onSuccess", "onError", "columns", "makeRequestPromise", "newPatchesPy", "err", "CellStateEnum", "CellStateClassEnum", "isShinyHtml", "x", "getCellValueText", "cellValue", "TableBodyCell", "containerRef", "rowId", "cell", "patchInfo", "columns", "coldefs", "rowIndex", "columnIndex", "editCellsIsAllowed", "getSortedRowModel", "cellEditInfo", "cellStyle", "cellClassName", "setData", "setCellEditMapAtLoc", "selection", "initialValue", "isHtmlColumn", "cellState", "errorTitle", "isEditing", "editValue", "tdRef", "A", "inputRef", "resetEditing", "q", "resetIsEditing", "resetEditValue", "obj_draft", "handleEsc", "e", "handleTab", "hasShift", "nextColumnIndex", "newColumnIndex", "attemptUpdate", "handleEnter", "rowModel", "sortedRowIndex", "row", "nextSortedRowIndex", "targetRowIndex", "onInputKeyDown", "fn", "updateCellsData", "_patches", "_err", "y", "onEdtingCellMouseDown", "curRef", "onBodyMouseDown", "onFocus", "onChange", "onCellDoubleClick", "content", "cellTitle", "tableCellClass", "addToTableCellClass", "attemptRenderAsync", "editContent", "Rn", "flexRender", "cellValueObjDeepCopy", "curTdRef", "useCellEditMap", "cellEditMap", "setCellEditMap", "i", "enableMapSet", "rowIndex", "columnIndex", "obj_fn", "draft", "key", "makeCellEditMapKey", "obj", "getCellEditMapObj", "x", "rowIndex", "columnIndex", "key", "makeCellEditMapKey", "findFirstItemInView", "scrollContainer", "items", "extraPadding", "pad", "container", "top", "left", "bottom", "right", "i", "el", "y", "x", "getStyle", "styleProp", "FilterNumeric", "props", "editing", "setEditing", "h", "range", "from", "to", "onRangeChange", "Rn", "FilterNumericImpl", "x", "FilterNumericImpl", "props", "min", "max", "editing", "onFocus", "rangeMin", "rangeMax", "minInputRef", "A", "maxInputRef", "Rn", "e", "createPlaceholder", "value", "coerceToNum", "label", "useFilters", "enabled", "columnFilters", "setColumnFilters", "h", "filtersTableOptions", "getFilteredRowModel", "getFacetedRowModel", "getFacetedUniqueValues", "getFacetedMinMaxValues", "row", "columnId", "value", "addMeta", "Filter", "header", "className", "props", "typeHint", "from", "to", "FilterNumeric", "Rn", "e", "ImmutableSet", "_ImmutableSet", "set", "values", "value", "newSet", "SelectionModes", "_SelectionModes", "row", "col", "rect", "initSelectionModes", "selectionModesOption", "useSelection", "isEditingCell", "editCellsIsAllowed", "selectionModes", "keyAccessor", "focusOffset", "focusEscape", "onKeyDownEnter", "between", "selectedKeys", "setSelectedKeys", "h", "ImmutableSet", "anchor", "setAnchor", "onMouseDown", "event", "el", "key", "CellStateClassEnum", "CellStateEnum", "result", "performMouseDownAction", "onKeyDown", "selected", "targetKey", "keyArr", "isMac", "shiftKey", "altKey", "ctrlKey", "toSelect", "useSort", "getColDefs", "sorting", "setSorting", "h", "sortUpdater", "newSorting", "coldefs", "htmlColumnsSet", "col", "filteredSort", "sort", "getSortedRowModel", "sortClassName", "sortCommonProps", "x", "sortPathCommonProps", "sortArrowUp", "Rn", "sortArrowDown", "SortArrow", "direction", "enableMapSet", "makeStyleInfoMapKey", "location", "rowIndex", "columnIndex", "useStyleInfoMap", "initStyleInfos", "nrow", "ncol", "styleInfoMap", "setStyleInfoMap", "i", "setStyleInfo", "q", "styleInfo", "rows", "cols", "draft", "rowArr", "_", "colArr", "j", "key", "prevObj", "newClass", "resetStyleInfos", "setStyleInfos", "styleInfos", "y", "getCellStyle", "x", "location", "rowIndex", "columnIndex", "key", "makeStyleInfoMapKey", "obj", "cssStringToObjDomElement", "styles_default", "useTabindexGroup", "container", "focusableItems", "extraPadding", "tabIndex", "setTabIndex", "h", "onFocus", "Rn", "event", "findFirstItemInView", "onBlur", "useSummary", "summaryTemplate", "scrollContainer", "virtualRows", "thead", "nrows", "T", "summaryOption", "template", "top", "bot", "firstIndex", "lastIndex", "findRangeIndex", "vrow", "start", "firstRow", "lastRow", "summaryMessage", "formatSummary", "Rn", "end", "items", "map", "first", "last", "i", "item", "total", "substr", "token", "ShinyDataGrid", "id", "payload", "patchInfo", "selectionModesProp", "bgcolor", "columnsProp", "typeHintsProp", "tableDataProp", "payloadOptions", "htmlDeps", "width", "height", "fill", "withFilters", "initStyleInfos", "containerRef", "A", "theadRef", "tbodyRef", "columns", "setColumns", "i", "typeHints", "setTypeHints", "_useStyleInfo", "useStyleInfoMap", "styleInfoMap", "setStyleInfos", "_cellEditMap", "useCellEditMap", "cellEditMap", "setCellEditMapAtLoc", "resetCellEditMap", "editCellsIsAllowed", "isEditingCell", "T", "cellEdit", "coldefs", "colname", "colIndex", "typeHint", "isHtmlColumn", "enableSorting", "row", "index", "getValue", "ret", "dataOriginal", "_tableData", "tableData", "setTableData", "_sort", "useSort", "sorting", "sortTableStateOptions", "sortTableOptions", "setSorting", "columnFilters", "columnFiltersState", "filtersTableOptions", "setColumnFilters", "useFilters", "updateData", "q", "data", "newTypeHintMap", "hint", "newSort", "sort", "newColumnFilter", "filter", "v", "options", "getCoreRowModel", "table", "useReactTable", "rowVirtualizer", "useVirtualizer", "_", "totalSize", "virtualRows", "paddingTop", "paddingBottom", "summary", "useSummary", "tableStyle", "containerClass", "tableClass", "selectionModes", "initSelectionModes", "canSelect", "canMultiRowSelect", "SelectionModes", "selection", "useSelection", "el", "key", "offset", "rowModel", "targetKey", "fromKey", "toKey", "findKeysBetween", "childrenNodes", "node", "firstItem", "findFirstItemInView", "doubleClickEvent", "y", "handleCellSelection", "event", "cellSelection", "element", "handleAddPatches", "evtPatches", "newPatches", "cellPatchPyArrToCellPatchArr", "addPatchToData", "handleUpdateData", "evtData", "handleColumnSort", "shinySorting", "columnSorting", "handleColumnFilter", "shinyFilters", "handleStyles", "styles", "shinyValue", "rowSelectionKeys", "rowsById", "x", "shinySort", "sortObj", "columnNum", "shinyFilter", "filterObj", "shinyRows", "tbodyTabItems", "Rn", "tbodyTabGroup", "useTabindexGroup", "headerRowCount", "scrolling", "scrollHeight", "clientHeight", "makeHeaderKeyDown", "column", "measureEl", "useVirtualizerMeasureWorkaround", "className", "includeRowNumbers", "headerGroup", "header", "headerContent", "flexRender", "SortArrow", "thKey", "Filter", "virtualRow", "cell", "rowIndex", "columnIndex", "cellEditInfo", "_key", "getCellEditMapObj", "cellStyle", "cellClassName", "getCellStyle", "TableBodyCell", "fromIdx", "toIdx", "keys", "measureTodoQueue", "measureElementWithRetry", "ShinyDataFrameOutputBinding", "scope", "err", "getComputedBgColor", "bgColor", "getStyle", "m", "bgImage", "cssTemplate", "styles_default", "ShinyDataFrameOutput", "target", "myDiv", "createRoot", "dataEl", "value", "yn", "message", "evt"]
}
