{
  "version": 3,
  "sources": ["../../../../js/text-area/textarea-autoresize.ts"],
  "sourcesContent": ["// By importing the css file, it will be copied to the output directory.\nimport \"./textarea-autoresize.css\";\n\nexport interface DOMEvent<T extends EventTarget> extends Event {\n  readonly target: T;\n}\n\nfunction onDelegatedEvent(\n  eventName: string,\n  selector: string,\n  callback: (target: HTMLTextAreaElement) => void\n) {\n  document.addEventListener(eventName, (e) => {\n    const e2 = e as DOMEvent<HTMLTextAreaElement>;\n    if (e2.target.matches(selector)) {\n      callback(e2.target);\n    }\n  });\n}\n\n// Use a single intersectionObserver as they are slow to create / use.\nlet textAreaIntersectionObserver: null | IntersectionObserver = null;\n\nfunction callUpdateHeightWhenTargetIsVisible(target: HTMLTextAreaElement) {\n  if (textAreaIntersectionObserver === null) {\n    // Create a single observer to watch for the textarea becoming visible\n    textAreaIntersectionObserver = new IntersectionObserver(\n      (entries, observer) => {\n        entries.forEach((entry) => {\n          // Quit if the entry is not visible\n          if (!entry.isIntersecting) {\n            return;\n          }\n          // If the entry is visible (even if it's just a single pixel)\n          // Stop observing the target\n          textAreaIntersectionObserver!.unobserve(entry.target);\n\n          // Update the height of the textarea\n          update_height(entry.target as HTMLTextAreaElement);\n        });\n      }\n    );\n  }\n\n  textAreaIntersectionObserver.observe(target);\n}\n\nfunction update_height(target: HTMLTextAreaElement) {\n  if (target.scrollHeight > 0) {\n    // Automatically resize the textarea to fit its content.\n    target.style.height = \"auto\";\n    target.style.height = target.scrollHeight + 2 + \"px\";\n  } else {\n    // The textarea is not visible on the page, therefore it has a 0 scroll height.\n\n    // If we should autoresize the text area height, then we can wait for the textarea to\n    // become visible and call `update_height` again. Hopefully the scroll height is no\n    // longer 0\n    callUpdateHeightWhenTargetIsVisible(target);\n  }\n}\n\n// Update on change\nonDelegatedEvent(\n  \"input\",\n  \"textarea.textarea-autoresize\",\n  (target: HTMLTextAreaElement) => {\n    update_height(target);\n  }\n);\n\n// Update on load\nfunction update_on_load() {\n  if (document.readyState === \"loading\") {\n    // Document still loading, wait 10ms to check again.\n    setTimeout(update_on_load, 10);\n    return;\n  }\n\n  // document.readyState in [\"interactive\", \"complete\"];\\\n  const textAreas = document.querySelectorAll(\n    \"textarea.textarea-autoresize\"\n  ) as NodeListOf<HTMLTextAreaElement>;\n  textAreas.forEach(update_height);\n}\nupdate_on_load();\n"],
  "mappings": ";AAOA,SAAS,iBACP,WACA,UACA,UACA;AACA,WAAS,iBAAiB,WAAW,CAAC,MAAM;AAC1C,UAAM,KAAK;AACX,QAAI,GAAG,OAAO,QAAQ,QAAQ,GAAG;AAC/B,eAAS,GAAG,MAAM;AAAA,IACpB;AAAA,EACF,CAAC;AACH;AAGA,IAAI,+BAA4D;AAEhE,SAAS,oCAAoC,QAA6B;AACxE,MAAI,iCAAiC,MAAM;AAEzC,mCAA+B,IAAI;AAAA,MACjC,CAAC,SAAS,aAAa;AACrB,gBAAQ,QAAQ,CAAC,UAAU;AAEzB,cAAI,CAAC,MAAM,gBAAgB;AACzB;AAAA,UACF;AAGA,uCAA8B,UAAU,MAAM,MAAM;AAGpD,wBAAc,MAAM,MAA6B;AAAA,QACnD,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAEA,+BAA6B,QAAQ,MAAM;AAC7C;AAEA,SAAS,cAAc,QAA6B;AAClD,MAAI,OAAO,eAAe,GAAG;AAE3B,WAAO,MAAM,SAAS;AACtB,WAAO,MAAM,SAAS,OAAO,eAAe,IAAI;AAAA,EAClD,OAAO;AAML,wCAAoC,MAAM;AAAA,EAC5C;AACF;AAGA;AAAA,EACE;AAAA,EACA;AAAA,EACA,CAAC,WAAgC;AAC/B,kBAAc,MAAM;AAAA,EACtB;AACF;AAGA,SAAS,iBAAiB;AACxB,MAAI,SAAS,eAAe,WAAW;AAErC,eAAW,gBAAgB,EAAE;AAC7B;AAAA,EACF;AAGA,QAAM,YAAY,SAAS;AAAA,IACzB;AAAA,EACF;AACA,YAAU,QAAQ,aAAa;AACjC;AACA,eAAe;",
  "names": []
}
