{
  "version": 3,
  "sources": ["../../../../srcts/src/components/_utils.ts", "../../../../srcts/src/components/bslibShiny.ts"],
  "sourcesContent": ["import type { HtmlDep } from \"rstudio-shiny/srcts/types/src/shiny/render\";\n\nimport type { InputBinding as InputBindingType } from \"rstudio-shiny/srcts/types/src/bindings/input\";\n\n// Exclude undefined from T\ntype NotUndefined<T> = T extends undefined ? never : T;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst InputBinding = (\n  window.Shiny ? Shiny.InputBinding : class {}\n) as typeof InputBindingType;\n\nfunction registerBinding(\n  inputBindingClass: new () => InputBindingType,\n  name: string\n): void {\n  if (window.Shiny) {\n    Shiny.inputBindings.register(new inputBindingClass(), \"bslib.\" + name);\n  }\n}\n\n// Return true if the key exists on the object and the value is not undefined.\n//\n// This method is mainly used in input bindings' `receiveMessage` method.\n// Since we know that the values are sent by Shiny via `{jsonlite}`,\n// then we know that there are no `undefined` values. `null` is possible, but not `undefined`.\nfunction hasDefinedProperty<\n  Prop extends keyof X,\n  X extends { [key: string]: any }\n>(\n  obj: X,\n  prop: Prop\n): obj is X & { [key in NonNullable<Prop>]: NotUndefined<X[key]> } {\n  return (\n    Object.prototype.hasOwnProperty.call(obj, prop) && obj[prop] !== undefined\n  );\n}\n\n// TODO: Shiny should trigger resize events when the output\n// https://github.com/rstudio/shiny/pull/3682\nfunction doWindowResizeOnElementResize(el: HTMLElement): void {\n  if ($(el).data(\"window-resize-observer\")) {\n    return;\n  }\n  const resizeEvent = new Event(\"resize\");\n  const ro = new ResizeObserver(() => {\n    window.dispatchEvent(resizeEvent);\n  });\n  ro.observe(el);\n  $(el).data(\"window-resize-observer\", ro);\n}\n\nfunction getAllFocusableChildren(el: HTMLElement): HTMLElement[] {\n  // Cross-referenced with https://allyjs.io/data-tables/focusable.html\n  const base = [\n    \"a[href]\",\n    \"area[href]\",\n    \"button\",\n    \"details summary\",\n    \"input\",\n    \"iframe\",\n    \"select\",\n    \"textarea\",\n    '[contentEditable=\"\"]',\n    '[contentEditable=\"true\"]',\n    '[contentEditable=\"TRUE\"]',\n    \"[tabindex]\",\n  ];\n  const modifiers = [':not([tabindex=\"-1\"])', \":not([disabled])\"];\n  const selectors = base.map((b) => b + modifiers.join(\"\"));\n  const focusable = el.querySelectorAll(selectors.join(\", \"));\n  return Array.from(focusable) as HTMLElement[];\n}\n\nexport {\n  InputBinding,\n  registerBinding,\n  hasDefinedProperty,\n  doWindowResizeOnElementResize,\n  getAllFocusableChildren,\n};\nexport type { HtmlDep };\n", "import { InputBinding } from \"./_utils\";\n\nShiny.addCustomMessageHandler(\"bslib.toggle-input-binary\", function (msg) {\n  // This handler was written for `toggle_switch()`, but could be used for any\n  // binary Shiny input, e.g. checkbox.\n  const el = document.getElementById(msg.id) as HTMLElement;\n  if (!el) {\n    console.warn(\"[bslib.toggle-input-binary] No element found\", msg);\n  }\n\n  const binding = $(el).data(\"shiny-input-binding\");\n  if (!(binding instanceof InputBinding)) {\n    console.warn(\"[bslib.toggle-input-binary] No input binding found\", msg);\n    return;\n  }\n\n  let value = msg.value;\n  if (typeof value === \"undefined\") {\n    value = !binding.getValue(el);\n  }\n  binding.receiveMessage(el, { value });\n});\n"],
  "mappings": ";mBAQA,IAAMA,EACJ,OAAO,MAAQ,MAAM,aAAe,KAAM,CAAC,ECP7C,MAAM,wBAAwB,4BAA6B,SAAUC,EAAK,CAGxE,IAAMC,EAAK,SAAS,eAAeD,EAAI,EAAE,EACpCC,GACH,QAAQ,KAAK,+CAAgDD,CAAG,EAGlE,IAAME,EAAU,EAAED,CAAE,EAAE,KAAK,qBAAqB,EAChD,GAAI,EAAEC,aAAmBC,GAAe,CACtC,QAAQ,KAAK,qDAAsDH,CAAG,EACtE,MACF,CAEA,IAAII,EAAQJ,EAAI,MACZ,OAAOI,GAAU,cACnBA,EAAQ,CAACF,EAAQ,SAASD,CAAE,GAE9BC,EAAQ,eAAeD,EAAI,CAAE,MAAAG,CAAM,CAAC,CACtC,CAAC",
  "names": ["InputBinding", "msg", "el", "binding", "InputBinding", "value"]
}
