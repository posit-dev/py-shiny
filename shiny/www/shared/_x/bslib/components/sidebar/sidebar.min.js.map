{
  "version": 3,
  "sources": ["../../../../srcts/src/components/_utils.ts", "../../../../srcts/src/components/_shinyResizeObserver.ts", "../../../../srcts/src/components/sidebar.ts"],
  "sourcesContent": ["import type { HtmlDep } from \"rstudio-shiny/srcts/types/src/shiny/render\";\n\nimport type { InputBinding as InputBindingType } from \"rstudio-shiny/srcts/types/src/bindings/input\";\n\n// Exclude undefined from T\ntype NotUndefined<T> = T extends undefined ? never : T;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst InputBinding = (\n  window.Shiny ? Shiny.InputBinding : class {}\n) as typeof InputBindingType;\n\nfunction registerBinding(\n  inputBindingClass: new () => InputBindingType,\n  name: string\n): void {\n  if (window.Shiny) {\n    Shiny.inputBindings.register(new inputBindingClass(), \"bslib.\" + name);\n  }\n}\n\n// Return true if the key exists on the object and the value is not undefined.\n//\n// This method is mainly used in input bindings' `receiveMessage` method.\n// Since we know that the values are sent by Shiny via `{jsonlite}`,\n// then we know that there are no `undefined` values. `null` is possible, but not `undefined`.\nfunction hasDefinedProperty<\n  Prop extends keyof X,\n  X extends { [key: string]: any }\n>(\n  obj: X,\n  prop: Prop\n): obj is X & { [key in NonNullable<Prop>]: NotUndefined<X[key]> } {\n  return (\n    Object.prototype.hasOwnProperty.call(obj, prop) && obj[prop] !== undefined\n  );\n}\n\n// TODO: Shiny should trigger resize events when the output\n// https://github.com/rstudio/shiny/pull/3682\nfunction doWindowResizeOnElementResize(el: HTMLElement): void {\n  if ($(el).data(\"window-resize-observer\")) {\n    return;\n  }\n  const resizeEvent = new Event(\"resize\");\n  const ro = new ResizeObserver(() => {\n    window.dispatchEvent(resizeEvent);\n  });\n  ro.observe(el);\n  $(el).data(\"window-resize-observer\", ro);\n}\n\nfunction getAllFocusableChildren(el: HTMLElement): HTMLElement[] {\n  // Cross-referenced with https://allyjs.io/data-tables/focusable.html\n  const base = [\n    \"a[href]\",\n    \"area[href]\",\n    \"button\",\n    \"details summary\",\n    \"input\",\n    \"iframe\",\n    \"select\",\n    \"textarea\",\n    '[contentEditable=\"\"]',\n    '[contentEditable=\"true\"]',\n    '[contentEditable=\"TRUE\"]',\n    \"[tabindex]\",\n  ];\n  const modifiers = [':not([tabindex=\"-1\"])', \":not([disabled])\"];\n  const selectors = base.map((b) => b + modifiers.join(\"\"));\n  const focusable = el.querySelectorAll(selectors.join(\", \"));\n  return Array.from(focusable) as HTMLElement[];\n}\n\nexport {\n  InputBinding,\n  registerBinding,\n  hasDefinedProperty,\n  doWindowResizeOnElementResize,\n  getAllFocusableChildren,\n};\nexport type { HtmlDep };\n", "/**\n * A resize observer that ensures Shiny outputs resize during or just after\n * their parent container size changes. Useful, in particular, for sidebar\n * transitions or for full-screen card transitions.\n *\n * @class ShinyResizeObserver\n * @typedef {ShinyResizeObserver}\n */\nclass ShinyResizeObserver {\n  /**\n   * The actual ResizeObserver instance.\n   * @private\n   * @type {ResizeObserver}\n   */\n  private resizeObserver: ResizeObserver;\n  /**\n   * An array of elements that are currently being watched by the Resize\n   * Observer.\n   *\n   * @details\n   * We don't currently have lifecycle hooks that allow us to unobserve elements\n   * when they are removed from the DOM. As a result, we need to manually check\n   * that the elements we're watching still exist in the DOM. This array keeps\n   * track of the elements we're watching so that we can check them later.\n   * @private\n   * @type {HTMLElement[]}\n   */\n  private resizeObserverEntries: HTMLElement[];\n\n  /**\n   * Watch containers for size changes and ensure that Shiny outputs and\n   * htmlwidgets within resize appropriately.\n   *\n   * @details\n   * The ShinyResizeObserver is used to watch the containers, such as Sidebars\n   * and Cards for size changes, in particular when the sidebar state is toggled\n   * or the card body is expanded full screen. It performs two primary tasks:\n   *\n   * 1. Dispatches a `resize` event on the window object. This is necessary to\n   *    ensure that Shiny outputs resize appropriately. In general, the window\n   *    resizing is throttled and the output update occurs when the transition\n   *    is complete.\n   * 2. If an output with a resize method on the output binding is detected, we\n   *    directly call the `.onResize()` method of the binding. This ensures that\n   *    htmlwidgets transition smoothly. In static mode, htmlwidgets does this\n   *    already.\n   *\n   * @note\n   * This resize observer also handles race conditions in some complex\n   * fill-based layouts with multiple outputs (e.g., plotly), where shiny\n   * initializes with the correct sizing, but in-between the 1st and last\n   * renderValue(), the size of the output containers can change, meaning every\n   * output but the 1st gets initialized with the wrong size during their\n   * renderValue(). Then, after the render phase, shiny won't know to trigger a\n   * resize since all the widgets will return to their original size (and thus,\n   * Shiny thinks there isn't any resizing to do). The resize observer works\n   * around this by ensuring that the output is resized whenever its container\n   * size changes.\n   * @constructor\n   */\n  constructor() {\n    this.resizeObserverEntries = [];\n    this.resizeObserver = new ResizeObserver((entries) => {\n      const resizeEvent = new Event(\"resize\");\n      window.dispatchEvent(resizeEvent);\n\n      // the rest of this callback is only relevant in Shiny apps\n      if (!window.Shiny) return;\n\n      const resized = [] as HTMLElement[];\n\n      for (const entry of entries) {\n        if (!(entry.target instanceof HTMLElement)) continue;\n        if (!entry.target.querySelector(\".shiny-bound-output\")) continue;\n\n        entry.target\n          .querySelectorAll<HTMLElement>(\".shiny-bound-output\")\n          .forEach((el) => {\n            if (resized.includes(el)) return;\n\n            const { binding, onResize } = $(el).data(\"shinyOutputBinding\");\n            if (!binding || !binding.resize) return;\n\n            // if this output is owned by another observer, skip it\n            const owner = (el as any).shinyResizeObserver;\n            if (owner && owner !== this) return;\n            // mark this output as owned by this shinyResizeObserver instance\n            if (!owner) (el as any).shinyResizeObserver = this;\n\n            // trigger immediate resizing of outputs with a resize method\n            onResize(el);\n            // only once per output and resize event\n            resized.push(el);\n\n            // set plot images to 100% width temporarily during the transition\n            if (!el.classList.contains(\"shiny-plot-output\")) return;\n            const img = el.querySelector<HTMLImageElement>(\n              'img:not([width=\"100%\"])'\n            );\n            if (img) img.setAttribute(\"width\", \"100%\");\n          });\n      }\n    });\n  }\n\n  /**\n   * Observe an element for size changes.\n   * @param {HTMLElement} el - The element to observe.\n   */\n  observe(el: HTMLElement): void {\n    this.resizeObserver.observe(el);\n    this.resizeObserverEntries.push(el);\n  }\n\n  /**\n   * Stop observing an element for size changes.\n   * @param {HTMLElement} el - The element to stop observing.\n   */\n  unobserve(el: HTMLElement): void {\n    const idxEl = this.resizeObserverEntries.indexOf(el);\n    if (idxEl < 0) return;\n\n    this.resizeObserver.unobserve(el);\n    this.resizeObserverEntries.splice(idxEl, 1);\n  }\n\n  /**\n   * This method checks that we're not continuing to watch elements that no\n   * longer exist in the DOM. If any are found, we stop observing them and\n   * remove them from our array of observed elements.\n   *\n   * @private\n   * @static\n   */\n  flush(): void {\n    this.resizeObserverEntries.forEach((el) => {\n      if (!document.body.contains(el)) this.unobserve(el);\n    });\n  }\n}\n\nexport { ShinyResizeObserver };\n", "import { InputBinding, registerBinding } from \"./_utils\";\nimport { ShinyResizeObserver } from \"./_shinyResizeObserver\";\n\n/**\n * Methods for programmatically toggling the state of the sidebar. These methods\n * describe the desired state of the sidebar: `\"close\"` and `\"open\"` transition\n * the sidebar to the desired state, unless the sidebar is already in that\n * state. `\"toggle\"` transitions the sidebar to the state opposite of its\n * current state.\n * @typedef {SidebarToggleMethod}\n */\ntype SidebarToggleMethod = \"close\" | \"open\" | \"toggle\";\n\n/**\n * Data received by the input binding's `receiveMessage` method.\n * @typedef {SidebarMessageData}\n */\ntype SidebarMessageData = {\n  method: SidebarToggleMethod;\n};\n\n/**\n * The DOM elements that make up the sidebar. `main`, `sidebar`, and `toggle`\n * are all direct children of `container` (in that order).\n * @interface SidebarComponents\n * @typedef {SidebarComponents}\n */\ninterface SidebarComponents {\n  /**\n   * The `layout_sidebar()` parent container, with class\n   * `Sidebar.classes.LAYOUT`.\n   * @type {HTMLElement}\n   */\n  container: HTMLElement;\n  /**\n   * The main content area of the sidebar layout.\n   * @type {HTMLElement}\n   */\n  main: HTMLElement;\n  /**\n   * The sidebar container of the sidebar layout.\n   * @type {HTMLElement}\n   */\n  sidebar: HTMLElement;\n  /**\n   * The toggle button that is used to toggle the sidebar state.\n   * @type {HTMLElement}\n   */\n  toggle: HTMLElement;\n}\n\n/**\n * The bslib sidebar component class. This class is only used for collapsible\n * sidebars.\n *\n * @class Sidebar\n * @typedef {Sidebar}\n */\nclass Sidebar {\n  /**\n   * The DOM elements that make up the sidebar, see `SidebarComponents`.\n   * @private\n   * @type {SidebarComponents}\n   */\n  private layout: SidebarComponents;\n\n  /**\n   * A Shiny-specific resize observer that ensures Shiny outputs in the main\n   * content areas of the sidebar resize appropriately.\n   * @private\n   * @type {ShinyResizeObserver}\n   * @static\n   */\n  private static shinyResizeObserver = new ShinyResizeObserver();\n\n  /**\n   * Creates an instance of a collapsible bslib Sidebar.\n   * @constructor\n   * @param {HTMLElement} container\n   */\n  constructor(container: HTMLElement) {\n    Sidebar.instanceMap.set(container, this);\n    this.layout = {\n      container,\n      main: container.querySelector(\":scope > .main\") as HTMLElement,\n      sidebar: container.querySelector(\":scope > .sidebar\") as HTMLElement,\n      toggle: container.querySelector(\n        \":scope > .collapse-toggle\"\n      ) as HTMLElement,\n    } as SidebarComponents;\n\n    if (!this.layout.toggle) {\n      throw new Error(\"Tried to initialize a non-collapsible sidebar.\");\n    }\n\n    const sideAccordion = this.layout.sidebar.querySelector(\n      \":scope > .sidebar-content > .accordion\"\n    );\n    if (sideAccordion) sideAccordion.classList.add(\"accordion-flush\");\n\n    this._initEventListeners();\n    this._initSidebarCounters();\n    this._initDesktop();\n\n    // Start watching the main content area for size changes to ensure Shiny\n    // outputs resize appropriately during sidebar transitions.\n    Sidebar.shinyResizeObserver.observe(this.layout.main);\n\n    container.removeAttribute(\"data-bslib-sidebar-init\");\n    const initScript = container.querySelector(\n      \":scope > script[data-bslib-sidebar-init]\"\n    );\n    if (initScript) {\n      container.removeChild(initScript);\n    }\n  }\n\n  /**\n   * Read the current state of the sidebar. Note that, when calling this method,\n   * the sidebar may be transitioning into the state returned by this method.\n   *\n   * @description\n   * The sidebar state works as follows, starting from the open state. When the\n   * sidebar is closed:\n   * 1. We add both the `COLLAPSE` and `TRANSITIONING` classes to the sidebar.\n   * 2. The sidebar collapse begins to animate. On desktop devices, and where it\n   *    is supported, we transition the `grid-template-columns` property of the\n   *    sidebar layout. On mobile, the sidebar is hidden immediately. In both\n   *    cases, the collapse icon rotates and we use this rotation to determine\n   *    when the transition is complete.\n   * 3. If another sidebar state toggle is requested while closing the sidebar,\n   *    we remove the `COLLAPSE` class and the animation immediately starts to\n   *    reverse.\n   * 4. When the `transition` is complete, we remove the `TRANSITIONING` class.\n   * @readonly\n   * @type {boolean}\n   */\n  get isClosed(): boolean {\n    return this.layout.container.classList.contains(Sidebar.classes.COLLAPSE);\n  }\n\n  /**\n   * Static classes related to the sidebar layout or state.\n   * @public\n   * @static\n   * @readonly\n   * @type {{ LAYOUT: string; COLLAPSE: string; TRANSITIONING: string; }}\n   */\n  public static readonly classes = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    LAYOUT: \"bslib-sidebar-layout\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    COLLAPSE: \"sidebar-collapsed\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    TRANSITIONING: \"transitioning\",\n  };\n\n  /**\n   * If sidebars are initialized before the DOM is ready, we re-schedule the\n   * initialization to occur on DOMContentLoaded.\n   * @private\n   * @static\n   * @type {boolean}\n   */\n  private static onReadyScheduled = false;\n  /**\n   * A map of initialized sidebars to their respective Sidebar instances.\n   * @private\n   * @static\n   * @type {WeakMap<HTMLElement, Sidebar>}\n   */\n  private static instanceMap: WeakMap<HTMLElement, Sidebar> = new WeakMap();\n\n  /**\n   * Given a sidebar container, return the Sidebar instance associated with it.\n   * @public\n   * @static\n   * @param {HTMLElement} el\n   * @returns {(Sidebar | undefined)}\n   */\n  public static getInstance(el: HTMLElement): Sidebar | undefined {\n    return Sidebar.instanceMap.get(el);\n  }\n\n  /**\n   * Initialize all collapsible sidebars on the page.\n   * @public\n   * @static\n   * @param {boolean} [flushResizeObserver=true] When `true`, we remove\n   * non-existent elements from the ResizeObserver. This is required\n   * periodically to prevent memory leaks. To avoid over-checking, we only flush\n   * the ResizeObserver when initializing sidebars after page load.\n   */\n  public static initCollapsibleAll(flushResizeObserver = true): void {\n    if (document.readyState === \"loading\") {\n      if (!Sidebar.onReadyScheduled) {\n        Sidebar.onReadyScheduled = true;\n        document.addEventListener(\"DOMContentLoaded\", () => {\n          Sidebar.initCollapsibleAll(false);\n        });\n      }\n      return;\n    }\n\n    const initSelector = `.${Sidebar.classes.LAYOUT}[data-bslib-sidebar-init]`;\n    if (!document.querySelector(initSelector)) {\n      // no sidebars to initialize\n      return;\n    }\n\n    if (flushResizeObserver) Sidebar.shinyResizeObserver.flush();\n\n    const containers = document.querySelectorAll(initSelector);\n    containers.forEach((container) => new Sidebar(container as HTMLElement));\n  }\n\n  /**\n   * Initialize event listeners for the sidebar toggle button.\n   * @private\n   */\n  private _initEventListeners(): void {\n    const { toggle } = this.layout;\n\n    toggle.addEventListener(\"click\", (ev) => {\n      ev.preventDefault();\n      this.toggle(\"toggle\");\n    });\n\n    // Remove the transitioning class when the transition ends. We watch the\n    // collapse toggle icon because it's guaranteed to transition, whereas the\n    // sidebar doesn't animate on mobile (or in browsers where animating\n    // grid-template-columns is not supported).\n    toggle\n      .querySelector(\".collapse-icon\")\n      ?.addEventListener(\"transitionend\", () => this._finalizeState());\n  }\n\n  /**\n   * Initialize nested sidebar counters.\n   *\n   * @description\n   * This function walks up the DOM tree, adding CSS variables to each direct\n   * parent sidebar layout that count the layout's position in the stack of\n   * nested layouts. We use these counters to keep the collapse toggles from\n   * overlapping. Note that always-open sidebars that don't have collapse\n   * toggles break the chain of nesting.\n   * @private\n   */\n  private _initSidebarCounters(): void {\n    const { container } = this.layout;\n\n    const selectorChildLayouts =\n      `.${Sidebar.classes.LAYOUT}` +\n      \"> .main > \" +\n      `.${Sidebar.classes.LAYOUT}:not([data-bslib-sidebar-open=\"always\"])`;\n\n    const isInnermostLayout =\n      container.querySelector(selectorChildLayouts) === null;\n\n    if (!isInnermostLayout) {\n      // There are sidebar layouts nested within this layout; defer to children\n      return;\n    }\n\n    function nextSidebarParent(el: HTMLElement | null): HTMLElement | null {\n      el = el ? el.parentElement : null;\n      if (el && el.classList.contains(\"main\")) {\n        // .bslib-sidebar-layout > .main > .bslib-sidebar-layout\n        el = el.parentElement;\n      }\n      if (el && el.classList.contains(Sidebar.classes.LAYOUT)) {\n        return el;\n      }\n      return null;\n    }\n\n    const layouts = [container];\n    let parent = nextSidebarParent(container);\n\n    while (parent) {\n      // Add parent to front of layouts array, so we sort outer -> inner\n      layouts.unshift(parent);\n      parent = nextSidebarParent(parent);\n    }\n\n    const count = { left: 0, right: 0 };\n    layouts.forEach(function (x: HTMLElement, i: number): void {\n      x.style.setProperty(\"--bslib-sidebar-counter\", i.toString());\n      const isRight = x.classList.contains(\"sidebar-right\");\n      const thisCount = isRight ? count.right++ : count.left++;\n      x.style.setProperty(\n        \"--bslib-sidebar-overlap-counter\",\n        thisCount.toString()\n      );\n    });\n  }\n\n  /**\n   * Initialize the sidebar's initial state when `open = \"desktop\"`.\n   * @private\n   */\n  private _initDesktop(): void {\n    const { container } = this.layout;\n    // If sidebar is marked open='desktop'...\n    if (container.dataset.bslibSidebarOpen?.trim() !== \"desktop\") {\n      return;\n    }\n\n    // then close sidebar on mobile\n    const initCollapsed = window\n      .getComputedStyle(container)\n      .getPropertyValue(\"--bslib-sidebar-js-init-collapsed\");\n\n    if (initCollapsed.trim() === \"true\") {\n      this.toggle(\"close\");\n    }\n  }\n\n  /**\n   * Toggle the sidebar's open/closed state.\n   * @public\n   * @param {SidebarToggleMethod | undefined} method Whether to `\"open\"`,\n   * `\"close\"` or `\"toggle\"` the sidebar. If `.toggle()` is called without an\n   * argument, it will toggle the sidebar's state.\n   */\n  public toggle(method: SidebarToggleMethod | undefined): void {\n    if (typeof method === \"undefined\") {\n      method = \"toggle\";\n    }\n\n    const { container, sidebar } = this.layout;\n    const isClosed = this.isClosed;\n\n    if ([\"open\", \"close\", \"toggle\"].indexOf(method) === -1) {\n      throw new Error(`Unknown method ${method}`);\n    }\n\n    if (method === \"toggle\") {\n      method = isClosed ? \"open\" : \"close\";\n    }\n\n    if ((isClosed && method === \"close\") || (!isClosed && method === \"open\")) {\n      // nothing to do, sidebar is already in the desired state\n      return;\n    }\n\n    if (method === \"open\") {\n      // unhide sidebar immediately when opening,\n      // otherwise the sidebar is hidden on transitionend\n      sidebar.hidden = false;\n    }\n\n    // Add a transitioning class just before adding COLLAPSE_CLASS since we want\n    // some of the transitioning styles to apply before the collapse state\n    container.classList.add(Sidebar.classes.TRANSITIONING);\n    container.classList.toggle(Sidebar.classes.COLLAPSE);\n  }\n\n  /**\n   * When the sidebar open/close transition ends, finalize the sidebar's state.\n   * @private\n   */\n  private _finalizeState(): void {\n    const { container, sidebar, toggle } = this.layout;\n    container.classList.remove(Sidebar.classes.TRANSITIONING);\n    sidebar.hidden = this.isClosed;\n    toggle.setAttribute(\"aria-expanded\", this.isClosed ? \"false\" : \"true\");\n\n    // Send browser-native event with updated sidebar state\n    const event = new CustomEvent(\"bslib.sidebar\", {\n      bubbles: true,\n      detail: { open: !this.isClosed },\n    });\n    sidebar.dispatchEvent(event);\n\n    // Trigger Shiny input and output binding events\n    $(sidebar).trigger(\"toggleCollapse.sidebarInputBinding\");\n    $(sidebar).trigger(this.isClosed ? \"hidden\" : \"shown\");\n  }\n}\n\n/**\n * A Shiny input binding for a sidebar.\n * @class SidebarInputBinding\n * @typedef {SidebarInputBinding}\n * @extends {InputBinding}\n */\nclass SidebarInputBinding extends InputBinding {\n  find(scope: HTMLElement) {\n    return $(scope).find(`.${Sidebar.classes.LAYOUT} > .bslib-sidebar-input`);\n  }\n\n  getValue(el: HTMLElement): boolean {\n    const sb = Sidebar.getInstance(el.parentElement as HTMLElement);\n    if (!sb) return false;\n    return !sb.isClosed;\n  }\n\n  setValue(el: HTMLElement, value: boolean): void {\n    const method = value ? \"open\" : \"close\";\n    this.receiveMessage(el, { method });\n  }\n\n  subscribe(el: HTMLElement, callback: (x: boolean) => void) {\n    $(el).on(\n      \"toggleCollapse.sidebarInputBinding\",\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      function (event) {\n        callback(true);\n      }\n    );\n  }\n\n  unsubscribe(el: HTMLElement) {\n    $(el).off(\".sidebarInputBinding\");\n  }\n\n  receiveMessage(el: HTMLElement, data: SidebarMessageData) {\n    const sb = Sidebar.getInstance(el.parentElement as HTMLElement);\n    if (sb) sb.toggle(data.method);\n  }\n}\n\nregisterBinding(SidebarInputBinding, \"sidebar\");\n\n// attach Sidebar class to window for global usage\n(window as any).bslib = (window as any).bslib || {};\n(window as any).bslib.Sidebar = Sidebar;\n"],
  "mappings": ";mBAQA,IAAMA,EACJ,OAAO,MAAQ,MAAM,aAAe,KAAM,CAAC,EAG7C,SAASC,EACPC,EACAC,EACM,CACF,OAAO,OACT,MAAM,cAAc,SAAS,IAAID,EAAqB,SAAWC,CAAI,CAEzE,CCXA,IAAMC,EAAN,KAA0B,CAoDxB,aAAc,CACZ,KAAK,sBAAwB,CAAC,EAC9B,KAAK,eAAiB,IAAI,eAAgBC,GAAY,CACpD,IAAMC,EAAc,IAAI,MAAM,QAAQ,EAItC,GAHA,OAAO,cAAcA,CAAW,EAG5B,CAAC,OAAO,MAAO,OAEnB,IAAMC,EAAU,CAAC,EAEjB,QAAWC,KAASH,EACZG,EAAM,kBAAkB,aACzBA,EAAM,OAAO,cAAc,qBAAqB,GAErDA,EAAM,OACH,iBAA8B,qBAAqB,EACnD,QAASC,GAAO,CACf,GAAIF,EAAQ,SAASE,CAAE,EAAG,OAE1B,GAAM,CAAE,QAAAC,EAAS,SAAAC,CAAS,EAAI,EAAEF,CAAE,EAAE,KAAK,oBAAoB,EAC7D,GAAI,CAACC,GAAW,CAACA,EAAQ,OAAQ,OAGjC,IAAME,EAASH,EAAW,oBAW1B,GAVIG,GAASA,IAAU,OAElBA,IAAQH,EAAW,oBAAsB,MAG9CE,EAASF,CAAE,EAEXF,EAAQ,KAAKE,CAAE,EAGX,CAACA,EAAG,UAAU,SAAS,mBAAmB,GAAG,OACjD,IAAMI,EAAMJ,EAAG,cACb,yBACF,EACII,GAAKA,EAAI,aAAa,QAAS,MAAM,CAC3C,CAAC,CAEP,CAAC,CACH,CAMA,QAAQJ,EAAuB,CAC7B,KAAK,eAAe,QAAQA,CAAE,EAC9B,KAAK,sBAAsB,KAAKA,CAAE,CACpC,CAMA,UAAUA,EAAuB,CAC/B,IAAMK,EAAQ,KAAK,sBAAsB,QAAQL,CAAE,EAC/CK,EAAQ,IAEZ,KAAK,eAAe,UAAUL,CAAE,EAChC,KAAK,sBAAsB,OAAOK,EAAO,CAAC,EAC5C,CAUA,OAAc,CACZ,KAAK,sBAAsB,QAASL,GAAO,CACpC,SAAS,KAAK,SAASA,CAAE,GAAG,KAAK,UAAUA,CAAE,CACpD,CAAC,CACH,CACF,ECjFA,IAAMM,EAAN,KAAc,CAsBZ,YAAYC,EAAwB,CAWlC,GAVAD,EAAQ,YAAY,IAAIC,EAAW,IAAI,EACvC,KAAK,OAAS,CACZ,UAAAA,EACA,KAAMA,EAAU,cAAc,gBAAgB,EAC9C,QAASA,EAAU,cAAc,mBAAmB,EACpD,OAAQA,EAAU,cAChB,2BACF,CACF,EAEI,CAAC,KAAK,OAAO,OACf,MAAM,IAAI,MAAM,gDAAgD,EAGlE,IAAMC,EAAgB,KAAK,OAAO,QAAQ,cACxC,wCACF,EACIA,GAAeA,EAAc,UAAU,IAAI,iBAAiB,EAEhE,KAAK,oBAAoB,EACzB,KAAK,qBAAqB,EAC1B,KAAK,aAAa,EAIlBF,EAAQ,oBAAoB,QAAQ,KAAK,OAAO,IAAI,EAEpDC,EAAU,gBAAgB,yBAAyB,EACnD,IAAME,EAAaF,EAAU,cAC3B,0CACF,EACIE,GACFF,EAAU,YAAYE,CAAU,CAEpC,CAsBA,IAAI,UAAoB,CACtB,OAAO,KAAK,OAAO,UAAU,UAAU,SAASH,EAAQ,QAAQ,QAAQ,CAC1E,CAyCA,OAAc,YAAYI,EAAsC,CAC9D,OAAOJ,EAAQ,YAAY,IAAII,CAAE,CACnC,CAWA,OAAc,mBAAmBC,EAAsB,GAAY,CACjE,GAAI,SAAS,aAAe,UAAW,CAChCL,EAAQ,mBACXA,EAAQ,iBAAmB,GAC3B,SAAS,iBAAiB,mBAAoB,IAAM,CAClDA,EAAQ,mBAAmB,EAAK,CAClC,CAAC,GAEH,MACF,CAEA,IAAMM,EAAe,IAAIN,EAAQ,QAAQ,kCACzC,GAAI,CAAC,SAAS,cAAcM,CAAY,EAEtC,OAGED,GAAqBL,EAAQ,oBAAoB,MAAM,EAExC,SAAS,iBAAiBM,CAAY,EAC9C,QAASL,GAAc,IAAID,EAAQC,CAAwB,CAAC,CACzE,CAMQ,qBAA4B,CA5NtC,IAAAM,EA6NI,GAAM,CAAE,OAAAC,CAAO,EAAI,KAAK,OAExBA,EAAO,iBAAiB,QAAUC,GAAO,CACvCA,EAAG,eAAe,EAClB,KAAK,OAAO,QAAQ,CACtB,CAAC,GAMDF,EAAAC,EACG,cAAc,gBAAgB,IADjC,MAAAD,EAEI,iBAAiB,gBAAiB,IAAM,KAAK,eAAe,EAClE,CAaQ,sBAA6B,CACnC,GAAM,CAAE,UAAAN,CAAU,EAAI,KAAK,OAErBS,EACJ,IAAIV,EAAQ,QAAQ,oBAEhBA,EAAQ,QAAQ,iDAKtB,GAAI,EAFFC,EAAU,cAAcS,CAAoB,IAAM,MAIlD,OAGF,SAASC,EAAkBP,EAA4C,CAMrE,OALAA,EAAKA,EAAKA,EAAG,cAAgB,KACzBA,GAAMA,EAAG,UAAU,SAAS,MAAM,IAEpCA,EAAKA,EAAG,eAENA,GAAMA,EAAG,UAAU,SAASJ,EAAQ,QAAQ,MAAM,EAC7CI,EAEF,IACT,CAEA,IAAMQ,EAAU,CAACX,CAAS,EACtBY,EAASF,EAAkBV,CAAS,EAExC,KAAOY,GAELD,EAAQ,QAAQC,CAAM,EACtBA,EAASF,EAAkBE,CAAM,EAGnC,IAAMC,EAAQ,CAAE,KAAM,EAAG,MAAO,CAAE,EAClCF,EAAQ,QAAQ,SAAUG,EAAgBC,EAAiB,CACzDD,EAAE,MAAM,YAAY,0BAA2BC,EAAE,SAAS,CAAC,EAE3D,IAAMC,EADUF,EAAE,UAAU,SAAS,eAAe,EACxBD,EAAM,QAAUA,EAAM,OAClDC,EAAE,MAAM,YACN,kCACAE,EAAU,SAAS,CACrB,CACF,CAAC,CACH,CAMQ,cAAqB,CA7S/B,IAAAV,EA8SI,GAAM,CAAE,UAAAN,CAAU,EAAI,KAAK,OAE3B,KAAIM,EAAAN,EAAU,QAAQ,mBAAlB,YAAAM,EAAoC,UAAW,UACjD,OAIoB,OACnB,iBAAiBN,CAAS,EAC1B,iBAAiB,mCAAmC,EAErC,KAAK,IAAM,QAC3B,KAAK,OAAO,OAAO,CAEvB,CASO,OAAOiB,EAA+C,CACvD,OAAOA,GAAW,cACpBA,EAAS,UAGX,GAAM,CAAE,UAAAjB,EAAW,QAAAkB,CAAQ,EAAI,KAAK,OAC9BC,EAAW,KAAK,SAEtB,GAAI,CAAC,OAAQ,QAAS,QAAQ,EAAE,QAAQF,CAAM,IAAM,GAClD,MAAM,IAAI,MAAM,kBAAkBA,GAAQ,EAGxCA,IAAW,WACbA,EAASE,EAAW,OAAS,SAG1B,EAAAA,GAAYF,IAAW,SAAa,CAACE,GAAYF,IAAW,UAK7DA,IAAW,SAGbC,EAAQ,OAAS,IAKnBlB,EAAU,UAAU,IAAID,EAAQ,QAAQ,aAAa,EACrDC,EAAU,UAAU,OAAOD,EAAQ,QAAQ,QAAQ,EACrD,CAMQ,gBAAuB,CAC7B,GAAM,CAAE,UAAAC,EAAW,QAAAkB,EAAS,OAAAX,CAAO,EAAI,KAAK,OAC5CP,EAAU,UAAU,OAAOD,EAAQ,QAAQ,aAAa,EACxDmB,EAAQ,OAAS,KAAK,SACtBX,EAAO,aAAa,gBAAiB,KAAK,SAAW,QAAU,MAAM,EAGrE,IAAMa,EAAQ,IAAI,YAAY,gBAAiB,CAC7C,QAAS,GACT,OAAQ,CAAE,KAAM,CAAC,KAAK,QAAS,CACjC,CAAC,EACDF,EAAQ,cAAcE,CAAK,EAG3B,EAAEF,CAAO,EAAE,QAAQ,oCAAoC,EACvD,EAAEA,CAAO,EAAE,QAAQ,KAAK,SAAW,SAAW,OAAO,CACvD,CACF,EAjUMG,EAANtB,EAAMsB,EAeW,oBAAsB,IAAIC,EAfrCD,EA0FmB,QAAU,CAE/B,OAAQ,uBAER,SAAU,oBAEV,cAAe,eACjB,EAjGIA,EA0GW,iBAAmB,GA1G9BA,EAiHW,YAA6C,IAAI,QAwNlE,IAAME,EAAN,cAAkCC,CAAa,CAC7C,KAAKC,EAAoB,CACvB,OAAO,EAAEA,CAAK,EAAE,KAAK,IAAIJ,EAAQ,QAAQ,+BAA+B,CAC1E,CAEA,SAASlB,EAA0B,CACjC,IAAMuB,EAAKL,EAAQ,YAAYlB,EAAG,aAA4B,EAC9D,OAAKuB,EACE,CAACA,EAAG,SADK,EAElB,CAEA,SAASvB,EAAiBwB,EAAsB,CAC9C,IAAMV,EAASU,EAAQ,OAAS,QAChC,KAAK,eAAexB,EAAI,CAAE,OAAAc,CAAO,CAAC,CACpC,CAEA,UAAUd,EAAiByB,EAAgC,CACzD,EAAEzB,CAAE,EAAE,GACJ,qCAEA,SAAUiB,EAAO,CACfQ,EAAS,EAAI,CACf,CACF,CACF,CAEA,YAAYzB,EAAiB,CAC3B,EAAEA,CAAE,EAAE,IAAI,sBAAsB,CAClC,CAEA,eAAeA,EAAiB0B,EAA0B,CACxD,IAAMH,EAAKL,EAAQ,YAAYlB,EAAG,aAA4B,EAC1DuB,GAAIA,EAAG,OAAOG,EAAK,MAAM,CAC/B,CACF,EAEAC,EAAgBP,EAAqB,SAAS,EAG7C,OAAe,MAAS,OAAe,OAAS,CAAC,EACjD,OAAe,MAAM,QAAUF",
  "names": ["InputBinding", "registerBinding", "inputBindingClass", "name", "ShinyResizeObserver", "entries", "resizeEvent", "resized", "entry", "el", "binding", "onResize", "owner", "img", "idxEl", "_Sidebar", "container", "sideAccordion", "initScript", "el", "flushResizeObserver", "initSelector", "_a", "toggle", "ev", "selectorChildLayouts", "nextSidebarParent", "layouts", "parent", "count", "x", "i", "thisCount", "method", "sidebar", "isClosed", "event", "Sidebar", "ShinyResizeObserver", "SidebarInputBinding", "InputBinding", "scope", "sb", "value", "callback", "data", "registerBinding"]
}
