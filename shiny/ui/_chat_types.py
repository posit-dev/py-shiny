from __future__ import annotations

from typing import Literal, NotRequired, Optional, TypedDict

Role = Literal["assistant", "user", "system", "tool"]


class Function(TypedDict):
    name: Optional[str]
    arguments: Optional[
        str
    ]  # The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.


class ToolCall(TypedDict):
    id: Optional[str]
    function: Optional[Function]
    finished: bool


# TODO: content should probably be [{"type": "text", "content": "..."}, {"type": "image", ...}]
# in order to support multiple content types...
class ChatMessage(TypedDict):
    content: str
    role: Role
    tool_call: NotRequired[ToolCall]


# A message once transformed have been applied
class TransformedMessage(TypedDict):
    content_client: str
    content_server: str
    role: Role
    transform_key: Literal["content_client", "content_server"]
    pre_transform_key: Literal["content_client", "content_server"]
    tool_calls: NotRequired[list[ToolCall]]


# A message that can be sent to the client
class ClientMessage(ChatMessage):
    content_type: Literal["markdown", "html"]
    chunk_type: Literal["message_start", "message_end"] | None


class ToolMessage:
    role: Literal["tool"]
    content: str  # The result of the tool call
    tool_call_id: str
